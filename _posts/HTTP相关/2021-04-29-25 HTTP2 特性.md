---
layout:     post
title:     25 HTTP/2 特性
subtitle:  
date:       2021-04-29
author:     
header-img: 
catalog: true
tags:
    - < HTTP相关 >
typora-root-url: ..
---


# 25 HTTP/2 特性

- 总结

    1、HTTP 协议 <u>取消了小版本号</u>，所以 `HTTP/2` 的正式名字不是 2.0

    2、HTTP/2 在 **语义** 上兼容 HTTP/1.1，保留了请求方法、URI 等传统概念

    3、HTTP/2 使用 `HPACK` 算法（字典表） **<span style="color:red">压缩头部信息</span>**，消除冗余数据节约带宽

    4、HTTP/2 的消息不再是 `Header+Body` 的形式，而是分散为多个 **<span style="color:red">二进制帧</span>**

    5、HTTP/2 使用 **虚拟的流** 传输消息，解决了困扰多年的 **队头阻塞** 问题（在应用层解决，但是传输层 TCP 协议中仍旧存在队头阻塞），同时实现了 **<span style="color:red">多路复用</span>**，提高连接的利用率

    6、HTTP/2 也增强了安全性，要求至少是 TLS1.2，而且禁用了很多不安全的密码套件

    7、设置请求的优先级

    8、**<span style="color:red">服务器推送</span>**

## 版本号名字
 HTTP/2 工作组明确只使用大版本号，每当发布新版本的 HTTP 协议都会有本质的不同，绝不会有零敲碎打的小改良

 ## 兼容 HTTP/1
由于HTTPS已经在安全方面做的非常好了，所以 HTTP/2 的唯一目标就是 **改进性能**

因为必须要保持功能上的兼容，所以 HTTP/2 把 HTTP 分解成了语义和语法两个部分，**语义层** 不做改动，与 HTTP/1 完全一致（即 RFC7231）；在 **语法层** 做了天翻地覆的改造，**完全变更了 HTTP 报文的传输格式**。

### 头部压缩
- 问题 - 大头儿子：

    报文 Header 一般会携带 `User Agent`、 `Cookie`、 `Accept` 、`Server`等许多固定的头字段，多达几百字节甚至上千字节；但 Body 却经常只有几十字节（比如 GET 请求、204/301/304 响应）

- 解决办法：

    开发了专门的 **HPACK算法**，在客户端和服务器两端建立 **字典**，用索引号表示重复的字符串，还釆用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率

### 二进制格式
- 变化：

    HTTP/1 里纯文本形式的报文 --> HTTP/2 全面采用 **二进制格式**
    多义性（大小写、空白字符、换行等） --> 无歧义，体积小，速度快

- 实现：

    把 TCP 协议的部分特性挪到了应用层，原来的 `Header+Body` 的消息打散为数个小片的二进制 **帧（Frame）**，用 `HEADERS` 帧存放头数据、`DATA` 帧存放实体数据


## 流和帧
- 消息的碎片到达目的地后应该怎么组装起来呢?

    虚拟的流：HTTP/2 为此定义了一个 `流（Stream）` 的概念，它是 **二进制帧的双向传输序列**，同一个消息往返的帧会分配一个唯一的 **流 ID**

因为 **流** 是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP 连接上用 **流** 同时发送 **多个碎片化的消息**，这就是常说的 **多路复用**（ Multiplexing）—— **<span style="color:red">多个往返通信都复用一个连接来处理</span>**。

在 **流** 的层面上看，消息是一些有序的 **帧** 序列，而在 **连接** 的层面上看，消息却是乱序收发的 **帧**。多个请求 / 响应之间没有了顺序关系，不需要排队等待，也就不会再出现 请求-应答模型下的 **队头阻塞**【一个数据包影响了一堆数据包，它不来大家都走不了】问题（在应用层解决，但是传输层 TCP 协议中仍旧存在队头阻塞），降低了延迟，大幅度提高了连接的利用率。

<img src="/../img/assets_2019/image-20210429140038297.png" alt="image-20210429140038297" style="zoom:45%;" />


## 设置请求的优先级
HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求


## 服务器推送

HTTP/2 还在一定程度上 <u>改变了传统的 **请求 - 应答工作模式**</u>，服务器不再是完全被动地响应请求，也可以 **新建“流”主动向客户端发送消息**。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为 **<span style="color:red">服务器推送</span>**（Server Push，也叫 Cache Push）。

## 强化安全
-   HTTP/2 延续了 HTTP/1 的 **明文** 特点，**可以像以前一样使用明文传输数据**，不强制使用加密通信，不过格式还是二进制，只是不需要解密

-   由于 HTTPS 的大势所趋，互联网上能看到的 **HTTP/2 一般都是使用https协议** 名，跑在 TLS 上面

-   为了区分 **加密和明文** 这两个不同的版本，HTTP/2 协议定义了两个字符串标识符：`h2` -- 加密的 HTTP/2，`h2c` -- 明文的 HTTP/2，多出的那个字母 `c` 的意思是 `clear text`

-   在 HTTP/2 标准制定的时候（2015 年）已经发现了很多 SSL/TLS 的弱点，而新的 TLS1.3 还未发布，所以加密版本的 HTTP/2 **在安全方面做了强化**，要求下层的通信协议 **必须是 TLS1.2 以上**，还要支持 **前向安全和 SNI**，并且把几百个弱密码套件列入了“黑名单”，比如 DES、RC4、CBC、SHA-1 都不能在 HTTP/2 里使用，相当于底层用的是“TLS1.25”

<img src="/../img/assets_2019/image-20210429140147039.png" alt="image-20210429140147039" style="zoom:30%;" />