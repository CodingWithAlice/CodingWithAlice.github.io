---
layout:     post
title:     Axios 1.x 迁移指南
subtitle:  
date:       2026-02-08
author:     
header-img: 
catalog: true
tags:
    - < HTTP相关 >
typora-root-url: ..
---



# Axios 1.x **迁移**指南

源 github 网址：[axios/MIGRATION_GUIDE.md at v1.x · axios/axios · GitHub](https://github.com/axios/axios/blob/v1.x/MIGRATION_GUIDE.md)

### 一、Breaking Changes

#### 1、错误处理

##### 差异：1.x 版本统一了错误处理流程，要求开发者必须明确决定错误是在调用处处理，还是在拦截器中处理后继续抛出给调用处

- 响应拦截器不能再默默吞下错误

- 每个 API调用都必须显式处理错误，否则它们就会变成未处理的 rejected 状态的 Promise

- 集中式错误处理需要新的模式

##### 0.x  的做法

有些 http 的错误不会抛出

```js
// Axios 0.x - Some HTTP error codes didn't throw
axios.get('/api/data')
  .then(response => {
    // Response interceptor could handle all errors 响应拦截器可以处理所有错误
    console.log('Success:', response.data);
  });
 
// Response interceptor handled everything 响应拦截器处理了一切
axios.interceptors.response.use(
  response => response,
  error => {
    handleError(error); // 在拦截器里处理错误 
    // Error was "handled" and didn't propagate 错误被“处理”了，不会继续向外传播
  }
);
```

##### 1.x 的做法

只要服务器返回了表示错误的 HTTP 状态码（如 404、500 等），axios 就会统一地、无一例外地将其作为错误抛出，而不是在 then() 中作为成功响应处理

```js
// Axios 1.x - All HTTP errors throw consistently 所有 HTTP 错误都会一致地抛出
axios.get('/api/data')
  .then(response => {
    console.log('Success:', response.data);
  })
  .catch(error => {
    // Must handle errors at call site or they propagate 必须在调用处处理错误，否则错误会向上传播
    console.error('Request failed:', error);
  });
 
// Response interceptor must re-throw or return rejected promise 响应拦截器必须重新抛出错误或返回一个被拒绝的 Promise
axios.interceptors.response.use(
  response => response,
  error => {
    handleError(error); // 可以在拦截器里进行一些通用处理（如记录日志）
    // Must explicitly handle propagation 必须明确处理错误的传播
    return Promise.reject(error); // or throw error;
  }
);
```

#### 2、 **JSON** **parse** 处理

0.x 的处理：宽松的 JSON 解析，甚至会尝试解析无效的 json

```js
response.data // 可能包含部分数据或者 fallback 回退
```

1.x 的处理：严格的 JSON 解析，为无效的 json 抛出明显的错误

```js
try {
    const data = response.data
} catch (err) {
    // 显式处理 json 解析错误
}
```

#### 3、请求/响应转换

0.x 的处理：带有一些 edge 边缘情况的隐式转换

```js
transformRequest: [function(data, headers) {
    return data // 难以预测的行为
}]
```

1.x 的处理： 更一致的转换管道

```js
transformRequest: [function(data, headers) {
    return data // Headers 参数始终可用，更多可预测行为
}]
```

#### 4、浏览器支持

0.x 支持 IE11 及更老的浏览器

1.x 支持现代支持 promise 的浏览器

 

### 二、升级 **Axios** 容易暴露的不兼容

升级到 axios 1.x 后，最容易踩到的不是“import 写法”，而是：

#### 1、axios 1.x 对失败状态更一致地 reject

以前一些项目会在拦截器里“处理但不继续 reject”，调用处没 catch 也不一定爆；1.x 更容易变成 Uncaught (in promise) AxiosError

#### 2、application/x-www-form-urlencoded 不会自动帮你序列化对象

如果某些接口期望的是 JSON，但发了 form，会出现 Content type not supported

- Content-Type: application/json（走 JSON body）

- Content-Type: application/x-www-form-urlencoded...（走表单编码）

这个接口到底要用 JSON 还是 form、要不要自动序列化、错误要在拦截器处理还是交给调用处
