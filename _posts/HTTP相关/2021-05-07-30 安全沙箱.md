---
layout:     post
title:     30 安全沙箱
subtitle:  
date:       2021-05-07
author:     
header-img: 
catalog: true
tags:
    - < HTTP相关 >
typora-root-url: ..
---


# 30 安全沙箱

-   为什么出现安全沙箱？
    
    如果浏览器被曝出存在漏洞，那么在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序，是可以 **入侵到浏览器进程内部** 的，可以读取和修改浏览器进程内部的任意内容，还可以**穿透浏览器**，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容
## 浏览器内核间的配合
<img src="/../img/assets_2019/image-20210507162128612.png" alt="image-20210507162128612" style="zoom:30%;" />

浏览器被划分为 **浏览器内核**【由网络进程、浏览器主进程和 GPU 进程组成】和 **渲染内核**【即渲染进程】两个核心模块，配合流程如下：

​	1、所有的 **网络资源** 都是通过 **浏览器内核** 来下载的，下载后的资源会通过 `IPC` 将其提交给 **渲染进程**

​	2、然后 **渲染进程** 会对这些资源进行 **解析、绘制** 等操作，最终生成一幅图片，但不负责显示

​	3、将最终生成的图片提交给 **浏览器内核** 模块，由浏览器内核模块负责 **显示** 这张图片

## 安全沙箱
网络资源的内容存在着各种可能性，所以浏览器会默认所有的网络资源都是不可信的，都是不安全的

 --> 下载一个恶意程序，但没有执行的话，恶意程序是不生效的

 --> 所以浏览器可以 **安全地下载各种网络资源**，但是 **执行需要谨慎**

 --> 将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱

 -  安全沙箱定义
    
    浏览器中的安全沙箱是利用 **操作系统提供的安全技术**，让渲染进程在执行过程中 <u>无法访问或者修改</u> 操作系统中的数据，在渲染进程需要访问系统资源的时候，需要**通过浏览器内核来实现**，然后将访问的结果通过 `IPC` 转发给渲染进程。
    
    【安全沙箱最小的保护单位是进程】
## 安全沙箱如何影响各个模块功能
因为安全沙箱要求进程不能拥有读写操作系统的功能，所以 **渲染进程** 中涉及到和系统交互的功能都转移到 **浏览器内核** 中去实现：

<img src="/../img/assets_2019/image-20210507162248202.png" alt="image-20210507162248202" style="zoom:35%;" />

1、 持久存储

在 **渲染进程** 内部有访问 Cookie 的需求、有上传文件的需求 --> 将读写文件的操作全部放在了 **浏览器内核** 中实现，然后通过 `IPC` 将操作结果转发给 **渲染进程**

- 存储 Cookie 数据的读写

    通常 **浏览器内核** 会维护一个存放所有 Cookie 的 Cookie 数据库，然后当 **渲染进程** 通过  JavaScript  来读取 Cookie 时，**渲染进程 **会通过 `IPC` 将读取  Cookie 的信息发送给 **浏览器内核**，**浏览器内核** 读取 Cookie 之后再将内容返回给 **渲染进程**

-   一些 **缓存文件** 的读写也是由浏览器内核实现的，比如网络文件缓存的读取

2、网络访问

在 **渲染进程** 内部也是不能直接访问网络的，如果要访问网络，则需要通过 **浏览器内核**。

不过 **浏览器内核** 在处理 URL 请求之前，会 检查渲染进程 <u>是否有权限请求该 URL</u> ，比如检查 `XMLHttpRequest` 或者  `Fetch`  是否是 <u>跨站点请求</u>，或者检测  HTTPS  的站点中是否包含了 HTTP 的请求

3、用户交互

为了限制 **渲染进程** 有监控到用户输入事件的能力，所以所有的 **键盘鼠标事件** 都是由 **浏览器内核** 来接收的，然后**浏览器内核** 再通过 `IPC` 将这些事件发送给渲染进程

实际实现方式：

- 1、**渲染进程** 需要渲染出位图。将生成好的位图发送到 **浏览器内核**，然后 **浏览器内核** 将位图复制到屏幕上

- 2、**操作系统** 没有将用户输入事件直接传递给 **渲染进程**，而是将这些事件传递给 **浏览器内核**。然后 **浏览器内核** 再根据当前浏览器界面的状态来判断如何调度这些事件 

    --> 如果当前焦点位于 **浏览器地址栏** 中，则输入事件会在 **浏览器内核** 内部处理 

    --> 如果当前焦点 **在页面的区域** 内，则 **浏览器内核** 会将输入事件转发给 **渲染进程**