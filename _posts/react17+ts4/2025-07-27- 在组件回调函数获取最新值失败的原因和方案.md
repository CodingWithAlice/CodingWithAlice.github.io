---
layout:     post
title:    在组件回调函数获取最新值失败的原因和方案
subtitle:  
date:       2025-07-27
author:     
header-img: 
catalog: true
tags:
    - < React17+TS4 >
typora-root-url: ..
---



# 在组件回调函数获取最新值失败的原因和方案

总结：

1、原因：在 回调函数中使用 组件的变量时，变量永远是 **生成时 的值**，后续的变更不会传入变化

2、解决方案动态获取可以使用 ref 或者 useEffect 监听依赖



#### 问题和原因

```js
const [source, setSource] = useState([])
const [columns, setColumns] = useState([])
const getColumns = () => ([
    {
        title: '名称'，
        edit: true,
        dataIndex: 'name',
        validate: (_, record) => {
			return source.name // ❌ 无法获取到最新值 -> 永远指向初始的 source（闭包问题）
    	}
    }
])
useEffect(() => {
    setColumns(getColumns())
}, []) // 只在挂载时执行一次
```

问题1、执行 getColumns 时，在 validate 中的回调函数中，无法获取当前组件 source 的最新值 -> 为什么？

- 原因：【**闭包 + React Hooks 渲染机制**】validate 是作为一个函数属性被写死在 columns 里的 -> ，getColumns 在组件**首次渲染执行**时，validate 捕获的是 **当时的 source，即 闭包变量**

- **知识点**：react 的 hooks 闭包特性 - 函数组件每次渲染时，所有函数、变量、props、state 都是快照，案例中的 validate 引用的 source 其实是 **生成 columns 那一刻的 source，而不是后续最新的**



```js
const getColumns = (s) => ([
    {
        validate: ((data) => {
            // 依旧获取不到 source 的最新值
        })(source),
    }
])
```

问题2、给 getColumns 传递参数，使用立即执行函数，为什么不行？

- 原因：validate 只是在 **生成时 闭包捕获**了这个参数，它永远不会自动变成最新的 source，**只会用 生成时捕获的那个值**



#### 解决方案

方案1、副作用

```js
useEffect(() => {
    setColumns(getColumns(source))
}, [source])
```



方案2、使用 ref

```js
validate: (_, record) => {
	const data = sourceRef.current
	return data.name
}
```

