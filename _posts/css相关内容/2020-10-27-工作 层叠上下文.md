---
layout:     post
title:     层叠上下文
subtitle:  
date:       2020-10-27
author:     
header-img: 
catalog: true
tags:
    - < CSS相关内容 >
typora-root-url: ..
---


# 层叠上下文

场景：运营自主设置热区的时候，不管热区设置多大，都不会影响下方商品的跳转链接；研究发现是热区的区块，显示在商品下方

![image-20201027170519735](/../img/assets_2019/image-20201027170519735.png)

参考：[长安曹公子的掘金](https://juejin.im/post/6844903667175260174#heading-8)

总结：

1、首先先看要比较的两个元素是否处于同一个层叠上下文中：    

​	1.1如果是，谁的层叠等级大，谁在上面（怎么判断层叠等级大小呢？——看“层叠顺序”图）。    

​	1.2如果两个元素不在统一层叠上下文中，请先比较他们所处的层叠上下文的层叠等级。

2、当两个元素层叠等级相同、层叠顺序相同时，在DOM结构中后面的元素层叠等级在前面元素之上。



以下为记录的核心要点梳理：

#### 层叠上下文 + 层叠等级

​	先理解 `<html></html>` 中有默认的【**层叠上下文**】概念，也可以触发单独的【层叠上下文】，每个【层叠上下文】中【**层叠等级**】控制哪个元素离用户更近；

**创建层叠上下文：**

1、HTML 的【**根元素`<html></html>`**】本身就有层叠上下文【根层叠上下文】

2、普通元素设置为【**`position:非static`并设置`z-index`属性为具体数值**】，就可以产生层叠上下文

3、css3中可以创建的方式：

- 父元素的【**display属性值**】为`flex|inline-flex`，子元素`z-index`属性值不为`auto`的时候，子元素为层叠上下文元素；
- 元素的【`opacity`**属性值**】不是`1`；
- 元素的【`transform`**属性值**】不是`none`；
- 元素`mix-blend-mode`属性值不是`normal`；
- 元素的`filter`属性值不是`none`；
- 元素的`isolation`属性值是`isolate`；
- `will-change`指定的属性值为上面任意一个；
- 元素的`-webkit-overflow-scrolling`属性值设置为`touch`。



#### 层叠顺序

在上述基础上去理解【层叠顺序】这个规则，可以把这个规则理解成css自定义的规则；

​		特别注意：层级上下文中，`background/border`的优先级低于`z-index`负数；

​					       块级盒子`block/float`盒子的优先级低于内联元素`inline/inline-block`；

![image-20201027174811488](/../img/assets_2019/image-20201027174811488.png)



### 有趣的例子

【这个例子打破了我对 z-index 只跟着 position 非static 才有效的认知】

父盒子给 `display:flex` ，子盒子给 `z-index` 就可以让子盒子形成层级上下文。

```html
<div class="box">
    <div class="parent">
        parent
        <div class="child">child</div>
    </div>
</div>
```

```css
.box {
	display: flex;
}
.parent {
	background: #168bf5;
    /* 不配合 position 属性，也可以生效 ---- 因为形成了层叠上下文 */
	z-index: -2;
}
.child {
	background: #32d19c;
	position: relative;
	z-index: -1;
}
```

![image-20210628204317197](/../img/assets_2019/image-20210628204317197.png)

### 正确区分 layer 和 层级上下文

详细可以参考博客（从Demo3起讲这个）：[chrome devTools](https://blog.csdn.net/qq_39446719/article/details/102980947)

有自己的 layer 的元素则必定是一个层叠上下文，而是层叠上下文的元素不一定有自己的 layer

