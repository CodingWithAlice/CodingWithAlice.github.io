---
layout:     post
title:     LTN①⑦
subtitle:  
date:       2025-2-19
author:     
header-img: 
catalog: true
tags:
    - < LTN >
typora-root-url: ..
---



# LTN①⑦

> LTN ①⑦ 错误整理 36错题/88题

❌作业92：前端中的序列化是什么？常见序列化方法。反序列化是什么？有哪些方法
❌作业93：闭包的作用和原理
❌2024-11 第十九章 表单脚本
❌2024-10 第十二章 BOM 小结
❌2024-09 第七章 迭代器与生成器 小结
❌2019-06 第五章 基本引用类型 小结
❌2021-07 前端路由的两种模式
❌作业30：简单写出一个请求头和响应头。HTTP/1.1中唯一要求请求头必须提供？写出常见状态码
❌2019.07 引用css，link和@import的区别
❌作业40：写出以下值

```js
1、Number(null)
2、Number(undefined)
3、isNaN() 检测那些值为 true?
4、Number、parseInt、parseFloat 检测 空字符串 得到?
5、1+'2'+'2'
1+ +'2'+'2'
1+ -'1'+'2'
'A'-'B'+'2'
'A'-'B'+ 2
6、let i = 0, age = 30;
i++ + age;
++i + age;
7、 12.34 | 0;
12.43 >> 0;
8、null === undefined；
```

❌作业32：什么是队头阻塞？原因是什么？怎么解决？
❌69.x 的平方根
❌作业87：Nextjs 中预渲染是什么？有哪些模式？写一个动态路由的page
❌作业88：mysql2 和 Sequelize 的使用场景？有哪些差异？简单写一个连接
❌作业95：唯一索引什么作用？Sequelize 中 define modal 的时候，怎么创建组合字段唯一索引？SQL怎么写？updateOnDuplicate 是什么作用？怎么配合唯一索引。 define 中的第三个参数中常见配置
❌作业97：Sequelize 中查找某条数据，如果存在就更新；不存在就创建一条
❌作业98：sequelize 怎么写关联表的查询，指定关联的 column 是date
❌2025.02 Mysql 8.0 以上，Sequel报插件错
❌2025.02 Nextjs 获取链接中的参数
❌作业 89：mysql 中类型的区别：varchar 和 char，date datetime
❌作业1：写一个只能被迭代指定次数的类
❌作业11：写出一个用 yield 实现的递归算法，从0数到指定n
❌作业10：说出WeakMap/WeakSet和Map、Set的区别，为什么有这两个弱类型，经常用在什么场景
❌作业70：Vue 和 React 的 Diff 算法比较
❌作业81：Redux 核心是什么？reducer、action、dispatch、store、RTK 怎么理解？简单写一个 redux 使用
❌2023.07 clickhouse、mysql、mongodb异同
❌2021.07 12-1 内存泄漏
❌2021.06 flex布局
❌作业99：渲染合成层定义、触发方式、优点、缺点
❌2019.07 显示省略号
❌ 2021.07 babel  作用+原理+补丁
❌ 2021.05 27 HTTP/3 改进的点
❌2025.02 nextTick 原理，在Vue2、Vue3中分别是什么步骤实现的，简单模拟实现流程
❌2021.04 12 垃圾回收机制
❌作业66：React如何处理错误
❌2021.06 子盒子在父盒子中水平垂直居中有几种方法？



> LTN①⑦  工具推荐做题周期 2.15 - 2.25  88题（LTN1-49, LTN2-7, LTN3-17, LTN4-11, LTN5-7）

LTN1 【推荐做题时间 02-15 - 7题 实际做题时间：2.19 】
✅作业90：金玉满堂是什么意思？在花卉中的说法是什么？
✅作业91：三次握手的过程和具体包的作用
❌作业92：前端中的序列化是什么？常见序列化方法
❌作业93：闭包的作用和原理
✅2021.07 事件流 + 事件模型
✅2021.06 链表 141. 环形链表
✅2021.09 get和post有什么区别

LTN3 【推荐做题时间 02-15 - 11题 实际做题时间： 2.19 + 2.20】
✅2021-06 CSS性能优化
✅2019-06 第一章-第三章 简介、基本概念 小结
✅2024-11 第十八章 动画与Canvas图形
❌2024-11 第十九章 表单脚本
❌2024-10 第十二章 BOM 小结
❌2024-09 第七章 迭代器与生成器 小结
❌2019-06 第五章 基本引用类型 小结
❌2021-07 前端路由的两种模式
✅2021-07 给DOM元素绑定事件
✅2021-04 实现给定时间切换状态
✅2024-11 数组乱序 洗牌算法

LTN4 【推荐做题时间 02-15 - 6题 实际做题时间： 2.20】
✅作业14：Proxy 的原型是什么？怎么撤销代理关联？是否可逆？写几个常见的代理模式对应的捕获器
❌作业30：简单写出一个请求头和响应头。HTTP/1.1中唯一要求请求头必须提供？写出常见状态码
✅作业31：什么是长连接？长连接的属性怎么写？哪个版本开始启用长连接？
✅作业33：Cookie 怎么设置有效期？有优先级吗？HttpOnly 是什么含义？
❌2019.07 引用css，link和@import的区别
✅2019.07 隐式转换:{}+{}=?

LTN1 【推荐做题时间 02-17 - 2题 实际做题时间： 2.20】
✅作业58：React和Vue是怎么描述UI的
✅作业62：fiber架构是什么？优点和实现方式？

LTN4 【推荐做题时间 02-17 - 4题 实际做题时间： 2.20】
❌作业40：写出以下值

```js
1、Number(null)
2、Number(undefined)
3、isNaN() 检测那些值为 true?
4、Number、parseInt、parseFloat 检测 空字符串 得到?
5、1+'2'+'2'
1+ +'2'+'2'
1+ -'1'+'2'
'A'-'B'+'2'
'A'-'B'+ 2
6、let i = 0, age = 30;
i++ + age;
++i + age;
7、 12.34 | 0;
12.43 >> 0;
8、null === undefined；
```

❌作业32：什么是队头阻塞？原因是什么？怎么解决？
✅作业16（1）：箭头函数和普通函数的区别是什么？（3点）
✅2019.07 盒模型有哪些？有什么区别？

LTN1 【推荐做题时间 02-18 - 2题 实际做题时间： 2.20 + 2.21】
✅作业64：Vue渲染怎么实现的？
❌69.x 的平方根

LTN1 【推荐做题时间 02-19 - 6题 实际做题时间： 2.21】
✅作业67：React 怎么做的性能优化？
✅作业68：React hooks 的原理是什么？useEffect useState模拟实现
❌作业87：Nextjs 中预渲染是什么？有哪些模式？写一个动态路由的page
❌作业88：mysql2 和 Sequelize 的使用场景？有哪些差异？简单写一个连接
✅作业94：Nextjs fetch 为什么接口查询之后，一般都要使用 .json() 来转化一次数据后再返回？sequelize findAll/findOne 可以通过传递参数获取 js 格式的数据
❌作业95：唯一索引什么作用？Sequelize 中 define modal 的时候，怎么创建组合字段唯一索引？SQL怎么写？updateOnDuplicate 是什么作用？怎么配合唯一索引。 define 中的第三个参数中常见配置

LTN1 【推荐做题时间 02-21 - 8题 实际做题时间： 2.21 + 2.22】
✅2020.07 对象分类、Promise按序执行、实现map
✅2024.11 第十七章 事件
✅2021-07 常见Webpack问题
✅作业 96：Sequelize 中 Date 的怪问题 - POST 存储 DATE 类型，GET 传参数2025-01-27 STRING，无法直接查询，有那些性能高的查询方法？索引是什么，为什么性能高？
❌作业97：Sequelize 中查找某条数据，如果存在就更新；不存在就创建一条
❌作业98：sequelize 怎么写关联表的查询，指定关联的 column 是date
❌2025.02 Mysql 8.0 以上，Sequel报插件错
❌2025.02 Nextjs 获取链接中的参数

LTN1 【推荐做题时间 02-22 - 6题 实际做题时间： 2.22】
✅作业2：支持迭代器的原生语言特性有哪些？
✅2019.07 为什么要清除浮动？怎么清除浮动？
✅作业45：原生+canvas 显示一张png格式的图片
✅2024.10 第十四章-第十五章 DOM、DOM扩展
✅2024.12 模拟实现instanceof
✅2019.07 h5新标签和语义化，块/行内元素

LTN2 【推荐做题时间 02-22 - 2题 实际做题时间： 2.22】
✅作业16（2）：arguments 对象对待命名参数和设置了默认值的命名参数有什么不同？数组作为参数传入函数得到的arguments 是什么？怎么实现arguments是数组？怎么收集独立参数？在对象字面量和数组字面量中，扩展运算符有什么不同的表现？
❌作业 89：mysql 中类型的区别：varchar 和 char，date datetime

LTN4 【推荐做题时间 02-22 - 1题 实际做题时间： 2.22】
✅2024-09 第六章 集合引用类型 小结

LTN5 【推荐做题时间 02-22 - 7题 实际做题时间： 2.22 + 2.23】
❌作业1：写一个只能被迭代指定次数的类
✅作业7：原始值包装类型和原始类型在使用 typeof 和 instanceof 进行类型判断时，有什么异同？
✅作业9：数组自带排序 sort() 为什么经常要传比较函数？写一个降序的比较函数。如果数组元素全是数值，请给出简写形式
❌作业11：写出一个用 yield 实现的递归算法，从0数到指定n
✅作业12：画出一个原型链，到 null 为止
✅作业8：ES6新增了两个创建数组的静态方法：Array.from()和Array.of()两个有什么区别？
❌作业10：说出WeakMap/WeakSet和Map、Set的区别，为什么有这两个弱类型，经常用在什么场景

LTN1 【推荐做题时间 02-23 - 10题 实际做题时间： 2.23】
✅2021.07 防抖节流
✅2024.12 模拟实现jsonp
❌作业70：Vue 和 React 的 Diff 算法比较
❌作业81：Redux 核心是什么？reducer、action、dispatch、store、RTK 怎么理解？简单写一个 redux 使用
✅作业83：INNER JOIN、LEFT OUTER JOIN、RIGHT OUTER JOIN 有什么区别?UNION作用是什么？怎么封装一个 SQL 查询
❌2023.07 clickhouse、mysql、mongodb异同
✅作业4：什么是生成器？有什么作用？
❌2021.07 12-1 内存泄漏
❌2021.06 flex布局
❌作业99：渲染合成层定义、触发方式、优点、缺点

LTN3 【推荐做题时间 02-23 - 6题 实际做题时间： 2.23】
✅作业49：牛顿三大定律、热力学两大定律
✅作业54：举杯邀明月，对影成三人。的上一句
✅作业77：重绘和重排是什么？有什么区别？
✅作业79：地球四季的成因是什么？
❌2019.07 显示省略号
✅2021.04 25 HTTP/2 特性

LTN1 【推荐做题时间 02-24 - 5题 实际做题时间： 2.24】
✅作业23：写出js 代码的执行顺序。词法作用域的特点是什么？

```js
function bar(){
    console.log(myName);
}
function foo(){
    var myName = 'hi 坑';
    bar();
}
var myName = 'bye 坑';
foo();
```

❌ 2021.07 babel  作用+原理+补丁
❌ 2021.05 27 HTTP/3 改进的点
❌2025.02 nextTick 原理，在Vue2、Vue3中分别是什么步骤实现的，简单模拟实现流程
❌2021.04 12 垃圾回收机制

LTN2 【推荐做题时间 02-24 - 2题 实际做题时间： 2.24】
✅作业6：new操作符实例化一个对象的过程
❌作业66：React如何处理错误

LTN2 【推荐做题时间 02-25 - 3题 实际做题时间： 2.24】
✅作业3：迭代器原理
✅作业24：写出事件循环系统的流程图，常见宏任务、微任务有哪些。并写出几个常见题目的输出结果

```js
Promise.resolve().then(() => {
    console.log(1);
    Promise.resolve().then(() => {
        console.log(2);
    }).then(() => {
        console.log(3);
    }).then(() => {
        console.log(4);
    })
}).then(() => {
    console.log(5);
}).then(() => {
    console.log(6);
}) 
    ------
async1 = async () => {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
function async2(){
    console.log('async2');
}
console.log('script start');
setTimeout(() => {
    console.log('setTimeout');
})
async1();
new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(() => {
    console.log('promise2');
    return new Promise(function(resolve) {
        resolve();
    })
}).then(() => {
    console.log('promise3');
})
console.log('script end');
```

❌2021.06 子盒子在父盒子中水平垂直居中有几种方法？

----

做题记录

```js
// 2021.06 子盒子在父盒子中水平垂直居中有几种方法？
- 第四遍 2025.2.24 -
1、flex .father{ display:flex; justify-content:center; align-iterms:center; }
2、position .son{ position:absolute; top:0; right:0; botton:0; left:0; margin:auto; }
3、position .son{ position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); }
4、table .father{ display:table-cell; vertical-align: middle; text-align: center; }
❌ // 1、table 少写了 .son{ display: inline-block }
- 第三遍 2025.2.11 -
- 第二遍 2025.2.9 -
- 第一遍 2025.1.30 -
④ .son { display: table-cell; text-align: center; vertial-align: middle; } 
❌ // 1、不是给子元素 添加 table-cell，这个方法的核心是把 父盒子 设置为 table-cell，使得另外两个属性生效 - 而子盒子作为行内块类型，垂直、居中 .father { display: table-cell; text-align: center; vertical-align: middle; } .son { display: inline-block; }
```

```js
// 作业24：写出事件循环系统的流程图，常见宏任务、微任务有哪些。并写出几个常见题目的输出结果
- 第四遍 2025.2.24 -
事件循环系统 - 同步 - 主线程 - 调用栈清空前，查询事件队列函数，进行执行 - 循环事件队列执行完毕
		   - 异步 - Event Table - 异步事件有结果后，将回调函数放入事件队列
宏任务：IO下载交互、UI渲染、setTimeout/setInterval、js代码执行
微任务：Promise.then、async/await、MutationObserver
125364
script start - async1 start - async2 - promise1 - script end
    - async1 end - promise2 - promise3
    - setTimeout
- 第三遍 2025.2.11 -
- 第二遍 2025.2.9 -
⭐️ // Event Queue + 触发时机 - 等异步任务有了结果，将回调函数投入事件队列
- 第一遍 2025.1.30 -
⭐️ // Event Queue，等异步任务有了结果，将回调函数投入事件队列
⭐️ // IO表示下载和交互
1 5 2 6 3 4 ❌ // 125364 
```

```js
// 作业3：迭代器原理
- 第五遍 2025.2.24 -
使用 next 遍历可迭代对象，不关心变量类型
- 第四遍 2025.2.11 -
- 第三遍 2025.2.9 -
- 第二遍 2025.1.30 -
提供暂停和恢复代码执行能力，[Symbol.iterater] 默认迭代器
yield 暂停，next 恢复执行 {done, value}
❌ // 迭代器使用 next 方法在可迭代对象中遍历数据
- 第一遍 2024.12.25 -
```

```js
// 作业66：React如何处理错误
- 第九遍 2025.2.24 -
React 提供了两个错误函数用于处理 render 和 commit 中的错误，避免错误溢出应用程序，影响 UI 展示
static getStateFromError + componentDidCatch
❌ // 1、函数名称错误：getDerivedStateFromError 
错误边界
class Boundaries extends React.component {
    constructor(props){
        super(props);
        this.state = {hasError: false};
    }
    static getStateFromError() { ❌ // 1、函数名称错误：getDerivedStateFromError
        return {hasError: true};
    }
    componentDidCatch(e, info){
		console.log(e)
    }
    render() {
        if(this.state.hasError) {
            return <div> There are errs. </div>
        } else {
            return this.props.children;
        }
    }
}
⭐️ // <ErrorBoundaries> <My /> </ErrorBoundaries>
- 第八遍 2025.2.10 -
- 第七遍 2025.2.9 -
- 第六遍 2025.1.29 -
React 提供两个函数处理错误 static getStateFromError()、componentDidCatch，用于捕获 
❌ // 1、静态函数名称错了 getDerivedStateFromError
render+commit 阶段的错误，阻止错误蔓延到整个应用影响 UI 展示
几个情况不会捕获：异步、回调、ssr、错误边界内部
class Boundaries extends React.Component{
    constructor() {
        super(props);
        this.state = { hasError: false }
    }
    static getStateFromError() { ❌ // 2、getDerivedStateFromError
        return { hasError: true }
    }
    componentDidCatch(e, info) {
        console.log(e)
    }
    render() {
        if(this.state.hasError) {
            return <p> There are errs. </p>
        } else {
            return this.props.children;
        }
    }
}
- 第五遍 2025.1.22 -
- 第四遍 2025.1.18 -
```

```js
// 作业6：new操作符实例化一个对象的过程
- 第一遍 2025.2.24 -
function newF() {
	const ctor = [].shift.call(arguments);
    const obj = new Object();
    obj.__proto__ = ctor.prototype;
    const res = ctor.call(obj, ...arguments);
    return typeof res === 'object' ? res : obj
}
- 第四遍 2025.2.10 -
- 第三遍 2025.2.9 -
- 第二遍 1.28 -
function newFun () {
    let obj = new Object();
    const ctor = [].shift.call(arguments);
    obj.__proto__ = ctor; ❌ // 1、不是构造函数，是构造函数的原型对象 obj.__proto__ = ctor.prototype;
    const res = ctor.apply(obj, arguments);
	return typeof res === 'object' ? res : obj;
}
- 第一遍 1.20 -
❌ // 1、不是调整 constructor 的指向
```

```js
// 2021.04 12 垃圾回收机制
- 第一遍 2025.2.24 -
❌ // 1、少写了栈的清理：指针移动 - 不需要的数据所在的内存被覆盖
v8 垃圾回收机制：标记清除（之前使用循环计数，无法清理循环调用）
❌ // 2、少写了：v8 引擎 基于代际假说
分为新生区和老生区 ⭐️ // 新生代 - 副垃圾回收机制，老生代 - 主垃圾回收机制(不产生内存碎片)
- 新生区：内存占用小，新生区清理两次都没有被清理的变量，提升到老生区
	划分为两部分，前和后，后存储到一半后，触发清理 - 先清理，清理的过程中已经包含了移动，清理完交换
❌ // 3、划分区域名错误：新生代 - 副垃圾回收器，划分为 对象区域、空闲区域；清理时机错误：对象区域快满时；清理过程错误：标记 - 将存活的对象有序地复制到空闲区 - 复制完后翻转两个区域
- 老生区：内存占用空间大
	先清理，再移动
❌ // 4、少写了算法：标记-清理，产生大量不连续的内存碎片
```

```js
// 2025.02 nextTick 原理，在Vue2、Vue3中分别是什么步骤实现的，简单模拟实现流程
- 第一遍 2025.2.24 -
nextTick 原理：有些操作需要在 DOM 更新后操作 ⭐️ // 在下次 DOM 更新循环结束之后，执行延迟回调
Vue2：将回调函数放到事件队列-微任务，执行完一次 DOM 元素的更新后，执行事件队列
❌ // 1、Vue 的数据更新是异步执行，修改数据后，Vue 不会立即更新 DOM，而是放到队列中等到下一个事件循环时再批量更新 - 需要 nextTick 来确保在 DOM 更新后再执行
❌ // 2、Vue2 的步骤：①回调函数收集到队列 ②异步执行方式选择：根据浏览器环境选择合适的异步执行方式，优先微任务 Promise/MutationObserver，如果不支持微任务则使用宏任务 setTimeout ③触发异步执行：在下次DOM 更新结束后执行
Vue3：将回调函数使用 MicroQueue 实现
❌ // 3、Vue3：和Vue差异是，使用 queueMicrotask 统一处理微任务
模拟
function nextTick(fn){
    if(typeof MicroEvent === 'function') {
        return new MircoEvent(fn);
    }
    if(typeof setTimeout === 'function') {
        return setTimeout(fn, 0)
    }
}
❌ /* 4、Vue2
const callbacks = []; 		// 异步函数收集队列
let pending = false;  		// 标记是否正在执行回调
function flushCallbacks() { // 执行所有回调函数 flushCallbacks
	pending = false;
	const copies = callbacks.slice(0);
	copies.forEach(it => it());
}

let timeFunc; // step2、根据浏览器支持情况，选择异步执行方式
if(typeof Promise !== 'undefined') { // 浏览器支持 Promise 微任务
	const p = Promise.resolve();
	timeFunc = () => { p.then(flushCallbacks) };
} esle if(typeof MutationObserver !== 'undefined'){ // 浏览器支持 MutationObserver 微任务
	const obs = new MutationObserver(flushCallbacks);
	const textNode = document.createTextNode('1');
	obs.observe(textNode, { characterData: true }); // 监听目标节点的文本内容变化
	timeFunc = () => { textNode.data = '2' }
} else if(typeof setImmediate !== 'undefined'){ // 浏览器支持 setImmediate 宏任务
	timeFunc = () => { setImmediate(flushCallbacks) }
} else {
	timeFunc = () => { setTimeout(flushCallbacks, 0) } // 浏览器默认 setTimeout 宏任务
}

funtion nextTick(cb, ctx) {
	callbacks.push(() => { // step1、收集到异步函数收集队列
		if(cb) { 
			try{ fn.call(ctx) }catch(e){ console.log(e) } 
		}
	})
	if(!pending) {
		pending = true;
		timeFuc();  // step3、执行异步
	}
}

new Vue({
	data() { return {msg:'hello'} },
	mounted() { this.$nextTick(() => { console.log('DOM 已更新') }) }
})
**/
/* 5、Vue3
const queue = [];			// 异步函数收集队列
let isFlushing = false;		// 标记是否正在执行回调
function flushJobs() {
	isFlushing = true;
	let job;
	while((job=queue.shift())){
		job();
	}
	isFlushing = false;
}
function nextTick(fn) {
	return new Promise((resolve) => {
		const runner = () => { 
			if(fn) {
				try{ fn() }catch(e){ console.error(e) }
			}
			resolve();
        }
        queue.push(runner); // step1、收集到异步函数收集队列
        if(!isFlushing){ queueMicrotask(flushJobs) } // step3、执行异步
	})
}

import { createApp, nextTick } from 'vue';
const app = createApp({
	data() { return {msg:'hello'} },
	mounted() { nextTick(() => { console.log('DOM 已经更新') }) }
})
app.mount('#app')
**
```

```js
// 2021.05 27 HTTP/3 改进的点
- 第一遍 2025.2.24 -
不再使用 HTTP/2.0 的 TCP 协议，改为 UDP，并使用 QUIC协议 ⭐️ // 完全解决了队头阻塞
❌ // 1、少写了 HTTP/2.0 存在的问题：HTTP/2.0 并没有完全解决队头阻塞，传输层的 TCP 有丢包重传机制 - TCP 为了保证可靠的传输，丢包必须等待重新传输确认，其他的包即使收到了也只能放在缓冲区，上层应用拿不出来，被丢的包不回来，大家都取不出来
❌ // 2、少写了：HTTP/3.0 UDP 无连接，HTTP/2.0 TCP 三次握手、四次挥手
```

```js
// 2021.07 babel  作用+原理+补丁
- 第一遍 2025.2.24 -
作用：babel 将 ES6 代码转换成 ES5 代码，方便引擎解析执行 
原理：babel 先将 ES6 代码解析成 ES6 AST 再在 AST 层面转换成 ES5 AST，再转换成 ES5 代码
❌ // 1、原理：少写了解析过程：解析Parsing[词法分析+语法分析得到AST]-转换Transformation[遍历AST转换 ES6的AST转换成ES5的AST]-生成Code Generation[根据转换后的AST转换成ES5 js代码]
补丁：babel 只能将 ES6 的常见语法转换，例如箭头函数等，其他的例如 Promise、async/await 等需要通过其他补丁完成，babel 的强大功能都是由补丁来完成的 
❌ // 2、不能转换的ES6语法：Iterator Generator Set Map Proxy Reflect Symbol 等全局对象 + Object.assign 全局对象上的方法；@babel/polyfill
```

```js
// 作业23：写出js 代码的执行顺序。词法作用域的特点是什么？
- 第二遍 2025.2.24 -
bye 坑
js  可执行代码 AST
	执行上下文 - this 在函数环境中，先创建 arguments，再函数提升，再变量提升
			 - 变量环境 var 作用域链：由多个执行上下文的变量环境组成的 ⭐️ // 链表
			 - 词法环境 let/const
词法作用域：只和代码所在位置有关
- 第一遍 2025.1.20 -
```

```js
// 2021.04 25 HTTP/2 特性
- 第四遍 2025.2.23 -
和 HTTP/1.1 语义层面保留，语法层面大力改造
1、压缩头部信息 ⭐️ // HPACK字典表算法
2、不再使用报文，使用二进制帧 - 双向传输序列形成流，多路复用-在一个连接中可以处理多个请求响应，多个请求响应之间不再有顺序关系，解决队头阻塞
3、服务器主动推送
4、设置请求优先级
5、采用 HTTPS
- 第三遍 2025.2.2 -
- 第一遍 -
❌ // 1、少写一个特性：服务器推送
```

```js
// 2019.07 显示省略号
- 第四遍 2025.2.23 -
.line {
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
}
.lines {
    overflow: hidden;
    display: -webkit-box; 
    -webkit-box-align: vertical; ❌ // 1、-webkit-box-orient: vertical;
    -webkit-line-clamp: 3;
    
    padding: 10px;
    line-height: 20px;
    line: 20*3-10px;
}
- 第三遍 2025.2.2 -
- 第一遍 -
❌ // 1、css 属性名错误：-webkit-box-orient: vertical;
```

```js
// 作业79：地球四季的成因是什么？
- 第三遍 2025.2.23 -
和地球与太阳的距离无关，只和太阳与地球表面的夹角-太阳光穿过的大气层厚度 和 地面照射的面积
- 第二遍 2025.2.2 -
⭐️ // 直射点的移动 + 太阳照射时长 - 夹角和地面角度的改变，改变了太阳辐射面积和经过大气层的路程衰减的辐射能量强度
```

```js
// 作业77：重绘和重排是什么？有什么区别？
- 第三遍 2025.2.23 -
重绘：只修改样式颜色，不影响布局，只需要重新渲染 ⭐️ // 只需要修改 分层+合成
重排：修改字体大小，影响布局 ⭐️ // 修改 布局+分层+合成，字体大小、padding/margin、激活伪类、style样式的修改、resize、页面初始渲染、DOM增删、位置内容的修改、DOM布局查询
- 第二遍 2025.2.2 -
```

```js
// 作业54：举杯邀明月，对影成三人。的上一句
- 第四遍 2025.2.23 -
花间一壶酒，独酌无相亲
- 第三遍 2025.2.2 -
```

```js
// 作业49：牛顿三大定律、热力学两大定律
- 第四遍 2025.2.23 -
牛顿三大定律 惯性定律、加速度定律 a=F/m、作用力与反作用力
热力学两大定律 能量守恒定律 熵增原理(自然系统，会自动失序)
- 第三遍 2025.2.2 -
- 第一遍 -
❌ // 1、少写了惯性定律 - 公交车记忆：刹车-加速度、乘客-惯性、地上痕迹-摩擦
```

```js
// 作业99：渲染合成层定义、触发方式、优点、缺点
- 第一遍 2025.2.23 -
定义：DOM-CSS-布局-分层（here）-绘制-栅格化-合成 将CSS样式分成不同层级 
❌ // 1、少写了：渲染时，为了提高渲染效率和性能，将页面中不同元素划分成多个层，每层都有独立的绘制、处理流程 - 这就是渲染合成层
触发方式：will-change opacity tranform  创建一层 ❌ // 2、少写了 3D 变化、视频/canvas
优点：修改部分样式的时候，只需要修改当前层，渲染效率更高
❌ // 3、少写了：减少不必要的回流重绘 + 实现流程流畅的动画效果，合成层可以在 GPU 上加速
缺点：分层越多，内存占用越大，合成时也会消耗性能
```

```js
// 2021.06 flex布局
- 第一遍 2025.2.23 -
独立容器 从上至下，垂直部署 计算高度时包含浮动元素 不和外部浮动元素重叠
分 主轴 和 交叉轴
flex: flex-grow 在主轴放大 flex-shrink 在主轴缩小 flex-basis auto-元素本身大小；0-根据整体 ⭐️ // flex-grow 正整数以 flex-basis 为基础
❌ /**
	1、优势：从 排列 + 空间分配 + 布局 描述
		便捷的元素排列 flex-direction - 水平、垂直、水平反转、垂直反转
		空间分配 flex 三个简写属性 + 主轴对齐方式 justify-Content + 交叉轴对齐方式 align-iterms
	2、常见默认属性
		主轴默认不拉伸，但默认缩小；交叉轴默认拉伸（align-items:stretch）
		-	space-between 元素排列后，再分配 [a--b--c]
		-	space-around 每个元素左右空间都相等 [-a--b--c-]
		flex 导致 float clear vertical-align 失效
		align-self 允许单个项目与其他不一样的对齐方式，可覆盖 align-items
*/
```

```js
// 2021.07 12-1 内存泄漏
- 第一遍 2025.2.23 -
内存泄漏：没有被使用的活动对象，却没有被清理
内存 Chrome Memory 录制查看
常见内存泄漏：闭包引用、全局变量、监听器、定时任务 ⭐️ // 少写了 弱引用 WeakMap/WeakSet
❌ /** 1、 如何避免内存泄漏：
	①尽可能少创建 闭包、全局变量 
	②手动清理定时器 clearInterval/clearTimeout 
	③手动移除监听器 removeEventListener .off() 
	④使用弱引用 WeakMap/WeakSet 或者 手动删除 Map、Set 的键/值 s.delete(value) m.delete(key)*/
```

```js
// 作业4：什么是生成器？有什么作用？
- 第四遍 2025.2.23 -
生成器 可以使用yield暂停和恢复代码执行，函数 Function * 声明，使用 next:{done, value} 遍历可迭代对象
模拟协程；自定义可迭代对象
- 第三遍 2025.2.18 -
- 第二遍 2025.2.15 -
❌ // 1、少写了：暂停、恢复代码执行，* 声明
- 第一遍 2025.1.30 -
```

```js
// 2023.07 clickhouse、mysql、mongodb异同
- 第六遍 2025.2.23 -
mysql 关联数据库，读写性能好，并发操作时会出现数据一致性问题，支持事务操作 ⭐️ // 高并发
mongodb 文档型数据库，读的性能好，写的性能弱，分布式操作时会出现数据一致性问题，支持非结构型类型/半结构型数据 XML、HTML ⭐️ // JSON
clickhouse 列式数据库，读写性能好，适合高吞吐、低延迟的场景 ❌ // 1、少写了：不支持事务，且支持分布式操作
- 第五遍 2025.2.18 -
❌ // 1、mysql 少写了：支持事务操作
❌ // 2、clickhouse 少写了：不支持事务
- 第四遍 2025.2.16 -
❌ // 1、mysql 少写了：支持事务操作；高并发时出现数据一致性问题
❌ // 2、mongodb 少写了：在分布式场景时出现数据一致性问题
❌ // 3、clickhouse 少写了：列式数据库 + 不支持事务，支持分布式查询 + 适合高吞吐、低延迟的场景
- 第三遍 2025.1.30 -
⭐️ // clickhouse：高吞吐、低延迟，支持复制、分布查询 + mongodb：分布式场景下一致性问题
- 第二遍 2025.1.25 -
❌ // 1、mongodb：在分布式场景下可能出现一致性问题 ；适合半结构化/非结构化数据
- 第一遍 2025.1.22 -
```

```js
// 作业83：INNER JOIN、LEFT OUTER JOIN、RIGHT OUTER JOIN 有什么区别?UNION作用是什么？怎么封装一个 SQL 查询
- 第六遍 2025.2.23 -
INNER JOIN 内联表，取AB表交集
LEFT OUTER JOIN A完全满足的条件行 + 补充所有相关的B的数据
RIGHT OUTER JOIN B 完全满足的条件行 + 补充所有相关A的数据
UNION 组合两次查询 ⭐️ // 拼接
封装 CREATE VIEW my AS SELECT...
SELECT * FROM my
- 第五遍 2025.2.18 -
封装 CREATE VIEW my ON SELECT * FROM table ❌ // 1、封装：关键词不是 ON 是 AS
- 第四遍 2025.2.16 -
❌ // 1、INNER JOIN 不是合集，是交集，表达错误 - AB都满足的行，内连接
CREATE VIEW my ON SELECT * FROM table ❌ // 2、封装：关键词不是 ON 是 AS
- 第三遍 2025.1.29 -
- 第二遍 2025.1.26 -
❌ // 1、少了一个 AS：封装 CREATE VIEW ... AS
- 第一遍 2025.1.22 -
```

```js
// 作业81：Redux 核心是什么？reducer、action、dispatch、store、RTK 怎么理解？简单写一个 redux 使用
- 第六遍 2025.2.23 -
Redux 将 react 的状态保存在 store 的对象树中，只能通过 dispatch action 改变 state
reducer 通过 oldState 和 action 计算出新的 state
RTK react toolkit - 官方推荐工具包
import { createStore } from 'redux';
const reducer = (oldState={v:1}, action) => {if(action.type) { return {v: oldState.v+1} }}
const store = createStore(reducer); ❌ // 1、 函数名称错了：getState
store.dispatch({type: true});
store.subscribe(() => console.log(store.getValue()))
- 第五遍 2025.2.18 -
store.subscribe(() => {console.log(store.getValue())}) ❌ // 1、 函数名称错了：getState
- 第四遍 2025.2.15 -
❌ // 1、注意 store 是对象树：Redux 将全局状态保存在 store 对象树中
⭐️ // reducer：返回新的 state 而不是改变
❌ // 2、reducer 参数顺序是 oldState,action
❌ // 3、 函数名称错了：getState，通过 subscribe 更新 UI
- 第三遍 2025.1.29 -
- 第二遍 2025.1.26 -
- 第一遍 2025.1.22 -
```

```js
// 作业70：Vue 和 React 的 Diff 算法比较
- 第九遍 2025.2.23 -
Vue 双端指针比较算法 -> 匹配不到，查找 同key+同标签 -> 索引是否一致，一致则复用，不一致 -> 再修改标签、移动或者重新渲染 ❌ // 1、Diff 跳过静态节点 + Vue 是组件级别的更新
React 分层同标签优先比较 -> 不同标签直接重新渲染 -> 同标签，修改属性复用 -> 同 key 移动
❌ // 2、分层比较 + 同类型优先比较 + React 是节点属性级别的更新 + DFS 深度优先遍历子节点，逐个比较
- 第八遍 2025.2.18 - 
- 第七遍 2025.2.16 -
❌ // 1、Vue 少写了：静态节点跳过；双端指针比较算法找不到时，要判断 同类型+同key 节点是否同索引
- 第六遍 2025.1.31 -
- 第五遍 2025.1.25 -
❌ // 1、Vue 少写了：静态节点跳过 ；Vue 是基于组件级别的更新算法
❌ // 2、React 少写了：是基于单个节点属性级别的，适合大型动态复杂场景
- 第四遍 2025.1.24 -
❌ // 1、Vue：找不到匹配的点后，再找到同类型+同 key的节点，进行索引比较，一致则复用，不一致则移动到新位置修改使用
- 第三遍 2025.1.18 -
❌ // 1、Vue：静态节点跳过比较 - 不要遗漏了，是个很重要的性能优化
❌ // 2、Vue：双端指针比较后，还有找不到的 -> 找同类型+同key来比较
- 第二遍 2025.1.13 -
⭐️ // React：「列表组件，根据 key 确定新老节点关系」
❌ // 1、Vue：双端比较算法是直接找匹配节点，不进行 标签修改
❌ // 2、Vue：key 是第三层比较逻辑，第二层比较逻辑是「索引」 - 若索引没有变化，则不更新当前节点；如果索引有变化，判断是否「同类型 + 同key」，移动到新位置
❌ // 3、Vue：性能优化，编译时标记的静态节点跳过 - 虽然老生常谈，但是这其实是一大优化
- 第一遍 -
```

```js
// 2024.12 模拟实现jsonp
- 第五遍 2025.2.23 -
function jsonp(url, params, callback) {
    const suffix = Object.entries(params).map(([key, value]) => `${key}=${value}`).join('&') + `&callback=${callback}`;
    const totalUrl = url + url.includes('?')?'&':'?' + suffix;
	const dom = document.createElement('script');
    window[callback] = function(data) {
        callback(data);
		document.body.removeChild(dom);
    }
    dom.src = totalUrl;
    document.body.appendChild(dom);
}
- 第四遍 2025.2.18 -
- 第三遍 2025.2.16 -
const suffix = Object.keys(params).reduce((pre, cur) => pre + `${cur}=${params[cur]}`, ''); 
❌ // 1、计算 url 时少了 '&' -> 使用 map + join 更简洁：Object.keys(params).map(it => `${it}=${params[it]}`).join('&') -> 使用 entries 也可以 Object.entries(params).map(([key, vlaue]) => `${key}=${value}`).join('&')
- 第二遍 2025.1.21 -
- 第一遍 -
```

```js
// 2021.07 防抖节流
- 第五遍 2025.2.23 -
function debounce(fn, delay) {
    let timeId;
    return (...args) => {
        if(timeId) {
            clearTimeout(timeId);
        }
        timeId = setTimeout(() => {
            fn(...args);
        }, delay);
    }
}
function throttle(fn, delay) {
    let flag = false;
    return (...args) => {
        if(flag) {
            return;
        }
        flag = true;
        fn(...args);
        setTimeout(() => {
            flag = false;
        }, delay)
    }
}
- 第四遍 2025.2.18 -
- 第三遍 2025.2.16 -
❌ // 1、debounce 遗漏赋值：timeId = setTimeout()
⭐️ // throttle：间隔多少秒执行一次
❌ // 2、throttle：判断条件应该是 if(flag){return}：flag 为 true 时，证明这段时间内已经执行了
- 第二遍 2025.1.21 -
- 第一遍 -
```

```js
// 作业10：说出WeakMap/WeakSet和Map、Set的区别，为什么有这两个弱类型，经常用在什么场景
- 第二遍 2025.2.23 -
WeakMap/WeakSet 的属性是对象，没有引用时，垃圾回收机制可以清理空对象的引用 ⭐️ // 键/值
Map、Set 不被垃圾回收机制清理 ⭐️ // 避免内存泄漏
场景：私有变量，例如属性引用 DOM，一旦DOM被删除，相关 WeakMap/WeakSet 就会被删除
❌ // 1、Map 和 Set 对存储的对象持有「强引用」，只要它们存在，对象就不会被回收 - 强引用意味着只要 Map 或 Set 存在，并且其中存储了某个对象，那么这个对象就不会被垃圾回收。即使在其他地方没有对该对象的引用，Map 或 Set 内部的引用会阻止垃圾回收器将其回收
❌ // 2、而 WeakMap 和 WeakSet 对存储的对象持有「弱引用」，不会阻止对象被垃圾回收
- 第一遍 2024.12.25 -
```

```js
// 作业8：ES6新增了两个创建数组的静态方法：Array.from()和Array.of()两个有什么区别？
- 第二遍 2025.2.23 -
Array.from 类数组（arguments+有index、length属性的对象 NodeList）、可迭代对象 转换成数组
	- 浅拷贝
Array.of 一系列参数 转换成数组 ⭐️ // Array.prototype.slice.call(arguments)
- 第一遍 2024.12.25 -
```

```js
// 作业12：画出一个原型链，到 null 为止
- 第二遍 2025.2.23 -
const person = new Person();
person.__proto__ -> Person.prototype
	Person.prototype.constructor -> Person
	Person.prototype.__proto__ -> Object.prototype
Object.prototype.constructor -> Object
Object.prototype.__proto__ -> null
- 第一遍 2024.12.25 -
```

```js
// 作业11：写出一个用 yield 实现的递归算法，从0数到指定n
- 第二遍 2025.2.22 -
function nTimes(n){ ❌ // 1、yield 只能在生成函数中使用 * -> 少写了*号
    if(n===0){ ❌ // 2、的确是 n > 0 才需要继续递归 -> 但是这么写，不是 next 的{value,done}格式，调用迭代器调用拿不到 0 这个值
        return n
    }
    yield * nTimes(n-1)
	❌ // 3、少写了 yield n-1 -> 上面的 yields * 是把 nTimes 进行一一迭代，yield 才是传递的每个迭代里的具体值
}
for(let i of nTimes(3)){
    console.log(i)
}
- 第一遍 2024.12.25 -
function * nTimes(n) {
    if(n>0) {
        yield* nTimes(n-1);
        yield (n-1);
    }
}
```

```js
// 作业9：数组自带排序 sort() 为什么经常要传比较函数？写一个降序的比较函数。如果数组元素全是数值，请给出简写形式
- 第二遍 2025.2.22 -
sort 默认会把数组的每一项转换成字符串后比较，会出现结果 [1,10,15,2,3,4]
sort((a, b) => return a>b ? -1 : a<b ? 1 : 0)
sort((a, b) => b-a)
- 第一遍 2024.12.25 -
```

```js
// 作业7：原始值包装类型和原始类型在使用 typeof 和 instanceof 进行类型判断时，有什么异同？
- 第二遍 2025.2.22 -
原始值包装类型 typeof x - 一直得到 "object" x instanceof String/Boolean/Number - true
原始类型 typeof x - 'strting'/'number'/'boolean' x instanceof String/Boolean/Number 一直false
- 第一遍 2024.12.25 -
```

```js
// 作业1：写一个只能被迭代指定次数的类
- 第二遍 2025.2.22 -
❌ // 1、写成 nTimes 没有读题
class count {
    constructor(n) {
        this.limit = n;
    }
    [Symbol.iterator]() {
        let limit = this.limit;
        let current = 0;
        return {
            next() {
				if(current < limit) {
                    return {value: current++, done: false}
                } else {
                    return {value: undefined, done: true}
                }
            }
            return() {
                return {value: undefined, done: true}
            }
        }
    }
}
- 第一遍 2024.12.25 -
// 答题核心：迭代器返回的是迭代器对象(包含next()、return()) + next 返回一个 done+value组成的对象
```

```js
// 作业 89：mysql 中类型的区别：varchar 和 char，date datetime
- 第二遍 2025.2.22 -
varchar(255) 固定长度存储，即使不固定也会补全 8字节
char(255) 按照内容长度存储
❌ // 1、varchar 可变长度存储；char 固定长度存储，不够则填充空格；tinytext 255字符；text 不限长度
date YYYY-MM-DD ⭐️ // 3字节
datetime YYYY-MM-DD HH-MM-SS ⭐️ // 8字节
- 第一遍 2025.2.8 -
⭐️ // char 内容长度不够时，使用空格填充到指定长度
```

```js
// 作业16（2）：arguments 对象对待命名参数和设置了默认值的命名参数有什么不同？数组作为参数传入函数得到的arguments 是什么？怎么实现arguments是数组？怎么收集独立参数？在对象字面量和数组字面量中，扩展运算符有什么不同的表现？
- 第四遍 2025.2.22 -
arguments 的值默认同步命名参数，但是不同步设置了默认值的命名参数
数组：arguments = [[1,2,3]] -> 扩展运算符 (...arr) -> arguments = [1,2,3]
独立参数 (first, ...rest) => ...rest 作为最后一项
对象字面量 {...obj} 创建一个新对象，复制所有可枚举属性
数组字面量 [...arr] 一个一个解析可迭代对象
- 第三遍 2025.2.8 - 
- 第一遍 -
❌ // 1、数组直接传入的 arguments 错了，应该是 [[1,2,3]]
❌ // 2、{...obj} 作用描述有问题，复制的是 可枚举属性
```

```js
// 2019.07 h5新标签和语义化，块/行内元素
- 第四遍 2025.2.22 -
1、SEO 优化 2、标签样式不同
新标签：header footer aside address article detail hgroup time datalist filedset section nav 
input 新属性：placeholder required multiple autocomplete autofocus ⭐️ // accesskey
input type 新属性：tel url number date week month datetime search range email ⭐️ // time
块元素 h1-h6 div hr p section table table-caption ul li dd dt ol ⭐️ // td tr address 
行内元素 br span select textarea button ⭐️ // i u a strong em b label
行内块元素 td img input
- 第三遍 2025.2.18 -
- 第二遍 2025.2.15 -
1、SEO 优化 2、标签样式不一样
❌ // 1、新标签少了：datalist detail time hgroup 
❌ // 2、input 属性少了：accesskey 
❌ // 3、input type 属性少了：url range search date time datetime week month 
❌ // 4、br - 错了，不是块元素，而是行内元素 + 块元素少了 h1-h6 td ol table-caption tr address hr
❌ // 5、行内元素少了：br i u a strong em button b label
- 第一遍 2025.1.9 -
```

```js
// 2024.12 模拟实现instanceof
- 第四遍 2025.2.22 -
function fakeInstanceOf(target, ctor) {
    let proto = target.__proto__; // Object.getPrototype(target)
    while(proto) {
        if(proto === ctor.prototype) {
            return true
        }
        proto = proto.__proto__;
    }
    return false
}
- 第三遍 2025.2.18 -
- 第二遍 2025.2.15 -
❌ // 1、获取 target 的原型链->应该是 target.__proto__ 或者 Object.getPrototype(target)
❌ // 2、判断原型链上是否和构造函数的原型对象相等，而不是和构造函数相等 proto===Ctor.prototype
❌ // 3、不停往上找原型链 -> 通过 __proto__或者getPrototype找，而不是 prototype 
- 第一遍 2025.1.9 -
```

```js
// 作业45：原生+canvas 显示一张png格式的图片
- 第四遍 2025.2.22 -
<canvas id='drawing' width=200 height=200></canvas>
const drawing = document.getElementById('drawing');
if(drawing.getContext){
    const imgData = drawing.toDataUrl('image/png');
    const dom = document.createElement('img');
    dom.src = imgData;
    document.body.appendChild(dom)
}
- 第三遍 2025.2.18 -
- 第二遍 2025.2.14 -
❌ // 1、需要判断是否存在 context 作为大前提：if(drawing.getContext){}
❌ // 2、image 标签添加 url 的属性是 src：image.src = imageData;
- 第一遍 2025.1.9 -
```

```js
// 2019.07 为什么要清除浮动？怎么清除浮动？
- 第六遍 2025.2.22 -
块元素把浮动元素当做不存在，行内元素围绕浮动元素；子元素浮动时，父元素高度塌陷，无法撑开背景
清除①给父元素添加 高度 ②父元素最后一个子盒子后添加 box .box{clear:both} ③父盒子伪元素 .father::after{ content:''; display: block; clear: both; } ④BFC .father{overflow: hidden}⭐️ // BFC 的盒子计算高度时包含浮动元素
- 第五遍 2025.2.18 -
- 第四遍 2025.2.15 -
❌ // 1、父元素+伪元素 应该是 display: block，否则撑不开父级全部宽度
- 第三遍 1.28 -
- 第二遍 1.25 -
❌ // 1、高度塌陷的描述：背景无法撑开 + padding、border 无法正常展示
❌ // 2、给父元素添加高度：宽度不对，高度+padding+border
- 第一遍 1.20 -
```

```js
// 作业2：支持迭代器的原生语言特性有哪些？
- 第六遍 2025.2.22 -
for-of Array.from ...扩展运算符 数组解构赋值 new Map/new Set yield * Promise.race/all
- 第五遍 2025.2.18 -
- 第四遍 2025.2.15 -
❌ // 1、少写了 yield * 只能在生成器中使用
- 第三遍 1.28 -
- 第二遍 1.25 -
- 第一遍 1.20 -
```

```js
// 2025.02 Nextjs 获取链接中的参数
- 第一遍 2025.2.22 -
import { useParamsUrl } from 'next/navigation';
❌ // 1、核心函数的名称记错：useSearchParams
const date = useParamsUrl().get('date');

import { useParamsUrl } from 'next/route'; ❌ // 2、另一个依赖包是 react-route-dom
const [params, useParams] = useParamsUrl();
❌ // 3、应该是 params 和 setParams
const date  = params.get('date');
❌ // 4、使用 useSearchParams 需要配套 <Suspense> 在 layout.tsx 处理路由的异步加载
export default function RootLayout({children}:ReadOnly<{
                                    children: React.ReactNode
                                    }>){
    return (<html lang='en'>
            	<body>
            		<Suspense fallback={<div>Loading...</div>}>
            			{children}
            		</Suspense>
            	</body>
            </html>)
}
```

```js
// 2025.02 Mysql 8.0 以上，Sequel报插件错
- 第一遍 2025.2.22 -
本地：使用 mysql 安装包下载，dmg 安装时选择插件 ⭐️ // Use Legacy Password Encryption
线上：指令切换 mysql  ❌ // 1、将 root 用户的认证插件修改为 mysql_native_password
```

```js
// 作业98：sequelize 怎么写关联表的查询，指定关联的 column 是date
- 第三遍 2025.2.22 -
先给两张表创建关联关系，再在查询的时候使用 includes
A.hasMany(B, {
    foreignKey: B_id,
    sourceKey: A_id
})
B.belongsTo(A, {
    foreignKey: B_id,
    targetKey: A_id
})
const res = A.findAll({ ❌ // 1、查询需要 await
    where1,
    includes: [{ ❌ // 2、查询关键词是 include
        table: B, ❌ // 3、include 关联表是 model 来声明
        where2
    }]
})
- 第二遍 2025.2.17 -
❌ // 1、查询不会 await A.findAll({ include: [{ model:B }] })
- 第一遍 2025.2.13 -
❌ // 1、关键词记错了：belongsTo
❌ // 2、查询不会 await A.findAll({ include: [{ model: B }] })
```

```js
// 作业97：Sequelize 中查找某条数据，如果存在就更新；不存在就创建一条
- 第三遍 2025.2.22 -
const [issue, created] = await table.findOrCreated(data, where);
❌ // 1、findOrCreated 参数错误 findOrCreated({ where, defaults: data })
if(!created){
    await issue.set(data); ❌ // 2、set 不需要 await
    await issue.save()
}
- 第二遍 2025.2.17 -
❌ // 1、findOrCreate 的数据源属性名记错 defaults
❌ // 2、先set数据，再保存 issue.set(data); await issue.save();
- 第一遍 2025.2.13 -
❌ // 1、需要获取函数的返回值，获取是否为新创建 const [issue, created]
❌ // 2、数据源没有传入 defaults: data
❌ // 3、如果已经存在，更新描述需要单独处理
```

```js
// 作业 96：Sequelize 中 Date 的怪问题 - POST 存储 DATE 类型，GET 传参数2025-01-27 STRING，无法直接查询，有那些性能高的查询方法？索引是什么，为什么性能高？
- 第三遍 2025.2.22 -
法1
const start = dayjs.utc(new Date(time)).startOf('day').toDate();
const end = dayjs.utc(new Date(time)).endOf('day').toDate();
const res = await table.findAll({
    where: { date: {
        [op.betwwen]: [start, end]
    } }
})
法2
const where = sequelize.where(
	sequelize.fn('DATE', sequelize.col('date')),
    ⭐️ // sequelize.fn('DATE_FORMAT', sequelize.col('date'), '%Y-%M-%D')
    '=',
    time
)
索引：数据表用来快速检索的树结构，单独存储于表之外，法1可以借用索引优化，索引就是查找的时候，不是全表遍历，而是根据索引先查找
⭐️ // 索引可以快速定位到查询条件的数据位置，从而减少 IO 操作
- 第二遍 2025.2.17 -
❌ // 1、函数式写法，少写了 sequelize.where 
- 第一遍 2025.2.13 -
❌ // 1、方法一：需要先将传入的 string 转换成 date + 还需要处理成 Date 类型查询
❌ // 2、方法二：sequelize.fn 两个函数不清晰
❌ // 3、索引不清晰
```

```js
// 2021-07 常见Webpack问题
/** 1、webpack的几个核心概念理解：Chunk、Module、plugin
2、常见配置项：entry、output、module、resolve等
自定义 loader 怎么配置？
3、Code Splitting 和 Tree Shaking 的区别？懒加载怎么实现？
4、html-webpack-plugin 作用？
5、sourceMap不同环境的区别？怎么开启配置？
6、热更新怎么实现？
7、webpack原理/执行过程？
开发插件的桥梁？*/
- 第四遍 2025.2.21 -
1、Chunk 由多个模块组成，由entry分组、Module万物皆模块、plugin插件，在构建的特定时机注入代码
2、entry:'main.ts'/{main:'main.ts', sub:'sub.ts'}
output:{filename:'[name]-[hash].js', path: path.resolve(_dirname, 'dist')}
module:模块解析规则{rules: [
    {test:/.\js/, use:['my-loader']},
    {test:/.\css/, use: ['style-loader', 'css-loader', 'less-loader']}
]}
resolve: 模块查找规则 {
    alias: {'@c': './src/component'},
	extensions: ['ts', 'js', 'json'],
	modules: ['node_modules', path.resolve(_dirname, './src/myLoader')]
}
自定义 loader 
① 在 module.rules use 时直接使用具体地址 use:[path.resolve(_dirname, './src/myLoader/my-loader')]
② 在 resolve.modules 查找配置中写明地址 + 在 module.rules 直接使用 loader，如上
3、Code Splitting：按需加载，以 entry 分组，加载页面时只加载当前需要使用的部分，提高渲染效率 ⭐️ // splitChunk 插件开启配置
Tree Shaking：按需打包，以 entry 分组，只打包相关代码，减小包体积 ⭐️ // 默认开启
懒加载：利用 code splitting，首次渲染的时候，按需加载，提高渲染效率
4、html-webpack-plugin 将 webpack 打包的 js css 等引入 html 文件，可以直接访问
5、sourceMap
devtool: eval-cheap-source-map; 本地 ⭐️ // cheap-eval-source-map
devtool: hidden-source-map; 在线
6、热更新 ① webpack 启动时，dev-server 在内存中启动服务，并注入 HMR 代码
② 监听 Compilor 的 done 事件，得到 mainfest.json 和 chunk.js，本地服务通过 Websocket 将 mainfest 推送到浏览器，浏览器拿到文件中的 chunkId，发起 ajax 获取模块代码
③ 拿到模块代码后，执行 window.updateWebpack -> hotApply 热更新当前模块，不刷新页面，只替换 ⭐️ // window.webpackHotUpdate
④ webpack.__require__ 执行模块代码
7、webpack原理 ① 合并配置：shell 脚本 和 配置文件 ⭐️ // 初始化参数配置
② 利用配置实例化 Compiler，加载所有 plugin 插件，执行 .run() 开始构建
③ 从 entry 为入口，依次遍历所有文件，执行所有的 loader 转换
④ 得到文件关系 和转换后的文件，按照 entry 分组输出到下载列表
⑤ 按照 output 输出，下载到指定路径
开发插件的桥梁：Compiler - webpack 的生命周期，唯一
Compilication - 文件每更新一次，就创建一次编译
- 第三遍 2025.2.18 -
- 第二遍 2025.2.14 -
❌ // 1、entry: 配置方式记错 - 不识别 path 这个属性 + output 配置属性记错
❌ // 2、resolve 的作用不是解析，是「依赖查找配置规则」+ module 的作用是：依赖解析、转换配置
❌ // 3、resolve 的属性 modules + extensions 错误
❌ // 4、开启 Code Splitting 配置的方式：splitChunk 插件配置
❌ // 5、devtool:cheap-eval-source-map; （不提供列信息）方便代码调试
❌ // 6、 监听到 compiler 的 done 事件 得到的文件是 chunk.js 文件，浏览器从 mainfest.json 文件中得到了 ChunkId，获取 chunk.js
❌ // 7、window.webpackHotUpdate -> hotApply 热更新函数，替换原有模块代码
- 第一遍 2024.12.26 -
```

```js
// 2020.07 对象分类、Promise按序执行、实现map
- 第六遍 2025.2.21 -
function classify(arr, property) {
    return arr.reduce((pre, cur) => {
        const key = cur[property];
        if(!pre[key]) {
            pre[key] = [];
        }
        pre[key].push(cur);
        return pre;
    }, {})
}
function list(arr, init) {
    return arr.reduce((pre, cur) => pre.then(cur), Promise.resolve(init));
}
Array.prototype.fakeMap = function(callback, thisArg) {
    return this.reduce((pre, cur, index, array) => {
        pre[index] = callback.call(thisArg, cur, index, array);
        return pre;
    }, [])
}
- 第五遍 2025.2.18 -
❌ // 1、classify分类函数：reduce 的初始值应该是 {} 而不是 []
❌ // 2、map 是 Array 上的高阶函数，之前写错成 Function(想成bind了)，重写了
- 第四遍 2025.2.14 -
❌ // 1、again，map 接收两个参数，一个 callback 函数，另一个是 this 指向
- 第三遍 2025.1.24 -
- 第二遍 2025.1.19 -
❌ // 1、map 函数接收两个参数，第一个是 callback，第二个是 thisArg - 用来指定 this
⭐️ // reduce filter map forEach 会跳过 empty 的数组项（ map 和 reduce 都跳过）
- 第一遍 -
```

```js
// 作业95：唯一索引什么作用？Sequelize 中 define modal 的时候，怎么创建组合字段唯一索引？SQL怎么写？updateOnDuplicate 是什么作用？怎么配合唯一索引。 define 中的第三个参数中常见配置
- 第三遍 2025.2.21 -
唯一索引：声明后，保证组合唯一，不会重复 ⭐️ // 确保索引字段的组合值
sequelize.define('database', {
    name: DataTypes.STRING
}, {
    indexes:[{
        unique: true,
        fields: ['date', 'sort']
    }]
})
SQL: CREATE INDEX dix_date_sort ON `database` (`date`, `sort`)
❌ // 1、CREATE UNIQUE INDEX - 少写了 UNIQUE，或者写 ADD UNIQUE KEY `dix_date_sort` (`date`, `sort`)
bulkCreate(data, { updateOnDuplicate: [name, age] }) 批量添加数据的时候，如果唯一索引有重复项，不添加数据而是修改 updateOnDuplicate 中声明的 field，没声明的不修改 ⭐️ // 执行更新而不是抛出错误，被指定的字段才会被更新，未指定的字段保持不变
define 的第三个参数 
underScore - 驼峰映射下划线；timeStamp: false - 不自动创建created_at、updated_at ❌ // 2、属性名称 underScores、timeStamps
- 第二遍 2025.2.17 -
❌ // 1、创建的 SQL 关键词：CREATE UNIQUE INDEX idx_date_sort ON `table` (`date`, `sort`)
❌ // 2、ADD UNIQUE KEY `idx_date_sort` (`date`, `sort`)
❌ // 3、timestamps: false, tableName: 'users'
- 第一遍 2025.2.13 -
```

```js
// 作业94：Nextjs fetch 为什么接口查询之后，一般都要使用 .json() 来转化一次数据后再返回？sequelize findAll/findOne 可以通过传递参数获取 js 格式的数据
- 第三遍 2025.2.21 -
Nextjs fetch 查到 Response 类型，包含了响应头、响应体、状态码等
.json() 用于将数据转换成 json ，再转成 js 对象 ⭐️ // await res.json()
findOne({ where, plain: true})
findOne/findAll({ where, raw: true})
plain: 拍平最外层，嵌套结构保留
raw: 多层级直接拍平 ⭐️ // 关联数据会直接合并到主对象
- 第二遍 2025.2.17 -
❌ // 1、状态码、响应头、响应体
❌ // 2、await res.json()
- 第一遍 2025.2.12 -
```

```js
// 作业88：mysql2 和 Sequelize 的使用场景？有哪些差异？简单写一个连接
- 第七遍 2025.2.21 -
mysql2: 为了 node 环境的数据库驱动，可以直连数据库，需要写很多 SQL
	- 提供 mysql2/promise 支持 async await 异步操作，可以管理多个数据库连接
Sequelize：将数据库的表和行映射为对象模型 ORM，适用于函数式编程 ⭐️ // 直接通过 js 操作
mysql2
import { createPool } from 'mysql2/promise'
const pool = createPool({host, user, password, database});
const con = await pool.getConnect(); ❌ // 1、获取连接 函数错了 getConnection()
consr [rows] = con.execute('SELECT * FROM table'); ❌ // 2、执行 SQL 需要 await
Sequelize
import { Sequelize, Modal, DataTypes } from 'sequelize';
const se = new Sequelize(database, user, password, {
    host: 'localhost',
    dialect: 'mysql2'
});
定义 mysql 模型 法1
class User extends Modal{}
User.init({
    name: DataTypes.STRING
}, {
    sequelize: se,
    modelName: 'users'
})
法2
sequelize.define('users', { ⭐️ // const User = ...
    name: DataTypes.STRING
}, {
    unserScore: true,
    timeStamp: false
})
- 第六遍 2025.2.17 -
- 第五遍 2025.2.12 -
❌ // 1、sequelize：实例化参数错误 + init 参数错误
❌ // 2、sequelize：define 第三个参数应该是一些配置
- 第四遍 2025.2.9 -
❌ // 1、sequelize：实例化的参数错误 + init 参数错误
- 第三遍 2025.1.31 -
❌ // 1、mysql2：导入依赖包错了 mysql2/promise + createPool的参数 少写了 database
❌ // 2、mysql2：获取连接的函数错了 await pool.getConnection()
❌ // 3、mysql2：需要使用 await 执行 SQL
❌ // 4、sequelize：有两种模型定义方法：一种是 define，另一种 extends Modal + init
- 第二遍 2025.1.26 -
❌ // 1、mysql2：依赖包是 mysql2/promise
❌ // 2、mysql2：创建连接池 createPool 不需要 await
❌ // 3、mysql2：获取连接时需要 await + 需要使用 await 执行 SQL
❌ // 4、sequelize：实例化的参数错误 + init 参数错误
- 第一遍 2025.1.22 -
```

```js
// 作业87：Nextjs 中预渲染是什么？有哪些模式？写一个动态路由的page
- 第七遍 2025.2.21 -
预渲染：服务端渲染 SSR getServerSideProps、静态生成 SSG generateStateParams、增量静态生成 ISR revalidate ❌ // 1、静态生成 的函数名称是 generateStaticParams 中间不是 state 是 static
⭐️ // 服务端渲染 - 在请求时，服务端直接引入数据生成 HTML，客户端直接渲染，不需要使用客户端js
⭐️ // 静态生成 - 构建、运行时，间隔更新时间，自动增量式创建新的 HTML
SSG
export default function Blog({slug}) { return <div>{slug}</div> }
export const revalidate = 60; // 页面重新验证时间
export async function generateStateParams() { ❌ // 2、generateStaticParams
    return [{slug:'first'}, {slug:'second'}]
}
SSR
import { getServerSideProps } from 'next/server';
export default function Blog({data}) { return <div>{data}</div> }
export async function getServerSideProps(){
    const res = await fetch('xxx');
    const data = await res.json();
    return {props: {data}}
}
- 第六遍 2025.2.17 -
- 第五遍 2025.2.12 -
❌ // 1、SSG：函数 少写了 async
❌ // 2、SSR：函数 少写了 async
- 第四遍 2025.2.9 -
❌ // 1、名称错误：服务端渲染SSR、静态生成SSG、增量静态生成ISR + 客户端、服务端生成的结果都是 HTML
❌ // 2、SSR：函数名称、依赖包错误 getServerSideProps next/server
❌ // 3、SSG：函数名称错误 generateStaticParams
- 第三遍 2025.1.31 -
❌ // 1、SSG：记错函数名称 generateStaticParams，用于生成动态路由的参数列表 + 少写了 revalidate
❌ // 2、SSR：异步解析数据 需要 await - data.json() 是异步的，处理 json 数据转换为 js 对象       
- 第二遍 2025.1.26 -
❌ // 1、SSR: fetch 数据需要 await  +  异步解析数据需要 await
- 第一遍 2025.1.22 -
```

```js
// 作业68：React hooks 的原理是什么？useEffect useState模拟实现
- 第八遍 2025.2.21 -
hooks 闭包+链表，目的是在不使用类组件的情况下依旧可以使用 state、状态管理、模拟生命周期
useEffect
const render = () => { 
    ReactDOM.render(<App />, document.getElementById('id'));
    cursor = 0;
};
const memorized = {};
let cursor = 0;
function fakeUseEffect(callback, array) {
    const lastDep = memorized[cursor];
    const hasChanged = lastDep && lastDep.some((it, index) => Object.is(it, array[index]))
    if(!lastDep || hasChanged){
        callback();
        memorized[cursor] = array;
        render();
    }
    cursor++;
}
useState
function fakeUseState(init){
    const current = cursor;
    memorized[current] = memorized[current] ?? init;
    const useValue = (newV) => {
        memorized[current] = newV;
        render();
    }
    cursor++;
    return [memorized[current], useValue]
}
- 第七遍 2025.2.17 -
- 第六遍 2025.2.12 -
❌ // 1、原理：没有事件委托，主要是 闭包和链表 + 少写了 hooks 的创建目的
❌ // 2、render：ReactDOM.render(<App />, document.getElementById('root')); 
❌ // 3、useEffect：使用 find 得到的是值，应该使用 some + 判断条件应该是 !Object.is
❌ // 4、useState：少写了 值 的初始化 memorized[current] = memorized[current] ?? init;
- 第五遍 2025.1.23 -
- 第四遍 2025.1.18 -
❌ // 1、render：ReactDOM.render(<App />, document.getElementById('root'));
❌ // 2、UseState：cursor++ 忘记写游标自增了
- 第三遍 2025.1.13 -
❌ // 1、不是描述 hooks 的执行过程，先描述【目的】state、状态管理、模拟生命周期，再描述【实现上述目的的方法】闭包 + 链表
❌ // 2、UseEffect：some 应该是判断「不等于」- 有不相等的，代表依赖数组变化，需要更新 !Object.is
❌ // 3、UseEffect：少写了「更新依赖数组」的逻辑：memorized[count] = array;
function fakeUseState(init) {
    const currentCount = count;
    let value = memorized[currentCount] ?? init;
    ❌ // 4、使用 value 会导致返回后，value 不会自动更新，和 memorized[currentCount] 失去了联系，本行改为：memorized[currentCount] = memorized[currentCount] ?? init;
    const setValue = (newValue) => {
        memorized[currentCount] = newValue;
        ❌ // 5、调用 useValue 必须触发 render：render();
    }
    count++;
    return [value, setValue]
    ❌ // 4.1、延续问题4，本行修改为：return [memorized[currentCount], setValue]
}
- 第二遍 -
❌ // 1、hooks 目的：不只是「生命周期替代能力」，还有「状态管理能力」、「逻辑复用能力」，还包括 state（没有 hooks 的函数组件主要接收 props 来展示 UI）
❌ // 2、hooks + 副作用链表：hooks 在组件更新时是「全部按序重新执行一遍」，副作用链表是「在 hooks 执行过程中，如果 useEffect 依赖有更新」，就更新到副作用链表
❌ // 3、UseEffect：cursor应该使用其他变量保存，和下文中 setValue 形成闭包 - 在异步情况下，cursor 可能会变化，导致索引错误
❌ // 4、UseState：要触发一次 render() 
- 第一遍 -
```

```js
// 作业67：React 怎么做的性能优化？
- 第七遍 2025.2.21 -
1、fiber 架构：优先级调度、增量式Diff、时间分片、渐进式渲染
2、跳过重新渲染策略： eagerState策略 - 如果 state 的新值和旧值无关，可以直接渲染，而不需要再去查询旧值
    bailout策略 - 比较组件的 state 和 props，不变化则跳过重新渲染
①类组件 shouldComponentUpdate(nextProps, nextState) 自定义布尔值表示是否重新渲染
②函数组件 React.memo((props) => return <div>{ props.text }</div>) 浅比较 props，不变则跳过
③useCallback((v) => v*2, [v]); useMemo((v) => v+1, [v])
- 第六遍 2025.2.17 -                                
- 第五遍 2025.2.12 -
❌ // 1、少写了 函数组件 React.memo - 浅比较props，不变则直接复用 
// 记忆法：shouldComponentUpdate(类组件)/React.memo(函数组件) + 2个hook：useMemo/useCallback
- 第四遍 2025.1.23 -
- 第三遍 2025.1.18 -
 ⭐️ // useCallback：每次渲染，函数都是重新生成的，用了这个就缓存住了
- 第二遍 2025.1.12 -
❌ // 1、React.memo：对于「函数组件」，React 提供了 React.memo 这个高阶函数来处理 -> 对组件的 props 进行浅比较，如果不变则跳过重新渲染
- 第一遍 -
```

```js
// 69.x 的平方根
- 第一遍 2025.2.21 -
function sqrt(n){
    const half = Math.ceil(n / 2);
    let res = 1; ❌ // 1、res 应该从 0 开始数，否则 n 为 0 时会返回 1
    while (res <= half) {
        const next = res + 1;
        if (res * res <= n && next * next > n) {
            return res
        }
        res++;
    }
    return res
}
⭐️ // 另一种空间换时间的写法
function sqrt2(n) {
    let left = 0;
    let right = n + 1;
    while (left + 1 !== right) {
        const mid = Math.ceil((left + right) / 2);
        if (mid * mid > n) {
            right = mid;
        } else {
            left = mid;
        }
    }
    return left
}
```

```js
// 作业64：Vue渲染怎么实现的？
- 第八遍 2025.2.20 -
AOT 预编译 + 模版编译：
	parse 词法分析、语法分析得到 AST
	optimize 标记静态节点，方便后续 diff/patch 跳过静态节点
	generate 生成 render 函数
数据双向绑定
	借用发布订阅、数据劫持实现双向绑定 Object.defineProperty(obj, 属性, {get, set})/Proxy
	在组件初始化、实例化 Watcher时，访问 set 触发组件的 Dep 收集当前正在执行的 Watcher ⭐️ // getter
    在渲染、更新组件时，get 触发更新所有的 Watcher - dep.notify() ⭐️ // setter
执行 render，得到 VDOM
执行 patch/diff ，计算得到最小 UI 更新量，应用到真实 DOM
- 第七遍 2025.2.17 -
- 第六遍 2025.2.11 -
❌ // 1、模版编译的阶段名称错误：parse - optimize - generate
❌ // 2、函数使用方法错误：Object.defineProperty(obj, 属性, { get, set })
- 第五遍 2025.1.23 -
- 第四遍 2025.1.18 -
- 第三遍 -
❌ // 1、数据劫持之后，触发订阅的时机是「渲染组件，实例化 Watcher 时，执行到 getter 触发对应的 Dep 收集正在执行的 Watcher」
- 第二遍 -
❌ // 1、模版编译执行步骤的最后一步是 generate
❌ // 2、AOT 预编译功能是针对 template 的，不是针对 js 的
- 第一遍 -
```

```js
// 2019.07 盒模型有哪些？有什么区别？
- 第二遍 2025.2.20 -
box-sizing: border-box; Width 是 Content+border+padding 的组合大小，IE 盒模型
box-sizing: content-box; Width 是 Content 内容大小，W3C 标准盒模型
- 第一遍 2025.1.20 -
```

```js
// 作业16（1）：箭头函数和普通函数的区别是什么？（3点）
- 第二遍 2025.2.20 -
没有 this，this 指向定义时的上下文；没有 argument、new.target、super；没有原型；不能用作构造函数
- 第一遍 2025.1.20 -
```

```js
// 作业32：什么是队头阻塞？原因是什么？怎么解决？
- 第二遍 2025.2.20 -
队头阻塞：一个请求没有返回，其他请求排队等待返回后再发起
原因：TCP 有丢包机制，拿不到响应就挂着，一个包不回来，影响其他 ❌ // 1、请求-应答模式导致的
解决：
❌ // 2、HTTP/1.1 优化的方案：域名分片 + 并发连接
升级到 Http/2.0 在应用层解决了队头阻塞问题，采用二进制流-多路复用，多个请求响应之间没有顺序关系，但是 TCP 传输层还没解决；
HTTP/3.0 采用 UDP，彻底解决队头阻塞
- 第一遍 2025.1.20 -
⭐️ // HTTP/3 QUIC 协议
```

```js
// 作业40：写出以下值
- 第二遍 2025.2.20 -
1、 0  2、NaN 
3、NaN undefined ❌ // 1、少写了 {}
4、Number - 0 parseInt、parseFloat - NaN ❌ // 2、Number-含有非数字字符就NaN parseInt-非数字开头即NaN
5、'122' '32' '02' 'NaN2' NaN 6、30 32
7、12 位操作符会把左右两边都转换成32位的值，即转换为整数 ⭐️ // 位操作符只能操作 32 位的整数
8、undefined 其实是从 null 继承而来，规定相等测试为 true ⭐️ // 派生
- 第一遍 2025.1.20 -
```

```js
// 作业62：fiber架构是什么？优点和实现方式？
- 第八遍 2025.2.20 -
三个主流程
Scheduler 调度器，主要用于优先级调度，在整个渲染流程中，主要用于宏观调控
Reconciler 协调器，主要用于在重绘/空闲时间判断是否要执行单元渲染任务，根据 shouldYield 判断，对应 render 阶段
Render 渲染器，对应 commit 阶段，更新真实 DOM
	Scheduler、Reconciler：这两个流程都是在内存中执行的，异步，随时可能被以下几种情况打断：报错、时间分片不够、优先级更高
	Render：同步，更新真实 DOM，不能暂停
优点：
1、优先级调度：优先渲染用户交互、视口等，提高用户体验，非视口优先级延后
2、渐进式渲染 + 时间分片：之前 react 的渲染是需要对比、更新整棵 VDOM 树，在主线程同步执行，会阻塞重绘；使用 fiber 之后，会将整个渲染任务分为一个个小的渲染任务单元，在空闲时间、重绘之前进行判断是否有足够时间执行一个渲染任务单元
3、增量式 Diff：不再比较一整颗树，而是在逐步执行渲染单元任务时，比较更新真实 DOM，提高 diff 算法效率
- 第七遍 2025.2.17 -
- 第六遍 2025.2.10 -
❌ // 1、时间切片：之前 react 会对整棵树 对比+更新，同步执行，会长时间占用主线程，阻塞重绘 ； 描述优化：小的单元任务，在空闲 + 重绘判断执行
- 第五遍 2025.1.22 -
- 第四遍 2025.1.18 -
❌ // 1、忘记中文：Scheduelor 是调度器
❌ // 2、时间切片：应该先说明 react 每次更新都要递归构建整棵 fiber 树+比较+更新，长时间占用主线程，会阻塞重绘 
❌ // 3、增量式 Diff：不是一次性比较整棵树，而是根据任务执行进度，逐步比较、更新部分节点 - 减少了每次比较的范围，提高了效率 
- 第三遍 -
❌ // 1、少写了 Reconciler 协调器，作用是「调用 shouldYield 判断当前 Time Slice 是否有剩余时间」
❌ // 2、Scheduler + Reconciler 不是因为「异步」才可以被打断，是以为「他们都在内存中执行，不会更新宿主环境 UI」
❌ // 3、写错了 Render「渲染器」
❌ // 4、优点：渐进式渲染、优先级调度、增量式 Diff、时间分片
- 第二遍 -
❌ // 1、少一个 增量式 Diff
- 第一遍 -
```

```js
// 作业58：React和Vue是怎么描述UI的
- 第七遍 2025.2.20 -
React: JSX=HTML+JS、类组件 函数组件、state 组件状态 props 传入组件属性、{}
Vue: 模版语法 + 指令 v-if v-if-else v-else v-for v-show v-model + {{}}
- 第六遍 2025.2.17 -
- 第五遍 2025.2.10 -
❌ // 1、React 少写了 ：类组件+函数组件
❌ // 2、Vue 少写了：模版语法 + v-show
- 第四遍 2025.1.22 -
- 第三遍 2025.1.18 -
- 第二遍 -
❌ // 1、React 少写了 ①自定义组件-函数组件、类组件 ②state、props
- 第一遍 -
// ❌ 1、React 少写了： 可以自定义组件 + 使用花括号{}将js嵌入JSX {note} + state、props
// ❌ 2、Vue 少写了：模版语法 + 使用双大括号展示数据{{note}} + 指令
```

```js
// 2019.07 隐式转换:{}+{}=?
- 第二遍 2025.2.20 -
'[object Object][object Object]'
- 第一遍 2025.1.8  -
```

```js
// 2019.07 引用css，link和@import的区别
- 第二遍 2025.2.20 -
link XML标签，浏览器都兼容，渲染进程 预解析线程提前下载；js 可获取修改 ❌ // 1、少写了：可以处理 rss 等其他事务
import css2.0提出，低版本有兼容问题，遇到再下载，由于下载时机；js难以获取修改 ❌ // 2、少写了：只能加载 css
- 第一遍 2025.1.8  -
```

```js
// 作业33：Cookie 怎么设置有效期？有优先级吗？HttpOnly 是什么含义？
- 第二遍 2025.2.20 -
Cache-control: max-age=2000;[优先级高]
Expires: deadline;
HttpOnly：仅限 HTTP 协议访问，浏览器禁用 js 访问 cookie，例如 document.cookie
- 第一遍 2025.1.8  -
```

```js
// 作业31：什么是长连接？长连接的属性怎么写？哪个版本开始启用长连接？
- 第二遍 2025.2.20 -
客户端和服务端建立连接，不关闭；之前每次请求都要重新建立连接 ⭐️ // 长连接后，一个连接可以处理多个请求响应
keep-alive ⭐️ //  Connection: keep-alive
从 HTTP/1.1 开始启用
- 第一遍 2025.1.8  -
```

```js
// 作业30：简单写出一个请求头和响应头。HTTP/1.1中唯一要求请求头必须提供？写出常见状态码
- 第二遍 2025.2.20 -
请求头 GET index.html  ❌ // 1、GET /index HTTP/1.1
响应头 HTTP/1.1 200 OK
HTTP/1.1中唯一要求 HOST
常见状态码 
200 OK 正常请求
204 No Content 只有响应头，没有响应体
301 Moved Permanently 永久重定向，使用响应体中的 Location
302 Moved Temperaily 临时重定向，使用响应体中的 Location
304 Not Modified 使用本地缓存，刷新缓存时间 ⭐️ // If-modified-since/Last-modified + If-none-match/ETag
404 Not Found 资源不存在
401 请求错误，语法问题 ❌ // 2、400 Bad Request 请求有语法错误（格式不正确、缺少必要请求参数、请求体格式错误）
403 请求方法错误，不支持 ❌ // 3、403 Forbidden 请求资源禁止访问
❌ // 4、405 Method Not Allowed 使用了服务器不支持的 HTTP 请求方法
500 服务端错误
- 第一遍 2025.1.8  -
```

```js
// 作业14：Proxy 的原型是什么？怎么撤销代理关联？是否可逆？写几个常见的代理模式对应的捕获器
- 第二遍 2025.2.20 -
Proxy 的原型是 undefined ⭐️ // 所以不能使用 instanceof 查询，会报错
const {proxy, revoke} = Proxy.revocable(target, handle);
revoke(); // 不可逆
const handle = {
    get(...args) { return Reflect.get(...args) },
    set/has/constructor ⭐️ // apply 对应执行函数
}
- 第一遍 2025.1.8  -
```

```js
// 2024-11 数组乱序 洗牌算法
- 第二遍 2025.2.20 -
// 从最后一个元素开始，从数组中随机选出一个位置，交换，直到第一个元素
function chaos(arr){
    let n = arr.length - 1;
    while(n >= 0){
        const random = Math.floor(Math.random() * arr.length);
        [arr[random], arr[n]] = [arr[n], arr[random]];
        n = n-1; ⭐️ //  n--;
    }
    return arr
}
- 第一遍 2024.12.25 -
```

```js
// 2021-04 实现给定时间切换状态
- 第一遍 2025.2.20 -
async function promisesetTimeout(promise, delay){
    return await Promise.race([promise, new Promise((resolve, reject) => { 
        setTimeout(() => { reject(new Error('promise time out')) }, delay) 
        ⭐️ // setTimeout(reject, delay, new Error('promise time out'))
    })])
}
```

```js
// 2021-07 给DOM元素绑定事件
- 第一遍 2025.2.20 -
onclick 属性
dom.addEventListener('click', () => {})
```

```js
// 2021-07 前端路由的两种模式
- 第一遍 2025.2.20 -
history：history.go(n)/forward()/back()/pushState() - 更新浏览器的历史记录，但是没有请求服务器，通过返回/前进访问时，向服务器发起请求
❌ // 1、少写了 replaceState + popstate
/** 1、pushState - 向浏览器历史记录栈中添加一个新的历史记录条目，需要手动调用
	const title = 'New Page';
	const url = '/new-page';
	history.pushState({ page: 'newPage' }, title, url);
2、replaceState - 修改当前的历史记录条目，而不是添加新的条目（也不会触发页面刷新
	// 当前链接：https://www.mozilla.org/foo.html
	history.replaceState({ foo: "bar" }, '', url);
3、popstate - 在浏览器的历史记录发生改变时触发，例如点击前进/后退按钮、go/forward/back，pushState和replaceState不会触发这个事件
	window.addEventListener('popstate', (event) => {
		if (event.state) {
			console.log('State:', event.state); // 根据 event.state 更新页面内容
		}
	});
*/
hash：url 链接中 #hash，使用 前端来切换模块，和服务器无关
❌ // 1、少写了 location.hash + window.onhashchange
```

```js
// 2021-06 CSS性能优化
- 第一遍 2025.2.19 -
减少层级，因为 css 从右向左解析的
开启 GPU 加速，使用 transform、opacity ⭐️ // 减少使用昂贵属性
减少布局、大小调整，减少回流、重绘带来的性能消耗
code splitting 按需加载，懒加载 ⭐️ // 模块化
使用 link 而不是 import，使用渲染进程的预解析线程 预加载css文件
```

```js
// 2021.09 get和post有什么区别
- 第三遍 2025.2.19 -
get 参数携带在链接上；大小2kb；浏览器默认会缓存；回退无害，参数依旧正确 ⭐️ // 参数在请求行上
post 参数在请求体上；大小不受限；默认不缓存，可配置；回退有害，参数不保留
- 第二遍 2025.2.10 -
- 第一遍 2025.2.8 -
❌ // 1、从四个方面描述：数据参数 + 参数长度 + 回退安全性 + 缓存
```

```js
// 2021.06 链表 141. 环形链表
- 第三遍 2025.2.19 -
function isCircle1(head){
    try{
        JSON.stringify(head);
        ⭐️ // 可以写在这儿： return false
    }catch(e){
        return true
    }
    return false
}
function isCircle2(head){
    while(head) {
        if(head.isCircle){
            return true;
        }
        head.isCircle = true;
        head = head.next;
    }
    return false
}
- 第二遍 2025.2.10 -
- 第一遍 2025.2.8 -
❌ // 1、判断条件是 while(head) 
```

```js
// 2021.07 事件流 + 事件模型
- 第三遍 2025.2.19 -
事件流：
	先捕获 - 从上至下，从 window-document-html-body-. ，触发事件处理函数，再冒泡 - 从外向内 ⭐️ // 冒泡：从具体节点逐渐向上传播到 DOM 最高层父节点
事件模型：
	DOM2 事件模型 先捕获，执行事件处理函数，再冒泡
	现代浏览器 事件模型：利用事件冒泡，通过事件委托管理
- 第二遍 2025.2.10 -
❌ // 1、现代事件模型：是事件委托 - 利用事件冒泡，将事件处理程序添加到父元素；DOM2级事件模型：捕获+处理+冒泡
- 第一遍 2025.2.8 -
```

```js
// 作业93：闭包的作用和原理
- 第三遍 2025.2.19 -
闭包原理：内部函数引用外部函数变量，外部函数执行结束后，原本应该清理活动对象，但是被引用的函数保存在 closure 中，保留下来 ❌ // 1、原理少写了闭包依赖于「词法作用域」-作用域链-垃圾回收机制
闭包作用：保存变量的持续值 ❌ // 2、①保存状态：允许函数记住它被创建时的环境 + ②数据封装：创建私有变量 + ③回调函数：确保回调函数在调用时能访问到定义时的上下文 + ④函数工厂：创建定制化函数
- 第二遍 2025.2.10 -
❌ // 1、少写了 函数工厂、回调函数
- 第一遍 2025.2.8 -
```

```js
// 作业92：前端中的序列化是什么？常见序列化方法
- 第三遍 2025.2.19 -
序列化：把前端参数、json 转换成js对象
❌ // 1、将「数据结构、对象」转换为可以「存储、传输」的格式的过程
常见序列化： new formData(from)、JSON.stringify(obj); JSON.parse()
⭐️ // JSON.stringify 无法处理 Function、无法处理循环引用
⭐️ // new FormData 转换成「键值对」格式
- 第二遍 2025.2.10 -
❌ // 1、JSON.stringify 无法处理 Function、无法处理循环引用；new FormData 收集表单数据并序列化，转换成键值对格式
- 第一遍 2025.2.8 -
```

```js
// 作业91：三次握手的过程和具体包的作用
- 第三遍 2025.2.19 -
客户端 SYN 服务端
服务端 SYN + ACK 客户端(标志位)
客户端 ACK 服务端
SYN 序列包 + ACK 确认包
- 第二遍 2025.2.10 -
客户端和服务端建立 TCP 连接，SYN 序列编号包，ACK 确认包（标志位）⭐️ // SYN 同步序列编号包
- 第一遍 2025.2.8 -
```

```js
// 作业90：金玉满堂是什么意思？在花卉中的说法是什么？
- 第三遍 2025.2.19 -
形容很多财富，比喻有人学识很丰富
玉堂春富贵 玉兰 海棠 迎春 牡丹 桂花
- 第二遍 2025.2.10 -
- 第一遍 2025.2.8 -
```
