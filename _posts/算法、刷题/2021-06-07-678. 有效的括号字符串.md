---
layout:     post
title:      215. 数组中的第K个最大元素
subtitle:  
date:       2021-06-10
author:     
header-img: 
catalog: true
tags:
    - < 算法题 >
typora-root-url: ..
---

## 215. 数组中的第K个最大元素

在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

示例：[3,2,1,5,6,4] 和 k = 2  =>  5 ；  [3,2,3,1,2,4,5,5,6] 和 k = 4 => 4

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

- 1、自己写的算法，利用数组的 `sort` 直接处理

<img src="/../img/assets_2019/image-20210613132001921.png" alt="image-20210613132001921" style="zoom:35%;" />

时间复杂度：O(n)，空间复杂度：xx

```js
var findKthLargest = function (nums, k) {
    let res = nums.sort((a, b) => {
        if (a < b) {
          	return 1;
        } else if (a == b) {
          	return 0;
        } else {
          	return -1;
        }
    });
    return res[k - 1];
};
```

- 2、冒泡算法

<img src="/../img/assets_2019/image-20210613163346322.png" alt="image-20210613163346322" style="zoom:35%;" />

时间复杂度：O(n^2)，空间复杂度：xx

```js
var findKthLargest = function (nums, k) {
   	// i 要少一个
    for(let i = 0; i < nums.length - 1; i++) {
        for(let j = i+1; j < nums.length; j = j+1) {
          	// 较小的那位交换往后冒泡
            if(nums[i] < nums[j]) {
                let temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }
    }
    return nums[k - 1];
};
```

- 3、冒泡算法优化 - 找到第k个值就退出

利用题目找寻的是第k个值，将外部循环控制在k次

<img src="/../img/assets_2019/image-20210614231558216.png" alt="image-20210614231558216" style="zoom:35%;" />

时间复杂度：O(n^2)，空间复杂度：xx

```js
var findKthLargest = (nums, k) => {
    // 循环 k 次，只排序到第 k 个大的值
    for(let i = 0; i < k ; i++) {
        // 得从后往前，把大值的往前送
        for (let j = nums.length - 1; j >= 0; j--) {
            // 前面小于后面，则交换 -> 将值从大往小排
            if(nums[j] < nums[j + 1]) {
                let temp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = temp;
            }
        }
    }
    return nums[k - 1];
}
```



