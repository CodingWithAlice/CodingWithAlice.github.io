---
layout:     post
title:      模拟实现promise
subtitle:  
date:       2024-12-5
author:     
header-img: 
catalog: true
tags:
    - < 算法题 >
    - < LTN1 >
typora-root-url: ..
---

## 模拟实现promise

明确 Promise 的几个基本信息：
1、状态凝固 默认pending/resolved/rejected，改变一次后无法再变更
 2、传入的执行器有两个函数参数 resolve,reject，调用这两个函数触发状态变更
3、执行器是同步执行的
 4、then 微任务执行，两个函数入参 onResolved,onRejected - catch语法糖，resolve抛出的值/reject抛出的错误原因是两个函数的参数
5、then 返回的就是Promise，可以链式调用
6、finally 不论返回什么值，只要改变了状态就执行
 7、Promise.resolve()\Promise.reject() 可以直接返回状态凝固的Promise
8、Promise.all()/Promise.race()

常见错误：

<img src="/../img/assets_2023/image-20241205201152107.png" alt="image-20241205201152107" style="zoom:50%;" />

```js
let Status = {
    resolve: 'fulfilled',
    reject: 'rejected',
    pending: 'pending'
}
function MyPromise(executor) {
    let self = this;
    self.status = Status.pending;
    self.value = null;
    self.reason = null;
    self.resolvedCallbacks = [];
    self.rejectedCallbacks = [];

    const resolve = function (value) {
        if (self.status === Status.pending) {
            self.status = Status.resolve;
            self.value = value;
            self.resolvedCallbacks.forEach(it => it(self.value));
        }
    }
    const reject = function (reason) {
        if (self.status === Status.pending) {
            self.status = Status.reject;
            self.reason = reason;
            self.rejectedCallbacks.forEach(it => it(self.reason));
        }
    }

    try {
        executor(resolve, reject)
    } catch (e) {
        reject(e)
    }
}

// 5
MyPromise.prototype.then = function (onResolved, onRejected) {
    // this在实例化的时候指向实例本身
    const { value, reason, status, resolvedCallbacks, rejectedCallbacks } = this;

    // 兼容 then 的两个参数都是函数
    onResolved = typeof onResolved === 'function' ? onResolved : value => value;
    onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason; };

    // 链式调用
    const promise2 = new MyPromise((resolve, reject) => {
        // Promise 可以绑定多个 then 方法 
        // -> 状态已改变的promise调用then-立即执行
        // -> 状态未改变的promise调用then-异步执行 - 通过setTimeout来模拟异步调用
        const resolveFake = () => {
            try {
                const res = onResolved(value);
                resolve(res);
            } catch (reason) {
                reject(reason)
            }
        }
        const rejectFake = () => {
            try {
                const res = onRejected(reason);
                resolve(res);
            } catch (reason) {
                reject(reason)
            }
        }
        switch (status) {
            case Status.resolve:
                setTimeout(resolveFake, 0);
                break;
            case Status.reject:
                setTimeout(rejectFake, 0);
                break;
            case Status.pending:
                resolvedCallbacks.push(() => setTimeout(resolveFake, 0));
                rejectedCallbacks.push(() => setTimeout(rejectFake, 0));
                break;
        }
    })
    return promise2
}

// 4
MyPromise.prototype.catch = function (onRejected) {
    return this.then(null, onRejected);
}

// 6
MyPromise.prototype.finally = function (callback) {
    return this.then(value => {
        callback();
        return value;
    }, reason => {
        callback();
        throw reason;
    });
}

// 7
MyPromise.prototype.resolve = function (value) {
    return new MyPromise((resolve) => resolve(value))
}
MyPromise.prototype.reject = function (reason) {
    return new MyPromise((resolve, reject) => reject(reason))
}

// 8
MyPromise.prototype.all = function (arr) {
    return new MyPromise((resolve, reject) => {
        let result = [];
        let index = 0;
        for (let i = 0; i < arr.length; i++) {
            MyPromise.resolve(arr[i]).then(data => {
                result[i] = data;
                if (++index === arr.length) {
                    resolve(result);
                }
            }, err => {
                reject(err);
                return;
            });
        }
    });
}

MyPromise.race = function (arr) {
    return new Promise((resolve, reject) => {
        for (let i = 0; i < arr.length; i++) {
            MyPromise.resolve(arr[i]).then(resolve, reject);
        }
    });
}
```

```js
// 测试then方法
let promise1 = new MyPromise((resolve, reject) => {
    resolve(10);
});
promise1.then(value => {
    console.log('then success:', value);
}).catch(reason => {
    console.log('then catch:', reason);
});

// 测试catch方法
let promise2 = new MyPromise((resolve, reject) => {
    reject('error');
});
promise2.catch(reason => {
    console.log('catch:', reason);
});

// 测试finally方法
let promise3 = new MyPromise((resolve, reject) => {
    resolve(20);
});
promise3.finally(() => {
    console.log('finally called');
}).then(value => {
    console.log('finally then success:', value);
});

// 测试all方法
let promise4 = MyPromise.resolve(30);
let promise5 = MyPromise.resolve(40);
MyPromise.all([promise4, promise5]).then(values => {
    console.log('all success:', values);
}).catch(reason => {
    console.log('all catch:', reason);
});

// 测试race方法
let promise6 = MyPromise.resolve(50);
let promise7 = new MyPromise((resolve, reject) => {
    setTimeout(() => {
        reject('race error');
    }, 1000);
});
MyPromise.race([promise6, promise7]).then(value => {
    console.log('race success:', value);
}).catch(reason => {
    console.log('race catch:', reason);
});

// 测试reject方法
MyPromise.reject('reject reason').catch(reason => {
    console.log('reject catch:', reason);
});

// 测试resolve方法
MyPromise.resolve('resolved value').then(value => {
    console.log('resolve success:', value);
});
```





