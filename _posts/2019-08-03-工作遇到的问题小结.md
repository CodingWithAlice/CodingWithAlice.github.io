---
layout:     post
title:      工作遇到的问题小结
subtitle:  
date:       2019-08-03
author:     
header-img: 
catalog: true
tags:
    - < 微信小程序的学习 >
typora-root-url: ..
---

# 工作遇到的问题小结（实习）

## vue element UI 组件相关问题

### 1.`el-upload` 导入excel

`element UI`组件，进行upload上传excel导入功能的时候，`on-success`/`before-upload`等钩子函数，要写在实例对象的`methods`中，才能够正常调用，否则会报`undefined in render` 的错。

### 2.`el-tree` 树形控件

`ElementUI Tree` 树形控件` https://blog.csdn.net/qq_42255106/article/details/80753096 ` 写的很细

有关element UI 中树形组件 `el-tree` 实现各个节点多选功能

```html
<!-- 在html中写的标签结构 -->
<el-tree
    :data="groupTreeData"
    show-checkbox
    ref="DeviceGroupTree"
    node-key="id"
    check-strictly
    @check="checkGroupNode">
</el-tree>
```

其中每一项的配置解析如下：

```javascript
/*	:data树形结构的数据
	show-checkbox 显示复选框
	ref的绑定 可以实现this.$refs.DeviceGroupTree拿到此控件
	node-key 给节点的编号【树形数据结构中有id字段】
	check-stricty 父、子节点之间没有关联【不写这个，选了父节点会默认选择全部的子节点】
	@check 复选框选择、取消选择时触发的事件 */
```

在JS中写的代码：

```javascript
// 在script标签中写方法
checkGroupNode: function (a, b) {
    if (b.checkedKeys.length > 0) {
     this.$refs.DeviceGroupTree.setCheckedKeys([a.id]);
    }
}
```

### 3.`el-input` 文字提醒

在做输入文字提醒的时候，可以使用三级列表形式提醒，使用的是`element`中的`el-input` 和`el-tree` ，如果想要直接以数据形式提醒的话，可以使用element当中的`el-autocomplete`。

### 4. element UI版本更新

在使用`element`文档内提供的组件的时候，如果使用之后发现有些功能无效，注意检查`element UI`的版本，可能是更新的属性。

更新升级element UI的版本方法：

```javascript
// 接下来的代码都在终端中输入
 npm view element-ui versions // 查看可升级到的element UI的版本
 npm update element-ui //然后更新到最新的版本，如果要指定版本，就接@版本号
 npm run serve // 启动项目，这里启动用serve还是dev自行确认下
```

### 5. `el-cascader` 三级级联组件

想要获取点击的内容时，可用` v-model="value"`来绑定，同时绑定事件`@change="handleChange"` 这样就可以在`methods`里面定义`handleChange`这个方法，同时传入value参数，进行数据处理。代码如下：

```javascript
// value 参数是标签中绑定的value值，作为参数传入
// 这里是为了实现多级级联多选时候，选中的节点，只取最后一项内容保存在school中
handleChange(value) {      
    for (let item of value) {       
        this.three.push(item[item.length - 1]);             
    }  
}
```

① 在级联中，options用于绑定数据，记得在标签里面**写的时候要加冒号**：；

②`:props`绑定后，可以传入对象，重置value（id） label（name） 和children（arrayData）的变量名

```javascript
data:{
	defaultprops:{
        value:"id",
        label:"name",
        children:"arrayData"
    }
}
```

### 6. `el-table` 表格

在`el-table`中，`scope.row`表示的是**一行的数据**，如果我想要输出一个数组中的每一个对象的值，如下，可以直接使用`{{scope.row.title}}`插槽即可。

```json
"items":[
    {
        "id":"2000001",
        "school":"浙江大学",
        "title":"前端开发",
        "contnt":"HTML+CSS+JavaScript",
        "detail":"计算机基础",
        "adress":"VScode",
        "likes":0,
        "views":45,
        "start":null,
        "schoolsNames":[
        	{
        		"id":"3000001",
        		"name":"华南理工",
        		"sort":2,
        		"likes":2,
        		"views":4,
        		"child":0,
        		"friends":9
    		},{},{}
        ]
    },{}
]
```

若对象中有数组，数组中以对象形式罗列，如上`person`数组，那么若要循环输出数组中的键值对，那么就要在这一行建立`template`，设置`slot-scope=“scope”`，在template里写个div,span都可以，用来承载`v-for`语句。

```html
<el-table-column prop="schoolsNames" label="学校"  show-overflow-tooltip > 
    <template scope="scope">  
        <span v-for="schoolsName in scope.row.schoolsNames" :key="schoolsName.id"> 								<span>{{ schoolsName.name }}</span >  
		</span>  
	</template> 
</el-table-column>
```

### 7.`el-menu ` 左侧导航

 1.要实现路由跳转，**先要在el-menu标签上添加router属性**，然后只要在每个**el-menu-item标签内的index属性**设置一下`url`即可实现点击el-menu-item实现路由跳转。

2.导航当前项设置：在el-menu标签中绑定 ` :default-active="$route.path"`,注意是绑定属性，不要忘了加`“:”`,当`$route.path`等于el-menu-item标签中的index属性值时则该item为当前项。

```html
        <el-menu 
                 router 
                 :default-active="$route.path" 
                 @open="handleOpen"
                 @close="handleClose" >
            <el-submenu index="1">
                <template slot="title">
                    <i class="el-icon-location"></i>
                    <span>信息</span>
                </template>
                <el-menu-item-group>
                    <el-menu-item index="/user/account">账号</el-menu-item>
                    <el-menu-item index="/user/password">密码</el-menu-item>
            </el-submenu>
            <el-submenu index="2">
                <template slot="title">
                    <i class="el-icon-location"></i>
                    <span>信息</span>
                </template>
                <el-menu-item-group>
                    <el-menu-item index="/company/manager">管理</el-menu-item>
                    <el-menu-item index="/company/edit">添加</el-menu-item>
                </el-menu-item-group>
            </el-submenu>
        </el-menu>
```

### 8. `el-form` 发布框必填/验证

①流程：在对发布框进行必填操作时，**先在 el-form 标签中 ，绑定rules**；然后在各个el-form-item标签中，**写prop属性，来匹配rules**；最后**在data中定义rules对应的验证**；

在rules中定义一个可以**验证 输入内容是否是数字的输入框**：

 ②其中一定要注意`v-model.number`绑定值的时候，绑定了number

```html
<el-form-item            
              label="积分"            
              prop="productPrice"            
              :step="1"            
              step-strictly            
              class="product_price">            
    <el-input 
              placeholder="请输入积分" 
              type="productPrice" 
              v-model.number="activityForm.productPrice" ><!--注意这里的v-model-->        
        <template slot="append">积分</template>            
    </el-input>          
</el-form-item>
```

```javascript
//  rules里面填写
productPrice: [          
    { type: 'number', message: "必须为数字值", trigger: "blur" },          
    { required: true, message: "请输入积分", trigger: "blur" }        
],  
```

③在验证的时候，**一定要把prop绑定的类别放置在父级**。如果跨开一级，就会一直失败

```html
<el-form-item label="类别" >              
    <el-select  
               prop="type" 
               v-model="Type" >                
        <el-option                  
                   v-for="item in List"                  
                   v-model="item.Name"                  
                   :key="item.Id">
        </el-option>              
    </el-select>            
</el-form-item>
```



## 遇到的报错总结

### 1. 页面显示没有数据

页面显示没有数据的时候（三级联动），注意去mounted里面看一下，获取数据的方法如`getAddress()；`有没有执行，是否将数据渲染到了页面；

### 2.404 状态码

第一次：接口返回**404状态码**的时候，确认自己的**运行环境**，在测试环境运行调用接口的时候，需要后端把接口部署到测试服务器上，否则就会接口报错。

这是第二次报错404，新增接口类别后，一定要记得去**`vue.config.js`里面添加`context`** 

```javascript
 module.exports = {    
     devServer: {    
         port: 8888,    
         open: true,    
         proxy: (() => {            
             let context = ['/credit'];            
             let obj = {};            
             context.forEach(item => {                
                 obj[item] = {                                  
                     // 电脑本地                    
                     target: 'http://10.200.144.130:12600/'                               
                 };  });            
             return obj;        
         })()    } }        
```

### 3.报错`TypeError: Object(...) is not a function`

`vue`报错`TypeError: Object(...) is not a function` 从几个方面入手 

1.确认方法命名**是否重名** 

2.**确认`import`的时候没有问题**（我这次是import from的地址不对导致的）

3.`mounted`里面调用的时候测试一下是否有问题

4.`import {sth} from ‘@/api/index’ `中，如果**没有加{}**，也会报错Object（...）is not  a function



### 4.报400错误

在报400错误的时候，同时发现传递的值和接口所需的值的类型是一一对应的，这个时候要确认，我遇到的问题就是**接口所需的URL是有传递的id和类型**的，但是我定义`api`的时候用的`formData`，还试了`json`格式的`params:params` ，这个时候要在定义`api`的时候写上URL的跳转方式：

![1566114641130](/img/assets_2019/1566114641130.png)

```javascript
// 修改 
export const update = (id,num) => {    
    return new Promise(resolve => {        
      SWXHR.put('/credit/update?Id='+id+'&Change='+num,{}) 
            .then(res => {                
            	resolve(res);            
        });    
    })};
```



## 接口/参数遇到的问题

### 1.接口参数（必传/选传/键值对/值）

在调用接口的时候，注意传参和接收参数的形式要一致

```javascript
//这是声明调用接口的方法，传递的参数是params，参数的形式是键值对形式
export const getTree = (params) => {
	return new Promise(resolve => {
        SWXHR.get('/school', {   //这里写接口地址 
                params: params
            })
            .then(res => {
               resolve(res);
          });
    });
};
```

在接收参数的时候，直接在方法中异步调用，同时要记得在mount里面调用`this.getSchool();`执行函数，方便页面初次加载的时候有数据

```javascript
async getSchool() {
      let res = await getTree();
      if (res.code === "success") {
        	this.data = res.data;
      }
    }
```

当传递的参数**可选**时，接口处的参数形式应该写为`{params}`，这样在实例组件调用的时候以该参数的属性传递/键值对的形式传递   

```javascript
export const getInfo = (params) => {    
	return new Promise(resolve => {        
		SWXHR.get('/member', {params})
            .then(res => {
            	resolve(res);
        	});    
    });
};
```

```javascript
 async getInfoList() {      
     let params = {        
         Num: this.page,        
         Size: this.Size,        
         Id: this.Id,        
         Type: this.Type      };      
     if (this.name) {        
         if (/^[0-9]*$/.test(this.name) === true) {          
             params.telephone = this.name;        
         }else if(/^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/g.test(this.name)   
             params.email = this.name;        
         } else {          
             params.name = this.name;        
         }      
     }      
     if (this.school) {        
         params.school = this.school;      
     }      
     let res = await getInfo(params);      
     if (res.code === "success") {        
         this.data = res.data.items;             
         this.total = Number(res.data.total);      
     }    
 },
```

### 2.Chrome开发者调试工具中查看接口传递的参数

在接口调用参数的时候，一般以键值对的形式调用，可以**在`F12`的`Network`里面，点击`XHR`查询参数传递了什么**，根据传递的参数判断是否传递了正确参数。



## 动态生成二维码问题

### 1. 动态生成二维码

先在终端中安装

```css
npm install qrcodejs2
```

然后在要生成二维码的页面中调用

```javascript
import QRCode from 'qrcodejs2'
```

然后在要展示二维码的结构处，为结构添加class属性

```html
<div class="qrcode" ref="qrCodeUrl"></div>
```

然后在`script`标签中添加方法

```javascript
creatQrCode() { // 创建一个实例对象
	var  qrcode = new QRCode(this.$refs.qrCodeUrl, {
	text: 'https://www.qtshe.com',
	width: 100,height: 100,colorDark: '#000000',colorLight: '#ffffff',     
	correctLevel: QRCode.CorrectLevel.H 
    })
},  
```

到此为止，二维码的功能代码已经写完，但是最后一个方法是需要调用的，否则就没有效果。

如果是在页面点击进来就要显示的话，就去`mounted(){}`钩子里面调用一下`this.creatQrCode();`，

如果是点击某个按钮等触发事件出现二维码的，只要在触发事件中绑定该方法即可。

### 2.在二级弹窗中显示二维码

①如果使用对话框显示二维码，有时会由于`html`元素还没有创建，导致生成二维码时报对象不存在或者`appenchild`方法未定义的错误。这时可以**使用`nextTick`来处理**。

```javascript
showQRCode(){      
    this.$nextTick(()=>{/* 使用了nextTick之后，会在生成DOM元素之后绑定*/  
        var qrcode = new QRCode(this.$refs.qrcodeContainer, {              
            text: 'https://wallimn.iteye.com',              
            width: 100,              
            height: 100,              
            colorDark: '#000000',              
            colorLight: '#ffffff',              
            correctLevel: QRCode.CorrectLevel.H          
        })      }  }  
```

②定义完方法后，**只在点击出现对话框的时候，调用`showQRCode`的方法**即可；可以不用在mounted里面进行调用。

③多次**点击会出现多个二维码**，这个时候要设置`this.$refs.qrCodeUrl.innerHTML='';`，保证每一次点击重新生成二维码之前，都已经将之前的清除了；

④在跳转前的页面 设置的地址如下` text:"'/qrcode/' + id " `, 到了跳转到的页面，可以通过**`this.$route.params.id `获取到`url`中的id值**



## 路由相关配置

### 1.配置路由地址

在`router.js`文件中配置路由地址的时候，使用的是`vue-router`，只要写在`home`下面的，都可以通用`header`和`footer`，如果有页面不想要的话，就要把路由地址**放到外面去**。

```javascript
//`router.js`文件中
import Vue from "vue";
import Router from "vue-router";
Vue.use(Router);
export default new Router({  
    routes: [{      
        path: "/",      
        name: "home",      
        component: () => import('@/pages/homes/homeIndex/index.vue'),      
        redirect: {        
        	name: 'list'      
    	},      
         children: [{          
             path: "/list",          
             name: "list",          
             component: () => import('@/pages/homes/list/index.vue'),        
		},...
        //下面都是按照list的配置进行路由配置
```

如果需要验证登陆后才可以点击查看页面的话，增加一个判断条件：

```javascript
{          
    path: "/home",          
    name: "home",          
    meta: {            
          isAuth: true          
    },          
    component: () => import('@/pages/homes/home/index.vue'),        
},
```

### 2. `Vue2.0`中$router 和 $route的区别

 ①.router是`VueRouter`的一个对象，通过`Vue.use(VueRouter)`和`VueRouter`构造函数得到一个router的实例对象，这个对象中是一个**全局的对象**，他**包含了所有的路由包含了许多关键的对象和属性**。**$router**对象是全局路由的实例，是router构造方法的实例。`$router.push({path:'home'});`本质是向history栈中添加一个路由，在我们看来是 切换路由，但本质是在添加一个history记录。

路由实例方法：

replace方法 `$router.replace({path:'home'});`//替换路由，没有历史记录，一般使用replace来做404页面 `this.$router.replace('/')`。

还有push方法 ，push方法其实和`<router-link :to="...">`是等同的。注意：push方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。

还有go方法，`this.$router.go(-1) `// 后退         

②.route是一个跳转的路由对象，每一个路由都会有一个route对象，是一个**局部的对象**，可以获取对应的`name,path,params,query`等
我们可以从`vue devtools`中看到每个路由对象的不同。

`$route.path `字符串，等于当前路由对象的路径，会被解析为**绝对路径**，如 "/home/news" 。`$route.params `对象，包含路由中的动态片段和全匹配片段的**键值对**。

`$route.query `对象，包含路由中查询参数的键值对。例如，对于` /home/news/detail/01?favorite=yes `，会得到`$route.query.favorite == 'yes'` 。

`$route.router` 路由规则所属的路由器（以及其所属的组件）。

`$route.matched `数组，包含当前匹配的路径中所包含的所有片段所对应的**配置参数对象**。`$route.name` 当前路径的名字，如果没有使用具名路径，则名字为空。

### 3.在`router.js`中配置相同页面不同id的地址

在`router.js`配置地址的时候，想要配置一个**不同id显示相同类别的页面**，

```javascript
// 这是正常页面跳转配置
{          
    path: "/Detail",          
    name: "Detail",          
    component: () => import('@/pages/Detail/index.vue'),        
},   
                
//这是带有id传值的配置   
{          
    path: "/Detail/:id",   /*注意这里，加了一个/：id*/         
    name: "Detail",          
    component: () => import('@/pages/Detail/index.vue'),        
},
```



## 基础知识补档

### 1. async...await

async作为一个关键词放在函数前面，表示异步执行，该函数的执行不阻塞后面代码的执行；await表示等待await后面的函数执行完毕，并且有了返回结果之后，才能继续执行下面的代码

### 2.前端代码打包上传测试服务器

打包上传服务器的时候，**先`npm run build `在终端对文件进行打包**，然后将打包好的` dist `文件夹里的`css js `等文件 通过`WinSCP`软件进行上传，其中这个上传软件需要 主机名 端口 账号 密码

### 3. 关于将`localstorage`改为`sessionstorage`

​	`localStorage`和`sessionStorage`一样都是用来**存储客户端临时信息**的对象。

​	他们均只能存储字符串类型的对象（虽然规范中可以存储其他原生类型的对象，但是目前为止没有浏览器对其进行实现）。

​	`localStorage`生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除`localStorage`信息，否则这些信息将永远存在。`sessionStorage`生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过`sessionStorage`存储的数据也就被清空了。

​	**不同浏览器无法共享**`localStorage`或`sessionStorage`中的信息。相同浏览器的不同页面间可以共享相同的` localStorage`（页面属于相同域名和端口），但是不同页面或标签页间无法共享`sessionStorage`的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个`iframe`标签且他们属于同源页面，那么他们之间是可以共享`sessionStorage`的。

`http://www.test.com
https://www.test.com `（不同源，因为**协议不同**）
`http://my.test.com`（不同源，因为**主机名不同**）
`http://www.test.com:8080`（不同源，因为**端口不同**）
`localStorage`和`sessionStorage`使用时**使用相同的`API`**：

`localStorage`和`sessionStorage`都继承于`Storage`，提供了统一的`api`来访问和设置数据。

​	

|   API列表    |                                                          | 举例说明                                                     |
| :----------: | :------------------------------------------------------: | ------------------------------------------------------------ |
|    clear     |               清空存储中的所有本地存储数据               | `localStorage.clear();`                                      |
|  `getItem`   |          接受一个参数key，获取对应key的本地存储          | `localStorage.getItem('order');`<br/>// 对象访问方式同样有效<br/>`localStorage.order = 'b110';`<br/>`localStorage.order; `// b110 |
|     key      |       接受一个整数索引，返回对应本地存储中索引的键       | `localStorage.key(0);`                                       |
| `removeItem` |          接受一个参数key，删除对应本地存储的key          | `localStorage.removeItem('order')；`                         |
|  `setItem`   | 接受两个参数，key和value，如果不存在则添加，存在则更新。 | `localStorage.setItem('order', 'a109');`                     |

`localStorage.setItem("key","value");`//以“key”为名称**存储一个值**“value”
`localStorage.getItem("key");`//**获取**名称为“key”的值
**枚举**`localStorage`的方法：

```javascript
for(var i=0; i < localStorage.length;i++){
     var name = localStorage.key(i);
     var value = localStorage.getItem(name);
}
```

**删除**`localStorage`中存储信息的方法：
`localStorage.removeItem("key");`//删除名称为“key”的信息。
`localStorage.clear();`//清空`localStorage`中所有信息
 通过`getItem`或直接使用`localStorage["key"]`获取到的信息均为**实际存储的副本**。

```javascript
localStorage.key = {value1:"value1"};
localStorage.key.value1='a';
//这里是无法对实际存储的值产生作用的，下面的写法也不可以：
localStorage.getItem("key").value1="a";
```

一篇写的比较详细的文章：

`http://www.111cn.net/wy/html5/85886.htm`

### 4.定义在`utils`里面的静态的`storage.js`文件中的方法

```javascript
/** * 设置localStorage * @param {名称} name  * @param {值} value  */
export const setLocalValue = (name, value) => {    
    if (window.localStorage) {        
        localStorage.setItem(name, JSON.stringify(value));    
    } else {        
        alert('7008');    
    }
}
/** * 获取localStorage * @param {*名称} name  */
export const getLocalValue = (name) => {    
    const value = localStorage.getItem(name);    
    if (value) {        
        return JSON.parse(value)    
    } else {        
        return ''    
    }
}
/** * 设置cookie * @param {cookie名称} name  * @param {*cookie值} value  * @param {*过期时间（分钟）} time  */
export const setCookie = (name, value, time) => {    
    let d = new Date()    
    d.setTime(d.getTime() + (time * 60 * 1000));    
    document.cookie = name + '=' + JSON.stringify(value) + ';path=/;expires=' + d.toGMTString();
}
/** * 获取cookie * @param {*cookie名称} names  */
export const getCookie = (names) => {    
    let name = names + "=";    
    let cookies = document.cookie.split(';');    
    for (let i = 0; i < cookies.length; i++) {        
        let cookie = cookies[i];        
        while (cookie.charAt(0) === ' ') cookie = cookie.substring(1);        
        if (cookie.indexOf(name) !== -1) {            
            let cookied = cookie.substring(name.length, cookie.length);            
            return JSON.parse(cookied)        
        }    
    }    
    return "";
}
```

### 5.`a`标签中的`href`写法

在写a标签中 的`href`的链接的时候，要**拼接字符串**的话，

```javascript
:href= "'/activity/Members?activityId=' + Id"
```

1.`href`前面要**加冒号**，

2.字符串用**单引号**‘/activity/Members?activityId=’包裹，`href`的链接用**双引号**包裹“”，否则会报错

3.尾部记得别忘记加` .html`

### 6.`img`中的`src`的写法

需要对图片image的`src`地址进行**动态绑定的时候**，记得要在`src`前面加：即v-on进行绑定 

```javascript
< img                
:src="imgSrc"                
style="padding-left:20px;vertical-align: middle"               @click="addLikes(item.id,item.likes)"              
/>   
```

然后`imgSrc`的值就可以**在data中定义**，在点击的方法中定义 

直接写`imgSrc:'./../../../assets/images/喜欢.png'  `会一直找不到image的路径  要写成`imgSrc:require("@/assets/images/喜欢.png") `**将图片作为模块加载进去**；

或者，将图片放到static目录下，但必须写成绝对路径如`images:[{src:”/static/1.png”},{src:”/static/2.png”}]`这样图片也会显示出来，当然你也可以通过在`webpack.base.config.js`定义来缩短路径的书写长度。

### 7.显示一行文本/多行文本+省略号

```javascript
//一行文本省略 
white-space: nowrap;
text-overflow: ellipsis;
overflow: hidden;
word-break: 
break-all;
//多行文本省略(ps：此处是两行)
text-overflow: -o-ellipsis-lastline;
overflow: hidden;
text-overflow: ellipsis;
display: -webkit-box;
-webkit-line-clamp: 2;
line-clamp: 2;
-webkit-box-orient: vertical;
word-break: break-all;
```

### 8.获取本地登陆的id等信息的方法

```javascript
//方法1：   
let loginInfo = JSON.parse(localStorage.getItem("loginInfo")); 
//方法2：         
let loginInfo = this.getLocalValue("loginInfo");
```

### 9.`this.$message.success("签到成功"); `弹出签到成功



## 其他经验积累

### 1. 在线json校验工具

后端接口调试返回数据的简便使用，非常好用，使用新版`http://www.bejson.com/`

### 2.测试环境中， 记得按disable cache ，可以不留缓存



## 第四周 实习经验分享

### 1.间隙问题

①上下间隙

​	有关块级元素包裹块级元素，在下方出现的间隙（div包裹div，div包裹img）都是块级包块级常见的情况，导致这个的原因：内联元素的默认垂直**对齐方式是和基线对齐**（vertical-align：baseline），并不是和底部对齐，以及**父级元素默认的行高**问题。

暴力解决：

​	**1.浮动**（可能导致父元素塌陷的问题，注意父级元素清除浮动）

​	**2.转化为块级元素**　

​	**3.定位**（使用定位时脱离文档流，注意父元素塌陷，定位完全脱离父元素，清除浮动没用）　

本质解决：

​	**1.修改父级元素行高**：line-height:0；

​	**2.修改父级元素字体大小**：font-size:0;　

​	**3.修改内联元素对齐方式**：vertical-align：根据需求可以改为middle、top、bottom、text-bottom等值（这种方式解决空隙问题比较好）；     

②左右间隙

​	有关多张图片连着排列的**（左右）间隙问题**：（浏览器把两个img标签之间的空格当成了空白节点）

**1.多个img标签写在一行**

**2.在img标签的父级上写：font-size:0;**

**3.给每一项添加display：block** 

**4.使用letter-spacing属性**，设置字符间距，在父级上面设置`style="letter-spacing:-800px"`**（letter-spacing的值无论是负多少都不会产生重叠）**



### 2.`el-form`表单提交及表单数据重置

```html
  <el-form :model="dataForm" :inline="true" :rules="rules" label-position="left">
        <el-form-item label="名称" prop="name">
            <el-input v-model="dataForm.name"></el-input>
        </el-form-item>
        <el-form-item label="价格" prop="price">
            <el-input v-model="dataForm.price"></el-input>
        </el-form-item>
        <el-form-item label="数量" prop="num">
            <el-input v-model="dataForm.num"></el-input>
        </el-form-item>
        <el-form-item label="日期" prop="date">
            <el-input v-model="dataForm.date"></el-input>
        </el-form-item>
        <el-button @click="Submit('dataForm')">提 交</el-button>
        <el-button @click="giveSubmit('dataForm')">取 消</el-button>
   </el-form>
```

表单提交的时候，如果点击取消，就需要把内部的数据重置，**流程**：

1.先在`el-form`标签中，用`：model=“dataForm” `将所有的填写的内容保存在里面，

2.然后在取消按钮上面绑定相应的取消方法 ：`<el-button @click="giveSubmit('dataForm')">取 消</el-button> ` ，同时将`dataForm`这个存储值的对象传入，

3.最后在方法中定义： 利用`resetFields();`重置这个里面的数据

```javascript
giveSubmit(formName) {      
    this.productDialog = false;   
    this.$refs[formName].resetFields();    
}, 
```



### 3.el-table 批量删除方法

```javascript
	delLists() {
            var ids = this.$refs.multipleTable.selection;
            var checks = [];
            if (ids.length === 0) {
                this.$message.warning("请选择");
                return false;
            } else {
                for (let i in ids) {
                    checks.push(ids[i].id);
                }
                var checkIds = checks.join("%");
            }
            this.$confirm("此操作将永久删除项数据, 是否继续?", "提示", {
                    confirmButtonText: "确定",
                    cancelButtonText: "取消",
                    type: "warning"
                })
                .then(() => {
                /*getDel是一个接收checkIds参数来删除的接口*/
                    getDel(checkIds).then(res => {
                        if (res.code === "success") {
                            this.$message({
                                type: "success",
                                activity: "删除成功!"
                            });
                            /*删除之后，重新获取table展示的数据，对当前页面进行刷新*/
                            this.getList();
                        }
                    });
                })
                .catch(() => {
                    this.$message({
                        type: "info",
                        activity: "已取消删除"
                    });
                });
        }
```

### 4.过滤器filter

#### ①先简单了解一下过滤方法：

`array.filter(function(currentValue,index,arr), thisValue)`  

filter() 方法**创建一个新的数组**，新数组中的元素是通过检查指定数组中**符合条件的所有元素**，如果没有符合条件的元素则返回空数组；**不会对空数组进行检测**；不会改变原始数组。

参数：**当前元素的值**`currentValue`必须；当前元素的**索引值**`index` 可选；当前元素属于的数组对象 `arr` 可选；

 thisValue  可选，表示对象作为该执行回调时使用，传递给函数，**用作 "this" 的值**。如果省略了 thisValue ，"this" 的值为 "undefined"  。      

```javascript
/*我使用到的场景*/
res.data.items.filter(value=>{          
    return value.isTrue===1        
})
```

#### ②过滤器可在new Vue实例前注册全局的，也可以在组件上写局部过滤器。

1.**全局过滤器**：

```javascript
/*过滤器名称global-Filter*/
Vue.filter('globa-lFilter', function (value) {return value + "000"})
```

2.**组件过滤器（局部）**：

```javascript
filters:{
    componentFilter:function(value){ return value + "111" }
},
```

**注意**：全局注册时是`filter`，没有s的。而组件过滤器是`filters`，是有s的，否则过滤器是没有效果的。
3.在**计算属性中过滤**：

```html
<li v-for="item in filterlist">{{item}}</li> 
```

```javascript
/*list是定义的一个数组*/ 
computed: {      
     filterlist () {           
         return this.list.filter(function (number) {
                    return number< 4                
         })            
     }     
 },
```

4.在**`methods`**里面的使用

```html
<li v-for="item in filterlistFun()">{{item}}</li>
```

```javascript
/*list是定义的一个数组*/  		
methods:{
    filterlistFun(val){
         return this.list.filter(function (number) {
               return number < 4
         })
    }
}
```

#### ③过滤器的使用方法

1.在双花括号插值` {{ 'ok' | globalFilter }} ` 
2.在`v-bind`表达式中使用 `<div v-bind:data="'ok' | globalFilter" ></div>`

#### ④过滤器的参数写法

1.**{{ message | filterA | filterB }}**  message是作为参数传给filterA 函数，而filterA 函数的返回值作为参数传给filterB函数，**最终结果显示是由filterB返回的**。调用的时候，只有一个参数。
2.**{{ message | filterA('arg1', arg2) }}** filterA的第一个参数是message，然后接下来的参数依次是‘arg1’,arg2。调用的时候，有三个参数。
3.**{{ 'a','b' | filterB }}** 'a'和'b'分别作为参数传给filterB。

过滤器函数始终以表达式的值作为第一个参数。带引号的参数视为字符串，而**不带引号的参数按表达式计算** ；

可以设置两个过滤器参数，前提是这**两个过滤器处理的不冲突**；



### 5.el-table 的格式化属性

用户从input输入的数据在回传到model之前也可以先处理；

```html
<el-table-column 
                 label="状态" 
                 align="center" 
                 :formatter="switchCode" 
                 show-overflow-tooltip></el-table-column>
```

 在表格中 有一个`formatter`用来格式化内容 `Function(row, column, cellValue, index) `
**使用流程：**

1.先在列中定义方法，给它一个方法名，它会自动获取参数；

2.然后再methods里面定义该方法，并传入默认的参数，这里传两个参数，row参数获取了本行的数组

```javascript
// 订单状态    
			switchCode(row, column) {
                    let Status = "";
                    switch (row.orderStatus) {
                        case 1:
                            Status = "已付款";
                            break;
                        case 2:
                            Status = "已发货";
                            break;
                        case 3:
                            Status = "已签收";
                            break;
                        case 4:
                            Status = "取消交易";
                            break;
                    }
                    return Status;
                }
```

**注意**：过程中，我将需要返回的Status变量，一开始定义在data中，导致无限循环报错，将要返回的变量局部定义在该函数中即可避免；

### 6.移动端轮播图抖动问题

```css
overflow：hidden;
width：100%;
height：0;
padding-bottom：31.25%;
```

`padding-bottom：31.25%;`表示**高度根据宽度相对撑开31.25%**，保证图片的宽高比。
**注意**：不能将height设置成31.25%，因为height是相对于父级的百分比。
或者可以写成另一种形式：

```css
/*高度相对于viewport的宽度；但是可能有兼容性问题*/
width：100%;
height：31.25vm;
```

### 7.模板字面量

1.在模板字面量（反引号）之内的所有空白符都是字符串的一部分，因此需要**特别留意缩进**。　　　
2.在模板字面量中**使用 \n 来指示换行**的插入位置。
3.模板字面量看上去仅仅是普通JS字符串的升级版，但二者之间**真正的区别**在于模板字面量的**变量占位符**。

**变量占位符允许将任何有效的JS表达式嵌入到模板字面量中，并将其结果输出为字符串的一部分。**
变量占位符由起始的` ${` 与结束的` } `来界定，之间允许放入任意的 JS 表达式。

```javascript
/*之前定义了count=10;price=2.5;*/
`${count} items cost $${(count * price).toFixed(2)}.`//"10 items cost $2.50."
```

模板字面量本身也是 JS 表达式，因此**可以将模板字面量嵌入到另一个模板字面量内部** 

```javascript
`Hello, ${my name is ${ name }}.`
```

4.模板字面量真正的威力来自于**标签模板**，每个模板标签都可以执行模板字面量上的转换并**返回最终的字符串值**。标签指的是在模板字面量**第一个反引号前方标注的字符串**。

```javascript
`let message = tag`Hello world`;` 
```

```javascript
function tag(literals, ...substitutions) {  /*返回一个字符串*/ }
```

标签可以是一个函数，调用时传入加工过的模板字面量各部分数据，但必须结合每个部分来创建结果。

**第一个参数是一个数组**，包含Javascript解释过后的字面量字符串，它之后的所有参数都是每一个占位符的解释值。标签函数通常使用不定参数特性来定义占位符，从而简化数据处理的过程。

实例解释：

```javascript
let count = 10,price = 0.25;
let message = passthru`${count} items cost $${(count * price).toFixed(2)}.`;
```

如果有一个名为`passthru()`的函数，那么作为一个模板字面量标签，它会接受**3个参数**：
首先是**第一个参数**是`literals`数组，包含以下元素：　　

​	1、第一个占位符前的空字符串("")　　

​	2、第一、二个占位符之间的字符串(" items cost $")　　

​	3、第二个占位符后的字符串(".")；

**下一个参数**是变量`count`的解释值，传参为10，它也成为了substitutions数组里的第一个元素；

**最后一个参数**是`(count*price).toFixed(2)`的解释值，传参为2.50，它是substitutions数组里的第二个元素。

**注意**：literals里的第一个元素是一个空字符串，这确保了literals[0]总是字符串的始端，就像literals[literals.length-1]总是字符串的结尾一样。substitutions的数量总比literals少一个，这也意味着表达式substitutions.Iength === literals.Iength-1的结果总为true。

### 8.防抖、节流

防抖、节流` https://segmentfault.com/a/1190000016261602 `这个写的很好，平时键盘抬起就会搜索，防抖后，间隔一段时间不输入才会搜索，节流后，可以做到不管是否停止打字，间隔一段时间都会搜索。

**函数防抖**(debounce)：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

```javascript
/模拟一段ajax请求,只要按下键盘，就会触发这次ajax请求。
/* ajax函数用来输出传入的参数*/
function ajax(content) {
  console.log('ajax request ' + content)
}
/* 通过id值获取到DOM标签*/
let inputa = document.getElementById('unDebounce')

inputa.addEventListener('keyup', function (e) {
    ajax(e.target.value)
})
```

优化后：

```javascript
/ 延迟执行ajax请求后，当你在频繁的输入时，并不会发送请求，只有当你在指定间隔内没有输入时，才会执行函数/
/* ajax函数用来输出传入的参数*/
function ajax(content) {
  console.log('ajax request ' + content)
}
/这里定义一个debounce函数，将传入的函数延迟5秒执行，如果间隔小于5秒，就会重新计时/
function debounce(fun, delay) {
    return function (args) {
        let that = this
        let _args = args
        clearTimeout(fun.id)
        fun.id = setTimeout(function () {
            fun.call(that, _args)
        }, delay)
    }
}
/* 通过id值获取到DOM标签*/    
let inputb = document.getElementById('debounce');
/这是个函数，是debounce返回的函数/
let debounceAjax = debounce(ajax, 500)
/* 添加监听键盘抬起事件，每次弹起就执行后面的回调函数，即将输入内容传值给debounceAjax函数延迟执行ajax*/
inputb.addEventListener('keyup', function (e) {
        debounceAjax(e.target.value)
})
```

函数节流：如果在延迟的时间间隔内执行函数，会重新触发计时。