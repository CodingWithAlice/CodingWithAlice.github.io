---
`layout:     post
title:      工作遇到的问题小结
subtitle:  
date:       2019-08-03
author:     
header-img: 
catalog: true
tags:
    - < 工作遇到的问题记录 >
typora-root-url: ..
---

# 工作遇到的问题小结

## 遇到的报错总结

### 1. 页面显示没有数据

页面显示没有数据的时候（三级联动），注意去mounted里面看一下，获取数据的方法如`getAddress()；`有没有执行，是否将数据渲染到了页面；

### 2.404 状态码

第一次：接口返回**404状态码**的时候，确认自己的**运行环境**，在测试环境运行调用接口的时候，需要后端把接口部署到测试服务器上，否则就会接口报错。

这是第二次报错404，新增接口类别后，一定要记得去**`vue.config.js`里面添加`context`** 

```javascript
 module.exports = {    
     devServer: {    
         port: 8888,    
         open: true,    
         proxy: (() => {            
             let context = ['/credit'];            
             let obj = {};            
             context.forEach(item => {                
                 obj[item] = {                                  
                     // 电脑本地                    
                     target: 'http://10.200.144.130:12600/'                               
                 };  });            
             return obj;        
         })()    } }        
```

### 3.报错`TypeError: Object(...) is not a function`

`vue`报错`TypeError: Object(...) is not a function` 从几个方面入手 

1.确认方法命名**是否重名** 

2.**确认`import`的时候没有问题**（我这次是import from的地址不对导致的）

3.`mounted`里面调用的时候测试一下是否有问题

4.`import {sth} from ‘@/api/index’ `中，如果**没有加{}**，也会报错Object（...）is not  a function



### 4.报400错误

在报400错误的时候，同时发现传递的值和接口所需的值的类型是一一对应的，这个时候要确认，我遇到的问题就是**接口所需的URL是有传递的id和类型**的，但是我定义`api`的时候用的`formData`，还试了`json`格式的`params:params` ，这个时候要在定义`api`的时候写上URL的跳转方式：

![1566114641130](/img/assets_2019/1566114641130.png)

```javascript
// 修改 
export const update = (id,num) => {    
    return new Promise(resolve => {        
      SWXHR.put('/credit/update?Id='+id+'&Change='+num,{}) 
            .then(res => {                
            	resolve(res);            
        });    
    })};
```



## 接口/参数遇到的问题

### 1.接口参数（必传/选传/键值对/值）

在调用接口的时候，注意传参和接收参数的形式要一致

```javascript
//这是声明调用接口的方法，传递的参数是params，参数的形式是键值对形式
export const getTree = (params) => {
	return new Promise(resolve => {
        SWXHR.get('/school', {   //这里写接口地址 
                params: params
            })
            .then(res => {
               resolve(res);
          });
    });
};
```

在接收参数的时候，直接在方法中异步调用，同时要记得在mount里面调用`this.getSchool();`执行函数，方便页面初次加载的时候有数据

```javascript
async getSchool() {
      let res = await getTree();
      if (res.code === "success") {
        	this.data = res.data;
      }
    }
```

当传递的参数**可选**时，接口处的参数形式应该写为`{params}`，这样在实例组件调用的时候以该参数的属性传递/键值对的形式传递   

```javascript
export const getInfo = (params) => {    
	return new Promise(resolve => {        
		SWXHR.get('/member', {params})
            .then(res => {
            	resolve(res);
        	});    
    });
};
```

```javascript
 async getInfoList() {      
     let params = {        
         Num: this.page,        
         Size: this.Size,        
         Id: this.Id,        
         Type: this.Type      };      
     if (this.name) {        
         if (/^[0-9]*$/.test(this.name) === true) {          
             params.telephone = this.name;        
         }else if(/^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/g.test(this.name)   
             params.email = this.name;        
         } else {          
             params.name = this.name;        
         }      
     }      
     if (this.school) {        
         params.school = this.school;      
     }      
     let res = await getInfo(params);      
     if (res.code === "success") {        
         this.data = res.data.items;             
         this.total = Number(res.data.total);      
     }    
 },
```

### 2.Chrome开发者调试工具中查看接口传递的参数

在接口调用参数的时候，一般以键值对的形式调用，可以**在`F12`的`Network`里面，点击`XHR`查询参数传递了什么**，根据传递的参数判断是否传递了正确参数。







## 基础知识补档

### 1. async...await

async作为一个关键词放在函数前面，表示异步执行，该函数的执行不阻塞后面代码的执行；await表示等待await后面的函数执行完毕，并且有了返回结果之后，才能继续执行下面的代码

### 2.前端代码打包上传测试服务器

打包上传服务器的时候，**先`npm run build `在终端对文件进行打包**，然后将打包好的` dist `文件夹里的`css js `等文件 通过`WinSCP`软件进行上传，其中这个上传软件需要 主机名 端口 账号 密码

### 3. 关于将`localstorage`改为`sessionstorage`

​	`localStorage`和`sessionStorage`一样都是用来**存储客户端临时信息**的对象。

​	他们均只能存储字符串类型的对象（虽然规范中可以存储其他原生类型的对象，但是目前为止没有浏览器对其进行实现）。

​	`localStorage`生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除`localStorage`信息，否则这些信息将永远存在。`sessionStorage`生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过`sessionStorage`存储的数据也就被清空了。

​	**不同浏览器无法共享**`localStorage`或`sessionStorage`中的信息。相同浏览器的不同页面间可以共享相同的` localStorage`（页面属于相同域名和端口），但是不同页面或标签页间无法共享`sessionStorage`的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个`iframe`标签且他们属于同源页面，那么他们之间是可以共享`sessionStorage`的。

`http://www.test.com
https://www.test.com `（不同源，因为**协议不同**）
`http://my.test.com`（不同源，因为**主机名不同**）
`http://www.test.com:8080`（不同源，因为**端口不同**）
`localStorage`和`sessionStorage`使用时**使用相同的`API`**：

`localStorage`和`sessionStorage`都继承于`Storage`，提供了统一的`api`来访问和设置数据。

​	

|   API列表    |                                                          | 举例说明                                                     |
| :----------: | :------------------------------------------------------: | ------------------------------------------------------------ |
|    clear     |               清空存储中的所有本地存储数据               | `localStorage.clear();`                                      |
|  `getItem`   |          接受一个参数key，获取对应key的本地存储          | `localStorage.getItem('order');`<br/>// 对象访问方式同样有效<br/>`localStorage.order = 'b110';`<br/>`localStorage.order; `// b110 |
|     key      |       接受一个整数索引，返回对应本地存储中索引的键       | `localStorage.key(0);`                                       |
| `removeItem` |          接受一个参数key，删除对应本地存储的key          | `localStorage.removeItem('order')；`                         |
|  `setItem`   | 接受两个参数，key和value，如果不存在则添加，存在则更新。 | `localStorage.setItem('order', 'a109');`                     |

`localStorage.setItem("key","value");`//以“key”为名称**存储一个值**“value”
`localStorage.getItem("key");`//**获取**名称为“key”的值
**枚举**`localStorage`的方法：

```javascript
for(var i=0; i < localStorage.length;i++){
     var name = localStorage.key(i);
     var value = localStorage.getItem(name);
}
```

**删除**`localStorage`中存储信息的方法：
`localStorage.removeItem("key");`//删除名称为“key”的信息。
`localStorage.clear();`//清空`localStorage`中所有信息
 通过`getItem`或直接使用`localStorage["key"]`获取到的信息均为**实际存储的副本**。

```javascript
localStorage.key = {value1:"value1"};
localStorage.key.value1='a';
//这里是无法对实际存储的值产生作用的，下面的写法也不可以：
localStorage.getItem("key").value1="a";
```

一篇写的比较详细的文章：

`http://www.111cn.net/wy/html5/85886.htm`

### 4.定义在`utils`里面的静态的`storage.js`文件中的方法

```javascript
/** * 设置localStorage * @param {名称} name  * @param {值} value  */
export const setLocalValue = (name, value) => {    
    if (window.localStorage) {        
        localStorage.setItem(name, JSON.stringify(value));    
    } else {        
        alert('7008');    
    }
}
/** * 获取localStorage * @param {*名称} name  */
export const getLocalValue = (name) => {    
    const value = localStorage.getItem(name);    
    if (value) {        
        return JSON.parse(value)    
    } else {        
        return ''    
    }
}
/** * 设置cookie * @param {cookie名称} name  * @param {*cookie值} value  * @param {*过期时间（分钟）} time  */
export const setCookie = (name, value, time) => {    
    let d = new Date()    
    d.setTime(d.getTime() + (time * 60 * 1000));    
    document.cookie = name + '=' + JSON.stringify(value) + ';path=/;expires=' + d.toGMTString();
}
/** * 获取cookie * @param {*cookie名称} names  */
export const getCookie = (names) => {    
    let name = names + "=";    
    let cookies = document.cookie.split(';');    
    for (let i = 0; i < cookies.length; i++) {        
        let cookie = cookies[i];        
        while (cookie.charAt(0) === ' ') cookie = cookie.substring(1);        
        if (cookie.indexOf(name) !== -1) {            
            let cookied = cookie.substring(name.length, cookie.length);            
            return JSON.parse(cookied)        
        }    
    }    
    return "";
}
```

### 5.`a`标签中的`href`写法

在写a标签中 的`href`的链接的时候，要**拼接字符串**的话，

```javascript
:href= "'/activity/Members?activityId=' + Id"
```

1.`href`前面要**加冒号**，

2.字符串用**单引号**‘/activity/Members?activityId=’包裹，`href`的链接用**双引号**包裹“”，否则会报错

3.尾部记得别忘记加` .html`

### 6.`img`中的`src`的写法

需要对图片image的`src`地址进行**动态绑定的时候**，记得要在`src`前面加：即v-on进行绑定 

```javascript
< img                
:src="imgSrc"                
style="padding-left:20px;vertical-align: middle"               @click="addLikes(item.id,item.likes)"              
/>   
```

然后`imgSrc`的值就可以**在data中定义**，在点击的方法中定义 

直接写`imgSrc:'./../../../assets/images/喜欢.png'  `会一直找不到image的路径  要写成`imgSrc:require("@/assets/images/喜欢.png") `**将图片作为模块加载进去**；

或者，将图片放到static目录下，但必须写成绝对路径如`images:[{src:”/static/1.png”},{src:”/static/2.png”}]`这样图片也会显示出来，当然你也可以通过在`webpack.base.config.js`定义来缩短路径的书写长度。

### 7.显示一行文本/多行文本+省略号

```javascript
//一行文本省略 
white-space: nowrap;
text-overflow: ellipsis;
overflow: hidden;
word-break: 
break-all;
//多行文本省略(ps：此处是两行)
text-overflow: -o-ellipsis-lastline;
overflow: hidden;
text-overflow: ellipsis;
display: -webkit-box;
-webkit-line-clamp: 2;
line-clamp: 2;
-webkit-box-orient: vertical;
word-break: break-all;
```

### 8.获取cookie中本地登陆的id等信息的方法

```javascript
let login =this.getCookie("login");     
if (login) {        
    //获取登陆信息         
    let loginInfo = this.getLocalValue("loginInfo");        
    // 和上面方法一样，反序列化，把字符串改成对象
    let loginInfo =JSON.parse(localStorage.getItem("loginInfo"));        
    //获取成员id         
    let memberId=loginInfo.id;        
    // 调用接口查询是否重复签到        
    console.log(memberId);
```



### 9.`this.$message.success("签到成功"); `弹出签到成功

### 10.间隙问题

①上下间隙

​	有关块级元素包裹块级元素，在下方出现的间隙（div包裹div，div包裹img）都是块级包块级常见的情况，导致这个的原因：内联元素的默认垂直**对齐方式是和基线对齐**（vertical-align：baseline），并不是和底部对齐，以及**父级元素默认的行高**问题。

暴力解决：

​	**1.浮动**（可能导致父元素塌陷的问题，注意父级元素清除浮动）

​	**2.转化为块级元素**　

​	**3.定位**（使用定位时脱离文档流，注意父元素塌陷，定位完全脱离父元素，清除浮动没用）　

本质解决：

​	**1.修改父级元素行高**：line-height:0；

​	**2.修改父级元素字体大小**：font-size:0;　

​	**3.修改内联元素对齐方式**：vertical-align：根据需求可以改为middle、top、bottom、text-bottom等值（这种方式解决空隙问题比较好）；     

②左右间隙

​	有关多张图片连着排列的**（左右）间隙问题**：（浏览器把两个img标签之间的空格当成了空白节点）

**1.多个img标签写在一行**

**2.在img标签的父级上写：font-size:0;**

**3.给每一项添加display：block** 

**4.使用letter-spacing属性**，设置字符间距，在父级上面设置`style="letter-spacing:-800px"`**（letter-spacing的值无论是负多少都不会产生重叠）**

### 11.模板字面量

1.在模板字面量（反引号）之内的所有空白符都是字符串的一部分，因此需要**特别留意缩进**。　　　
2.在模板字面量中**使用 \n 来指示换行**的插入位置。
3.模板字面量看上去仅仅是普通JS字符串的升级版，但二者之间**真正的区别**在于模板字面量的**变量占位符**。

**变量占位符允许将任何有效的JS表达式嵌入到模板字面量中，并将其结果输出为字符串的一部分。**
变量占位符由起始的` ${` 与结束的` } `来界定，之间允许放入任意的 JS 表达式。

```javascript
/*之前定义了count=10;price=2.5;*/
`${count} items cost $${(count * price).toFixed(2)}.`//"10 items cost $2.50."
```

模板字面量本身也是 JS 表达式，因此**可以将模板字面量嵌入到另一个模板字面量内部** 

```javascript
`Hello, ${my name is ${ name }}.`
```

4.模板字面量真正的威力来自于**标签模板**，每个模板标签都可以执行模板字面量上的转换并**返回最终的字符串值**。标签指的是在模板字面量**第一个反引号前方标注的字符串**。

```javascript
`let message = tag`Hello world`;` 
```

```javascript
function tag(literals, ...substitutions) {  /*返回一个字符串*/ }
```

标签可以是一个函数，调用时传入加工过的模板字面量各部分数据，但必须结合每个部分来创建结果。

**第一个参数是一个数组**，包含Javascript解释过后的字面量字符串，它之后的所有参数都是每一个占位符的解释值。标签函数通常使用不定参数特性来定义占位符，从而简化数据处理的过程。

实例解释：

```javascript
let count = 10,price = 0.25;
let message = passthru`${count} items cost $${(count * price).toFixed(2)}.`;
```

如果有一个名为`passthru()`的函数，那么作为一个模板字面量标签，它会接受**3个参数**：
首先是**第一个参数**是`literals`数组，包含以下元素：　　

​	1、第一个占位符前的空字符串("")　　

​	2、第一、二个占位符之间的字符串(" items cost $")　　

​	3、第二个占位符后的字符串(".")；

**下一个参数**是变量`count`的解释值，传参为10，它也成为了substitutions数组里的第一个元素；

**最后一个参数**是`(count*price).toFixed(2)`的解释值，传参为2.50，它是substitutions数组里的第二个元素。

**注意**：literals里的第一个元素是一个空字符串，这确保了literals[0]总是字符串的始端，就像literals[literals.length-1]总是字符串的结尾一样。substitutions的数量总比literals少一个，这也意味着表达式substitutions.Iength === literals.Iength-1的结果总为true。

### 12.防抖、节流

防抖、节流` https://segmentfault.com/a/1190000016261602 `这个写的很好，平时键盘抬起就会搜索，防抖后，间隔一段时间不输入才会搜索，节流后，可以做到不管是否停止打字，间隔一段时间都会搜索。

**函数防抖**(debounce)：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

```javascript
/模拟一段ajax请求,只要按下键盘，就会触发这次ajax请求。
/* ajax函数用来输出传入的参数*/
function ajax(content) {
  console.log('ajax request ' + content)
}
/* 通过id值获取到DOM标签*/
let inputa = document.getElementById('unDebounce')

inputa.addEventListener('keyup', function (e) {
    ajax(e.target.value)
})
```

优化后：

```javascript
/ 延迟执行ajax请求后，当你在频繁的输入时，并不会发送请求，只有当你在指定间隔内没有输入时，才会执行函数/
/* ajax函数用来输出传入的参数*/
function ajax(content) {
  console.log('ajax request ' + content)
}
/这里定义一个debounce函数，将传入的函数延迟5秒执行，如果间隔小于5秒，就会重新计时/
function debounce(fun, delay) {
    return function (args) {
        let that = this
        let _args = args
        clearTimeout(fun.id)
        fun.id = setTimeout(function () {
            fun.call(that, _args)
        }, delay)
    }
}
/* 通过id值获取到DOM标签*/    
let inputb = document.getElementById('debounce');
/这是个函数，是debounce返回的函数/
let debounceAjax = debounce(ajax, 500)
/* 添加监听键盘抬起事件，每次弹起就执行后面的回调函数，即将输入内容传值给debounceAjax函数延迟执行ajax*/
inputb.addEventListener('keyup', function (e) {
        debounceAjax(e.target.value)
})
```

**函数节流**：规定在一个单位时间内，只能触发一次函数。**如果这个单位时间内触发多次函数，只有一次生效。**

```javascript
let biu = function () {
    console.log('biu biu biu',new Date().Format('HH:mm:ss'))
}
setInterval(debounce(biu,500),1000)
/*biu这个函数在第一次1.5s后执行，然后每隔1s执行一次*/

let boom = function () {
    console.log('boom boom boom',new Date().Format('HH:mm:ss'))
}
setInterval(debounce(boom,2000),1000)
/*boom这个函数，一次都不会执行，函数执行事件是1s，但是函数间隔2s才会执行，每次2s还没到，就重新计时了*/
```

优化后

```javascript
    /在不断输入时，ajax会按照我们设定的时间，每1s执行一次
	function throttle(fun, delay) {
        let last, deferTimer
        return function (args) {
            let that = this
            let _args = arguments
            let now = +new Date()
            if (last && now < last + delay) {
                clearTimeout(deferTimer)
                deferTimer = setTimeout(function () {
                    last = now
                    fun.apply(that, _args)
                }, delay)
            }else {
                /如果现在=上一次的时间+延迟时间，那么就马上执行fun函数
                last = now
                fun.apply(that,_args)
            }
        }
    }

	/*throttleAjax是个函数，*/
    let throttleAjax = throttle(ajax, 1000);

	/* 获取当前的DOM元素，并添加键盘抬起的监听事件，每次抬起就调用函数throttleAjax*/
    let inputc = document.getElementById('throttle')
    inputc.addEventListener('keyup', function(e) {
        throttleAjax(e.target.value)
    });

	/不管我们设定的执行时间间隔多小，总是1s内只执行一次。
	let biubiu = function () {
        console.log('biu biu biu', new Date().Format('HH:mm:ss'))
    };
    setInterval(throttle(biubiu,1000),10);
```

总结：函数防抖，类似法师技能读条，还没读完条再按技能，就会重新读条，但是会出现一直读条不能放技能的状况；函数节流，就是一直按着技能键，也能在规定时间内发技能。

- 函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。
- 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。
- debounce
  - search搜索联想，用户在不断输入值时，用防抖来节约请求资源。
  - window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次
- throttle
  - 鼠标不断点击触发，mousedown(单位时间内只触发一次)
  - 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断

### 13.watch的使用

1.监听到变化，**执行方法**：

```javascript
watch: {    cityName(newName, oldName) {      / .../    } 
```

2.监听到变化，**改变变量值**：

```javascript
watch: {    cityName: 'nameChange'    } } 
```

3.这样使用watch时有一个特点，就是**当值第一次绑定的时候，不会执行监听函数，只有值发生改变才会执行**。

如果我们需要在最初绑定值的时候也执行函数，则就需要用到**`immediate`属性**。

比如当父组件向子组件动态传值时，子组件props首次获取到父组件传来的默认值时，也需要执行函数，此时就需要将`immediate`设为true。

`immediate`表示在watch中首次绑定的时候，是否执行handler，**值为true则表示在watch中声明的时候，就立即执行handler方法**，值为false，则和一般使用watch一样，在数据发生变化的时候才执行handler。

```javascript
watch: {    
    cityName: {    　　
        handler(newName, oldName) {      　　/ .../    　　},
    　　immediate: true    
    }  
} 
```

4.当需要监听一个对象的改变时，普通的watch方法**无法监听到对象内部属性的改变**，只有data中的数据才能够监听到变化，此时就需要deep属性对对象进行**深度监听**。

```javascript
watch: {
    cityName: {      
        handler(newName, oldName) {      / .../    },
        deep: true,    
        immediate: true    
    }  
} 
```

设置`deep: true` 则可以监听到`cityName.name`的变化，此时会**给cityName的所有属性都加上这个监听器**，当对象属性较多时，**每个属性值的变化都会执行handler**。

如果只需要监听对象中的一个属性值，则可以做以下优化：

```javascript
//使用字符串的形式监听对象属性：
watch: {
    'cityName.name': {      
        handler(newName, oldName) {      / ../      },
      	deep: true,      
        immediate: true    
    }  
}
```



## 其他经验积累

### 1. 在线json校验工具

后端接口调试返回数据的简便使用，非常好用，使用新版`http://www.bejson.com/`

### 2.测试环境中， 记得按disable cache ，可以不留缓存

### 3.移动端轮播图抖动问题

```css
overflow：hidden;
width：100%;
height：0;
padding-bottom：31.25%;
```

`padding-bottom：31.25%;`表示**高度根据宽度相对撑开31.25%**，保证图片的宽高比。
**注意**：不能将height设置成31.25%，因为height是相对于父级的百分比。
或者可以写成另一种形式：

```css
/*高度相对于viewport的宽度；但是可能有兼容性问题*/
width：100%;
height：31.25vm;
```



​     