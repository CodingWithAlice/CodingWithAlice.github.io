---
layout:     post
title:      工作遇到的问题小结
subtitle:  
date:       2019-08-03
author:     
header-img: 
catalog: true
tags:
    - < 微信小程序的学习 >
typora-root-url: ..
---

# 工作遇到的问题小结（实习）

## 第一周：

### 1. 页面显示没有数据

页面显示没有数据的时候（三级联动），注意去mounted里面看一下，获取数据的方法如`getAddress()；`有没有执行，是否将数据渲染到了页面；

### 2. async...await

async作为一个关键词放在函数前面，表示异步执行，该函数的执行不阻塞后面代码的执行；await表示等待await后面的函数执行完毕，并且有了返回结果之后，才能继续执行下面的代码

### 3.接口参数（必传/选传/键值对/值）

在调用接口的时候，注意传参和接收参数的形式要一致

```javascript
//这是声明调用接口的方法，传递的参数是params，参数的形式是键值对形式
export const getTree = (params) => {
	return new Promise(resolve => {
        SWXHR.get('/school', {   //这里写接口地址 
                params: params
            })
            .then(res => {
               resolve(res);
          });
    });
};
```

在接收参数的时候，直接在方法中异步调用，同时要记得在mount里面调用`this.getSchool();`执行函数，方便页面初次加载的时候有数据

```javascript
async getSchool() {
      let res = await getTree();
      if (res.code === "success") {
        	this.data = res.data;
      }
    }
```

当传递的参数**可选**时，接口处的参数形式应该写为`{params}`，这样在实例组件调用的时候以该参数的属性传递/键值对的形式传递   

```javascript
export const getInfo = (params) => {    
	return new Promise(resolve => {        
		SWXHR.get('/member', {params})
            .then(res => {
            	resolve(res);
        	});    
    });
};
```

```javascript
 async getInfoList() {      
     let params = {        
         Num: this.page,        
         Size: this.Size,        
         Id: this.Id,        
         Type: this.Type      };      
     if (this.name) {        
         if (/^[0-9]*$/.test(this.name) === true) {          
             params.telephone = this.name;        
         }else if(/^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/g.test(this.name)   
             params.email = this.name;        
         } else {          
             params.name = this.name;        
         }      
     }      
     if (this.school) {        
         params.school = this.school;      
     }      
     let res = await getInfo(params);      
     if (res.code === "success") {        
         this.data = res.data.items;             
         this.total = Number(res.data.total);      
     }    
 },
```

### 4.Chrome开发者调试工具中查看接口传递的参数

在接口调用参数的时候，一般以键值对的形式调用，可以**在`F12`的`Network`里面，点击`XHR`查询参数传递了什么**，根据传递的参数判断是否传递了正确参数。

### 5.404状态码

接口返回**404状态码**的时候，确认自己的运行环境，在测试环境运行调用接口的时候，需要后端把接口部署到测试服务器上，否则就会接口报错。

### 6.前端代码打包上传测试服务器

打包上传服务器的时候，**先`npm run build `在终端对文件进行打包**，然后将打包好的` dist `文件夹里的`css js `等文件 通过`WinSCP`软件进行上传，其中这个上传软件需要 主机名 端口 账号 密码

### 7.导入excel的时候，upload的钩子函数写在methods里面

`element UI`组件，进行upload上传excel导入功能的时候，`on-success`/`before-upload`等钩子函数，要写在实例对象的`methods`中，才能够正常调用，否则会报`undefined in render` 的错。

### 8.el-tree树形控件

`ElementUI Tree` 树形控件` https://blog.csdn.net/qq_42255106/article/details/80753096 ` 写的很细

### 9.文字提醒

在做输入文字提醒的时候，可以使用三级列表形式提醒，使用的是`element`中的`el-input` 和`el-tree` ，如果想要直接以数据形式提醒的话，可以使用element当中的`el-autocomplete`。

## 第二周

### 1. 关于将`localstorage`改为`sessionstorage`

​	`localStorage`和`sessionStorage`一样都是用来**存储客户端临时信息**的对象。

​	他们均只能存储字符串类型的对象（虽然规范中可以存储其他原生类型的对象，但是目前为止没有浏览器对其进行实现）。

​	`localStorage`生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除`localStorage`信息，否则这些信息将永远存在。`sessionStorage`生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过`sessionStorage`存储的数据也就被清空了。

​	**不同浏览器无法共享**`localStorage`或`sessionStorage`中的信息。相同浏览器的不同页面间可以共享相同的` localStorage`（页面属于相同域名和端口），但是不同页面或标签页间无法共享`sessionStorage`的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个`iframe`标签且他们属于同源页面，那么他们之间是可以共享`sessionStorage`的。

`http://www.test.com
https://www.test.com `（不同源，因为**协议不同**）
`http://my.test.com`（不同源，因为**主机名不同**）
`http://www.test.com:8080`（不同源，因为**端口不同**）
`localStorage`和`sessionStorage`使用时**使用相同的`API`**：

`localStorage`和`sessionStorage`都继承于`Storage`，提供了统一的`api`来访问和设置数据。

​	

|   API列表    |                                                          | 举例说明                                                     |
| :----------: | :------------------------------------------------------: | ------------------------------------------------------------ |
|    clear     |               清空存储中的所有本地存储数据               | `localStorage.clear();`                                      |
|  `getItem`   |          接受一个参数key，获取对应key的本地存储          | `localStorage.getItem('order');`<br/>// 对象访问方式同样有效<br/>`localStorage.order = 'b110';`<br/>`localStorage.order; `// b110 |
|     key      |       接受一个整数索引，返回对应本地存储中索引的键       | `localStorage.key(0);`                                       |
| `removeItem` |          接受一个参数key，删除对应本地存储的key          | `localStorage.removeItem('order')；`                         |
|  `setItem`   | 接受两个参数，key和value，如果不存在则添加，存在则更新。 | `localStorage.setItem('order', 'a109');`                     |

`localStorage.setItem("key","value");`//以“key”为名称**存储一个值**“value”
`localStorage.getItem("key");`//**获取**名称为“key”的值
**枚举**`localStorage`的方法：

```javascript
for(var i=0; i < localStorage.length;i++){
     var name = localStorage.key(i);
     var value = localStorage.getItem(name);
}
```

**删除**`localStorage`中存储信息的方法：
`localStorage.removeItem("key");`//删除名称为“key”的信息。
`localStorage.clear();`//清空`localStorage`中所有信息
 通过`getItem`或直接使用`localStorage["key"]`获取到的信息均为**实际存储的副本**。

```javascript
localStorage.key = {value1:"value1"};
localStorage.key.value1='a';
//这里是无法对实际存储的值产生作用的，下面的写法也不可以：
localStorage.getItem("key").value1="a";
```

一篇写的比较详细的文章：

`http://www.111cn.net/wy/html5/85886.htm`

### 2. element UI版本

在使用`element`文档内提供的组件的时候，如果使用之后发现有些功能无效，注意检查`element UI`的版本，可能是更新的属性。

更新升级element UI的版本方法：

```javascript
// 接下来的代码都在终端中输入
 npm view element-ui versions // 查看可升级到的element UI的版本
 npm update element-ui //然后更新到最新的版本，如果要指定版本，就接@版本号
 npm run serve // 启动项目，这里启动用serve还是dev自行确认下
```



### 3. 有关element UI 中树形组件 `el-tree` 实现各个节点多选功能

```html
<!-- 在html中写的标签结构 -->
<el-tree
    :data="groupTreeData"
    show-checkbox
    ref="DeviceGroupTree"
    node-key="id"
    check-strictly
    @check="checkGroupNode">
</el-tree>
```

其中每一项的配置解析如下：

```javascript
/*	:data树形结构的数据
	show-checkbox 显示复选框
	ref的绑定 可以实现this.$refs.DeviceGroupTree拿到此控件
	node-key 给节点的编号【树形数据结构中有id字段】
	check-stricty 父、子节点之间没有关联【不写这个，选了父节点会默认选择全部的子节点】
	@check 复选框选择、取消选择时触发的事件 */
```

在JS中写的代码：

```javascript
// 在script标签中写方法
checkGroupNode: function (a, b) {
    if (b.checkedKeys.length > 0) {
     this.$refs.DeviceGroupTree.setCheckedKeys([a.id]);
    }
}
```

### 4. `element UI`中三级级联组件

想要获取点击的内容时，可用` v-model="value"`来绑定，同时绑定事件`@change="handleChange"` 这样就可以在`methods`里面定义`handleChange`这个方法，同时传入value参数，进行数据处理。代码如下：

```javascript
// value 参数是标签中绑定的value值，作为参数传入
// 这里是为了实现多级级联多选时候，选中的节点，只取最后一项内容保存在school中
handleChange(value) {      
    for (let item of value) {       
        this.school.push(item[item.length - 1]);             
    }    
}
```

### 5. 动态生成二维码

先在终端中安装

```css
npm install qrcodejs2
```

然后在要生成二维码的页面中调用

```javascript
import QRCode from 'qrcodejs2'
```

然后在要展示二维码的结构处，为结构添加class属性

```html
<div class="qrcode" ref="qrCodeUrl"></div>
```

然后在`script`标签中添加方法

```javascript
creatQrCode() { // 创建一个实例对象
	var  qrcode = new QRCode(this.$refs.qrCodeUrl, {
	text: 'https://www.qtshe.com',
	width: 100,height: 100,colorDark: '#000000',colorLight: '#ffffff',     
	correctLevel: QRCode.CorrectLevel.H 
    })
},  
```

到此为止，二维码的功能代码已经写完，但是最后一个方法是需要调用的，否则就没有效果。

如果是在页面点击进来就要显示的话，就去`mounted(){}`钩子里面调用一下`this.creatQrCode();`，

如果是点击某个按钮等触发事件出现二维码的，只要在触发事件中绑定该方法即可。

### 6. `element ui`中`el-table`

在`el-table`中，`scope.row`表示的是**一行的数据**，如果我想要输出一个数组中的每一个对象的值，如下，可以**直接使用`{{scope.row.title}}`插槽**即可。

```json
"items":[
    {
        "id":"2000001",
        "school":"浙江大学",
        "title"："前端开发",
        "contnt":"HTML+CSS+JavaScript",
        "detail":"计算机基础"，
        "adress":"VScode",
        "likes":0,
        "views":45,
        "start":null,
        "schoolsNames":[
        	{
        		"id":"3000001",
        		"name":"华南理工",
        		"sort":2,
        		"likes":2,
        		"views":4,
        		"child":0,
        		"friends":9
    		},{},{},...
        ]
    },{},...
]
```

若对象中有数组，数组中以对象形式罗列，如上`person`数组，那么若要循环输出数组中的键值对，那么就要在这一行建立`template`，设置`slot-scope=“scope”`，在template里写个div,span都可以，用来承载`v-for`语句。

```html
<el-table-column prop="schoolsNames" label="学校"  show-overflow-tooltip > 
    <template scope="scope">  
        <span v-for="schoolsName in scope.row.schoolsNames" :key="schoolsName.id"> 				<span>{{ schoolsName.name }}</span >  
		</span>  
	</template> 
</el-table-column>
```



### 7.配置路由地址

在`router.js`文件中配置路由地址的时候，使用的是`vue-router`，只要写在`home`下面的，都可以通用`header`和`footer`，如果有页面不想要的话，就要把路由地址**放到外面去**。

```javascript
//`router.js`文件中
import Vue from "vue";
import Router from "vue-router";
Vue.use(Router);
export default new Router({  
    routes: [{      
        path: "/",      
        name: "home",      
        component: () => import('@/pages/homes/homeIndex/index.vue'),      
        redirect: {        
        	name: 'list'      
    	},      
         children: [{          
             path: "/list",          
             name: "list",          
             component: () => import('@/pages/homes/list/index.vue'),        
		},...
        //下面都是按照list的配置进行路由配置
```

如果需要验证登陆后才可以点击查看页面的话，增加一个判断条件：

```javascript
{          
    path: "/home",          
    name: "home",          
    meta: {            
          isAuth: true          
    },          
    component: () => import('@/pages/homes/home/index.vue'),        
},
```



### 8. `Vue2.0`中$router 和 $route的区别

 ①.router是`VueRouter`的一个对象，通过`Vue.use(VueRouter)`和`VueRouter`构造函数得到一个router的实例对象，这个对象中是一个**全局的对象**，他**包含了所有的路由包含了许多关键的对象和属性**。**$router**对象是全局路由的实例，是router构造方法的实例。`$router.push({path:'home'});`本质是向history栈中添加一个路由，在我们看来是 切换路由，但本质是在添加一个history记录。

路由实例方法：

replace方法 `$router.replace({path:'home'});`//替换路由，没有历史记录，一般使用replace来做404页面 `this.$router.replace('/')`。

还有push方法 ，push方法其实和`<router-link :to="...">`是等同的。注意：push方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。

还有go方法，`this.$router.go(-1) `// 后退         

②.route是一个跳转的路由对象，每一个路由都会有一个route对象，是一个**局部的对象**，可以获取对应的`name,path,params,query`等
我们可以从`vue devtools`中看到每个路由对象的不同。

`$route.path `字符串，等于当前路由对象的路径，会被解析为**绝对路径**，如 "/home/news" 。`$route.params `对象，包含路由中的动态片段和全匹配片段的**键值对**。

`$route.query `对象，包含路由中查询参数的键值对。例如，对于` /home/news/detail/01?favorite=yes `，会得到`$route.query.favorite == 'yes'` 。

`$route.router` 路由规则所属的路由器（以及其所属的组件）。

`$route.matched `数组，包含当前匹配的路径中所包含的所有片段所对应的**配置参数对象**。`$route.name` 当前路径的名字，如果没有使用具名路径，则名字为空。

### 9. 在线json校验工具

后端接口调试返回数据的简便使用，非常好用，使用新版`http://www.bejson.com/`

### 10. 身边朋友开始秋招遇到的问题

网易秋招题共4小时，5道编程题。

为什么选择`vue+element`这样一个体系搭建系统？有什么吗优点？

 在实习的项目中，你学到了什么？你认为现在的项目有什么可以优化的地方？

有公司要求写代码，用js原生仿照发布者订阅者模式写。

写一个左侧导航栏，不能调试，鼠标移动底部变色，参照京东左侧导航栏

### 11. 之前视频中站友提出的我说的有问题的地方

闭包：当外部函数返回之后，内部函数可以访问外部函数的属性或者方法。

get 和post 安全等级是同级别的，不要说安全区别，都不安全，get有数据缓存的问题，清缓存query需要加时间戳，post就不会有这个问题。

` attachEvent`绑定的事件，如果需要注销，应该使用`detachEvent`

测试环境中， 记得按disable cache ，可以不留缓存





















