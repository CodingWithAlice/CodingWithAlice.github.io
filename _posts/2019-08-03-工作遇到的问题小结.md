---
layout:     post
title:      工作遇到的问题小结
subtitle:  
date:       2019-08-03
author:     
header-img: 
catalog: true
tags:
    - < 微信小程序的学习 >
typora-root-url: ..
---

# 工作遇到的问题小结（实习）

## vue element UI 组件相关问题

### 1.`el-upload` 导入excel

`element UI`组件，进行upload上传excel导入功能的时候，`on-success`/`before-upload`等钩子函数，要写在实例对象的`methods`中，才能够正常调用，否则会报`undefined in render` 的错。

### 2.`el-tree` 树形控件

`ElementUI Tree` 树形控件` https://blog.csdn.net/qq_42255106/article/details/80753096 ` 写的很细

有关element UI 中树形组件 `el-tree` 实现各个节点多选功能

```html
<!-- 在html中写的标签结构 -->
<el-tree
    :data="groupTreeData"
    show-checkbox
    ref="DeviceGroupTree"
    node-key="id"
    check-strictly
    @check="checkGroupNode">
</el-tree>
```

其中每一项的配置解析如下：

```javascript
/*	:data树形结构的数据
	show-checkbox 显示复选框
	ref的绑定 可以实现this.$refs.DeviceGroupTree拿到此控件
	node-key 给节点的编号【树形数据结构中有id字段】
	check-stricty 父、子节点之间没有关联【不写这个，选了父节点会默认选择全部的子节点】
	@check 复选框选择、取消选择时触发的事件 */
```

在JS中写的代码：

```javascript
// 在script标签中写方法
checkGroupNode: function (a, b) {
    if (b.checkedKeys.length > 0) {
     this.$refs.DeviceGroupTree.setCheckedKeys([a.id]);
    }
}
```

### 3.`el-input` 文字提醒

在做输入文字提醒的时候，可以使用三级列表形式提醒，使用的是`element`中的`el-input` 和`el-tree` ，如果想要直接以数据形式提醒的话，可以使用element当中的`el-autocomplete`。

### 4. element UI版本更新

在使用`element`文档内提供的组件的时候，如果使用之后发现有些功能无效，注意检查`element UI`的版本，可能是更新的属性。

更新升级element UI的版本方法：

```javascript
// 接下来的代码都在终端中输入
 npm view element-ui versions // 查看可升级到的element UI的版本
 npm update element-ui //然后更新到最新的版本，如果要指定版本，就接@版本号
 npm run serve // 启动项目，这里启动用serve还是dev自行确认下
```

### 5. `el-cascader` 三级级联组件

想要获取点击的内容时，可用` v-model="value"`来绑定，同时绑定事件`@change="handleChange"` 这样就可以在`methods`里面定义`handleChange`这个方法，同时传入value参数，进行数据处理。代码如下：

```javascript
// value 参数是标签中绑定的value值，作为参数传入
// 这里是为了实现多级级联多选时候，选中的节点，只取最后一项内容保存在school中
handleChange(value) {      
    for (let item of value) {       
        this.three.push(item[item.length - 1]);             
    }  
}
```

① 在级联中，options用于绑定数据，记得在标签里面**写的时候要加冒号**：；

②`:props`绑定后，可以传入对象，重置value（id） label（name） 和children（arrayData）的变量名

```javascript
data:{
	defaultprops:{
        value:"id",
        label:"name",
        children:"arrayData"
    }
}
```

### 6. `el-table` 表格

在`el-table`中，`scope.row`表示的是**一行的数据**，如果我想要输出一个数组中的每一个对象的值，如下，可以直接使用`{{scope.row.title}}`插槽即可。

```json
"items":[
    {
        "id":"2000001",
        "school":"浙江大学",
        "title":"前端开发",
        "contnt":"HTML+CSS+JavaScript",
        "detail":"计算机基础",
        "adress":"VScode",
        "likes":0,
        "views":45,
        "start":null,
        "schoolsNames":[
        	{
        		"id":"3000001",
        		"name":"华南理工",
        		"sort":2,
        		"likes":2,
        		"views":4,
        		"child":0,
        		"friends":9
    		},{},{}
        ]
    },{}
]
```

若对象中有数组，数组中以对象形式罗列，如上`person`数组，那么若要循环输出数组中的键值对，那么就要在这一行建立`template`，设置`slot-scope=“scope”`，在template里写个div,span都可以，用来承载`v-for`语句。

```html
<el-table-column prop="schoolsNames" label="学校"  show-overflow-tooltip > 
    <template scope="scope">  
        <span v-for="schoolsName in scope.row.schoolsNames" :key="schoolsName.id"> 								<span>{{ schoolsName.name }}</span >  
		</span>  
	</template> 
</el-table-column>
```

### 7.`el-menu ` 左侧导航

 1.要实现路由跳转，**先要在el-menu标签上添加router属性**，然后只要在每个**el-menu-item标签内的index属性**设置一下`url`即可实现点击el-menu-item实现路由跳转。

2.导航当前项设置：在el-menu标签中绑定 ` :default-active="$route.path"`,注意是绑定属性，不要忘了加`“:”`,当`$route.path`等于el-menu-item标签中的index属性值时则该item为当前项。

```html
        <el-menu 
                 router 
                 :default-active="$route.path" 
                 @open="handleOpen"
                 @close="handleClose" >
            <el-submenu index="1">
                <template slot="title">
                    <i class="el-icon-location"></i>
                    <span>信息</span>
                </template>
                <el-menu-item-group>
                    <el-menu-item index="/user/account">账号</el-menu-item>
                    <el-menu-item index="/user/password">密码</el-menu-item>
            </el-submenu>
            <el-submenu index="2">
                <template slot="title">
                    <i class="el-icon-location"></i>
                    <span>信息</span>
                </template>
                <el-menu-item-group>
                    <el-menu-item index="/company/manager">管理</el-menu-item>
                    <el-menu-item index="/company/edit">添加</el-menu-item>
                </el-menu-item-group>
            </el-submenu>
        </el-menu>
```

### 8. `el-form` 发布框必填/验证

①流程：在对发布框进行必填操作时，**先在 el-form 标签中 ，绑定rules**；然后在各个el-form-item标签中，**写prop属性，来匹配rules**；最后**在data中定义rules对应的验证**；

在rules中定义一个可以**验证 输入内容是否是数字的输入框**：

 ②其中一定要注意`v-model.number`绑定值的时候，绑定了number

```html
<el-form-item            
              label="积分"            
              prop="productPrice"            
              :step="1"            
              step-strictly            
              class="product_price">            
    <el-input 
              placeholder="请输入积分" 
              type="productPrice" 
              v-model.number="activityForm.productPrice" ><!--注意这里的v-model-->        
        <template slot="append">积分</template>            
    </el-input>          
</el-form-item>
```

```javascript
//  rules里面填写
productPrice: [          
    { type: 'number', message: "必须为数字值", trigger: "blur" },          
    { required: true, message: "请输入积分", trigger: "blur" }        
],  
```

③在验证的时候，**一定要把prop绑定的类别放置在父级**。如果跨开一级，就会一直失败

```html
<el-form-item label="类别" >              
    <el-select  
               prop="type" 
               v-model="Type" >                
        <el-option                  
                   v-for="item in List"                  
                   v-model="item.Name"                  
                   :key="item.Id">
        </el-option>              
    </el-select>            
</el-form-item>
```



## 遇到的报错总结

### 1. 页面显示没有数据

页面显示没有数据的时候（三级联动），注意去mounted里面看一下，获取数据的方法如`getAddress()；`有没有执行，是否将数据渲染到了页面；

### 2.404 状态码

第一次：接口返回**404状态码**的时候，确认自己的**运行环境**，在测试环境运行调用接口的时候，需要后端把接口部署到测试服务器上，否则就会接口报错。

这是第二次报错404，新增接口类别后，一定要记得去**`vue.config.js`里面添加`context`** 

```javascript
 module.exports = {    
     devServer: {    
         port: 8888,    
         open: true,    
         proxy: (() => {            
             let context = ['/credit'];            
             let obj = {};            
             context.forEach(item => {                
                 obj[item] = {                                  
                     // 电脑本地                    
                     target: 'http://10.200.144.130:12600/'                               
                 };  });            
             return obj;        
         })()    } }        
```

### 3.报错`TypeError: Object(...) is not a function`

`vue`报错`TypeError: Object(...) is not a function` 从几个方面入手 

1.确认方法命名**是否重名** 

2.**确认`import`的时候没有问题**（我这次是import from的地址不对导致的）

3.`mounted`里面调用的时候测试一下是否有问题

4.`import {sth} from ‘@/api/index’ `中，如果**没有加{}**，也会报错Object（...）is not  a function



### 4.报400错误

在报400错误的时候，同时发现传递的值和接口所需的值的类型是一一对应的，这个时候要确认，我遇到的问题就是**接口所需的URL是有传递的id和类型**的，但是我定义`api`的时候用的`formData`，还试了`json`格式的`params:params` ，这个时候要在定义`api`的时候写上URL的跳转方式：

![1566114641130](/img/assets_2019/1566114641130.png)

```javascript
// 修改 
export const update = (id,num) => {    
    return new Promise(resolve => {        
      SWXHR.put('/credit/update?Id='+id+'&Change='+num,{}) 
            .then(res => {                
            	resolve(res);            
        });    
    })};
```



## 接口/参数遇到的问题

### 1.接口参数（必传/选传/键值对/值）

在调用接口的时候，注意传参和接收参数的形式要一致

```javascript
//这是声明调用接口的方法，传递的参数是params，参数的形式是键值对形式
export const getTree = (params) => {
	return new Promise(resolve => {
        SWXHR.get('/school', {   //这里写接口地址 
                params: params
            })
            .then(res => {
               resolve(res);
          });
    });
};
```

在接收参数的时候，直接在方法中异步调用，同时要记得在mount里面调用`this.getSchool();`执行函数，方便页面初次加载的时候有数据

```javascript
async getSchool() {
      let res = await getTree();
      if (res.code === "success") {
        	this.data = res.data;
      }
    }
```

当传递的参数**可选**时，接口处的参数形式应该写为`{params}`，这样在实例组件调用的时候以该参数的属性传递/键值对的形式传递   

```javascript
export const getInfo = (params) => {    
	return new Promise(resolve => {        
		SWXHR.get('/member', {params})
            .then(res => {
            	resolve(res);
        	});    
    });
};
```

```javascript
 async getInfoList() {      
     let params = {        
         Num: this.page,        
         Size: this.Size,        
         Id: this.Id,        
         Type: this.Type      };      
     if (this.name) {        
         if (/^[0-9]*$/.test(this.name) === true) {          
             params.telephone = this.name;        
         }else if(/^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/g.test(this.name)   
             params.email = this.name;        
         } else {          
             params.name = this.name;        
         }      
     }      
     if (this.school) {        
         params.school = this.school;      
     }      
     let res = await getInfo(params);      
     if (res.code === "success") {        
         this.data = res.data.items;             
         this.total = Number(res.data.total);      
     }    
 },
```

### 2.Chrome开发者调试工具中查看接口传递的参数

在接口调用参数的时候，一般以键值对的形式调用，可以**在`F12`的`Network`里面，点击`XHR`查询参数传递了什么**，根据传递的参数判断是否传递了正确参数。



## 动态生成二维码问题

### 1. 动态生成二维码

先在终端中安装

```css
npm install qrcodejs2
```

然后在要生成二维码的页面中调用

```javascript
import QRCode from 'qrcodejs2'
```

然后在要展示二维码的结构处，为结构添加class属性

```html
<div class="qrcode" ref="qrCodeUrl"></div>
```

然后在`script`标签中添加方法

```javascript
creatQrCode() { // 创建一个实例对象
	var  qrcode = new QRCode(this.$refs.qrCodeUrl, {
	text: 'https://www.qtshe.com',
	width: 100,height: 100,colorDark: '#000000',colorLight: '#ffffff',     
	correctLevel: QRCode.CorrectLevel.H 
    })
},  
```

到此为止，二维码的功能代码已经写完，但是最后一个方法是需要调用的，否则就没有效果。

如果是在页面点击进来就要显示的话，就去`mounted(){}`钩子里面调用一下`this.creatQrCode();`，

如果是点击某个按钮等触发事件出现二维码的，只要在触发事件中绑定该方法即可。

### 2.在二级弹窗中显示二维码

①如果使用对话框显示二维码，有时会由于`html`元素还没有创建，导致生成二维码时报对象不存在或者`appenchild`方法未定义的错误。这时可以**使用`nextTick`来处理**。

```javascript
showQRCode(){      
    this.$nextTick(()=>{/* 使用了nextTick之后，会在生成DOM元素之后绑定*/  
        var qrcode = new QRCode(this.$refs.qrcodeContainer, {              
            text: 'https://wallimn.iteye.com',              
            width: 100,              
            height: 100,              
            colorDark: '#000000',              
            colorLight: '#ffffff',              
            correctLevel: QRCode.CorrectLevel.H          
        })      }  }  
```

②定义完方法后，**只在点击出现对话框的时候，调用`showQRCode`的方法**即可；可以不用在mounted里面进行调用。

③多次**点击会出现多个二维码**，这个时候要设置`this.$refs.qrCodeUrl.innerHTML='';`，保证每一次点击重新生成二维码之前，都已经将之前的清除了；

④在跳转前的页面 设置的地址如下` text:"'/qrcode/' + id " `, 到了跳转到的页面，可以通过**`this.$route.params.id `获取到`url`中的id值**



## 路由相关配置

### 1.配置路由地址

在`router.js`文件中配置路由地址的时候，使用的是`vue-router`，只要写在`home`下面的，都可以通用`header`和`footer`，如果有页面不想要的话，就要把路由地址**放到外面去**。

```javascript
//`router.js`文件中
import Vue from "vue";
import Router from "vue-router";
Vue.use(Router);
export default new Router({  
    routes: [{      
        path: "/",      
        name: "home",      
        component: () => import('@/pages/homes/homeIndex/index.vue'),      
        redirect: {        
        	name: 'list'      
    	},      
         children: [{          
             path: "/list",          
             name: "list",          
             component: () => import('@/pages/homes/list/index.vue'),        
		},...
        //下面都是按照list的配置进行路由配置
```

如果需要验证登陆后才可以点击查看页面的话，增加一个判断条件：

```javascript
{          
    path: "/home",          
    name: "home",          
    meta: {            
          isAuth: true          
    },          
    component: () => import('@/pages/homes/home/index.vue'),        
},
```

### 2. `Vue2.0`中$router 和 $route的区别

 ①.router是`VueRouter`的一个对象，通过`Vue.use(VueRouter)`和`VueRouter`构造函数得到一个router的实例对象，这个对象中是一个**全局的对象**，他**包含了所有的路由包含了许多关键的对象和属性**。**$router**对象是全局路由的实例，是router构造方法的实例。`$router.push({path:'home'});`本质是向history栈中添加一个路由，在我们看来是 切换路由，但本质是在添加一个history记录。

路由实例方法：

replace方法 `$router.replace({path:'home'});`//替换路由，没有历史记录，一般使用replace来做404页面 `this.$router.replace('/')`。

还有push方法 ，push方法其实和`<router-link :to="...">`是等同的。注意：push方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。

还有go方法，`this.$router.go(-1) `// 后退         

②.route是一个跳转的路由对象，每一个路由都会有一个route对象，是一个**局部的对象**，可以获取对应的`name,path,params,query`等
我们可以从`vue devtools`中看到每个路由对象的不同。

`$route.path `字符串，等于当前路由对象的路径，会被解析为**绝对路径**，如 "/home/news" 。`$route.params `对象，包含路由中的动态片段和全匹配片段的**键值对**。

`$route.query `对象，包含路由中查询参数的键值对。例如，对于` /home/news/detail/01?favorite=yes `，会得到`$route.query.favorite == 'yes'` 。

`$route.router` 路由规则所属的路由器（以及其所属的组件）。

`$route.matched `数组，包含当前匹配的路径中所包含的所有片段所对应的**配置参数对象**。`$route.name` 当前路径的名字，如果没有使用具名路径，则名字为空。

### 3.在`router.js`中配置相同页面不同id的地址

在`router.js`配置地址的时候，想要配置一个**不同id显示相同类别的页面**，

```javascript
// 这是正常页面跳转配置
{          
    path: "/Detail",          
    name: "Detail",          
    component: () => import('@/pages/Detail/index.vue'),        
},   
                
//这是带有id传值的配置   
{          
    path: "/Detail/:id",   /*注意这里，加了一个/：id*/         
    name: "Detail",          
    component: () => import('@/pages/Detail/index.vue'),        
},
```



## 基础知识补档

### 1. async...await

async作为一个关键词放在函数前面，表示异步执行，该函数的执行不阻塞后面代码的执行；await表示等待await后面的函数执行完毕，并且有了返回结果之后，才能继续执行下面的代码

### 2.前端代码打包上传测试服务器

打包上传服务器的时候，**先`npm run build `在终端对文件进行打包**，然后将打包好的` dist `文件夹里的`css js `等文件 通过`WinSCP`软件进行上传，其中这个上传软件需要 主机名 端口 账号 密码

### 3. 关于将`localstorage`改为`sessionstorage`

​	`localStorage`和`sessionStorage`一样都是用来**存储客户端临时信息**的对象。

​	他们均只能存储字符串类型的对象（虽然规范中可以存储其他原生类型的对象，但是目前为止没有浏览器对其进行实现）。

​	`localStorage`生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除`localStorage`信息，否则这些信息将永远存在。`sessionStorage`生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过`sessionStorage`存储的数据也就被清空了。

​	**不同浏览器无法共享**`localStorage`或`sessionStorage`中的信息。相同浏览器的不同页面间可以共享相同的` localStorage`（页面属于相同域名和端口），但是不同页面或标签页间无法共享`sessionStorage`的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个`iframe`标签且他们属于同源页面，那么他们之间是可以共享`sessionStorage`的。

`http://www.test.com
https://www.test.com `（不同源，因为**协议不同**）
`http://my.test.com`（不同源，因为**主机名不同**）
`http://www.test.com:8080`（不同源，因为**端口不同**）
`localStorage`和`sessionStorage`使用时**使用相同的`API`**：

`localStorage`和`sessionStorage`都继承于`Storage`，提供了统一的`api`来访问和设置数据。

​	

|   API列表    |                                                          | 举例说明                                                     |
| :----------: | :------------------------------------------------------: | ------------------------------------------------------------ |
|    clear     |               清空存储中的所有本地存储数据               | `localStorage.clear();`                                      |
|  `getItem`   |          接受一个参数key，获取对应key的本地存储          | `localStorage.getItem('order');`<br/>// 对象访问方式同样有效<br/>`localStorage.order = 'b110';`<br/>`localStorage.order; `// b110 |
|     key      |       接受一个整数索引，返回对应本地存储中索引的键       | `localStorage.key(0);`                                       |
| `removeItem` |          接受一个参数key，删除对应本地存储的key          | `localStorage.removeItem('order')；`                         |
|  `setItem`   | 接受两个参数，key和value，如果不存在则添加，存在则更新。 | `localStorage.setItem('order', 'a109');`                     |

`localStorage.setItem("key","value");`//以“key”为名称**存储一个值**“value”
`localStorage.getItem("key");`//**获取**名称为“key”的值
**枚举**`localStorage`的方法：

```javascript
for(var i=0; i < localStorage.length;i++){
     var name = localStorage.key(i);
     var value = localStorage.getItem(name);
}
```

**删除**`localStorage`中存储信息的方法：
`localStorage.removeItem("key");`//删除名称为“key”的信息。
`localStorage.clear();`//清空`localStorage`中所有信息
 通过`getItem`或直接使用`localStorage["key"]`获取到的信息均为**实际存储的副本**。

```javascript
localStorage.key = {value1:"value1"};
localStorage.key.value1='a';
//这里是无法对实际存储的值产生作用的，下面的写法也不可以：
localStorage.getItem("key").value1="a";
```

一篇写的比较详细的文章：

`http://www.111cn.net/wy/html5/85886.htm`

### 4.定义在`utils`里面的静态的`storage.js`文件中的方法

```javascript
/** * 设置localStorage * @param {名称} name  * @param {值} value  */
export const setLocalValue = (name, value) => {    
    if (window.localStorage) {        
        localStorage.setItem(name, JSON.stringify(value));    
    } else {        
        alert('7008');    
    }
}
/** * 获取localStorage * @param {*名称} name  */
export const getLocalValue = (name) => {    
    const value = localStorage.getItem(name);    
    if (value) {        
        return JSON.parse(value)    
    } else {        
        return ''    
    }
}
/** * 设置cookie * @param {cookie名称} name  * @param {*cookie值} value  * @param {*过期时间（分钟）} time  */
export const setCookie = (name, value, time) => {    
    let d = new Date()    
    d.setTime(d.getTime() + (time * 60 * 1000));    
    document.cookie = name + '=' + JSON.stringify(value) + ';path=/;expires=' + d.toGMTString();
}
/** * 获取cookie * @param {*cookie名称} names  */
export const getCookie = (names) => {    
    let name = names + "=";    
    let cookies = document.cookie.split(';');    
    for (let i = 0; i < cookies.length; i++) {        
        let cookie = cookies[i];        
        while (cookie.charAt(0) === ' ') cookie = cookie.substring(1);        
        if (cookie.indexOf(name) !== -1) {            
            let cookied = cookie.substring(name.length, cookie.length);            
            return JSON.parse(cookied)        
        }    
    }    
    return "";
}
```

### 5.`a`标签中的`href`写法

在写a标签中 的`href`的链接的时候，要**拼接字符串**的话，

```javascript
:href= "'/activity/Members?activityId=' + Id"
```

1.`href`前面要**加冒号**，

2.字符串用**单引号**‘/activity/Members?activityId=’包裹，`href`的链接用**双引号**包裹“”，否则会报错

3.尾部记得别忘记加` .html`

### 6.`img`中的`src`的写法

需要对图片image的`src`地址进行**动态绑定的时候**，记得要在`src`前面加：即v-on进行绑定 

```javascript
< img                
:src="imgSrc"                
style="padding-left:20px;vertical-align: middle"               @click="addLikes(item.id,item.likes)"              
/>   
```

然后`imgSrc`的值就可以**在data中定义**，在点击的方法中定义 

直接写`imgSrc:'./../../../assets/images/喜欢.png'  `会一直找不到image的路径  要写成`imgSrc:require("@/assets/images/喜欢.png") `**将图片作为模块加载进去**；

或者，将图片放到static目录下，但必须写成绝对路径如`images:[{src:”/static/1.png”},{src:”/static/2.png”}]`这样图片也会显示出来，当然你也可以通过在`webpack.base.config.js`定义来缩短路径的书写长度。

### 7.显示一行文本/多行文本+省略号

```javascript
//一行文本省略 
white-space: nowrap;
text-overflow: ellipsis;
overflow: hidden;
word-break: 
break-all;
//多行文本省略(ps：此处是两行)
text-overflow: -o-ellipsis-lastline;
overflow: hidden;
text-overflow: ellipsis;
display: -webkit-box;
-webkit-line-clamp: 2;
line-clamp: 2;
-webkit-box-orient: vertical;
word-break: break-all;
```

### 8.获取本地登陆的id等信息的方法

```javascript
//方法1：   
let loginInfo = JSON.parse(localStorage.getItem("loginInfo")); 
//方法2：         
let loginInfo = this.getLocalValue("loginInfo");
```

### 9.`this.$message.success("签到成功"); `弹出签到成功



## 其他经验积累

### 1. 在线json校验工具

后端接口调试返回数据的简便使用，非常好用，使用新版`http://www.bejson.com/`

### 2.测试环境中， 记得按disable cache ，可以不留缓存



## 第四周 实习经验分享

### 1.有关块级元素包裹块级元素，在下方出现的间隙

（div包裹div，div包裹img）都是块级包块级常见的情况，导致这个的原因：

​	内联元素的默认垂直**对齐方式是和基线对齐**（vertical-align：baseline），并不是和底部对齐，以及**父级元素默认的行高**问题。

​	暴力解决：1.浮动（可能导致父元素塌陷的问题，注意父级元素清除浮动）2.转化为块级元素　3.定位（使用定位时脱离文档流，注意父元素塌陷，定位完全脱离父元素，清除浮动没用）　

​	本质解决：1.修改父级元素：line-height:0；2.修改父级元素：font-size:0;　3.修改内联元素：vertical-align：根据需求可以改为middle、top、bottom、text-bottom等值，这种方式解决空隙问题比较好；     

有关多张图片连着排列的间隙问题：浏览器把两个img标签之间的空格当成了空白节点。解决方案：1.多个img标签写在一行 2.在img标签的父级上写：font-size:0;3.使用display：block(img是内联元素)//要float一下才行4.使用letter-spacing属性，在父级上面设置style="letter-spacing:-800px"<!--letter-spacing的值无论是负多少都不会产生重叠-->







