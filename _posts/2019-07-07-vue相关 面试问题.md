---
layout:     post
title:     vue相关 面试问题
subtitle:  
date:       2019-07-07
author:     
header-img: 
catalog: true
tags:
    - < 面试题整理 >
typora-root-url: ..
---



# vue相关 面试问题

#### 1. vue实现双向绑定的原理？

VUE实现双向数据绑定的原理就是利用了 **Object.defineProperty() 方法重新定义了对象获取属性值get和设置属性值set的操作**来实现的；

`Object.defineProperty() `三个参数：要操作的对象，要定义或修改的对象属性名，属性描述符；

其中，属性描述符是一个对象，主要有两种形式（任选其一）：数据描述符和存取描述符（get、set）。

```javascript
var obj = { };
var name;
//第一个参数：定义属性的对象;第二个参数：要定义或修改的属性的名称;第三个参数：将被定义或修改的属性描述符。
Object.defineProperty(obj, "data", {
    //获取值
    get:function () {
        return name;
    },
    //设置值
    set:function (val) {
        name = val;
        console.log(val);
    }
})
    //赋值调用set
	obj.data = 'aaa';
    //取值调用get
	console.log(obj.data);
```

这里着重理解**data更新，view视图层是怎么更新的**：（view更新，要data改变只要进行事件监听即可）利用`Object.defineProperty() `对属性设置的set函数，**改变了data数据就会触发set函数**，在这个函数里面添加更新view视图层的方法即可。



#### 2. vue组件之间的传值？

1. 父传子：
先在**父组件中绑定变量`<child :msg="parent"></child>`**，parent是定义在父组件中的变量/值；
再在**子组件中添加props属性接收**父组件传递过来的变量`props:['msg']`；
最后就可以在子组件中使用``来表示父组件中parent变量中的值了。

2. 子传父：
   先在子组件中**绑定事件`@change="sendChild"`**，触发的时候在`setChild`事件中**用`$emit()`触发父组件中的函数**，并将子组件中的变量作为参数传递；
```javascript
   methods：{
       sendChild:function(){
           this.$emit('transparent',this.msg)
       }
   }
```
在父组件中绑定事件`<child @transparent="getChild"></child>`，当子组件触发这个事件的时候，就可以**调用getChild方法获取到传递过来的参数**；
```javascript
   methods:{
       getChild(msg){
           this.user=msg;
       }
   }
```
1.兄弟组件互相传值，**通过Vuex状态管理传值**：
先通过npm加载vuex，创建store.js文件

```javascript
//store.js
   import Vue from 'vue'
   import Vuex from 'vuex'
   Vue.use(Vuex);
   const state={name:'Alice'};
   const mutations={
       newName(state,message){
           state.name=message
       }
   }
   export default new Vuex.Store({state,mutations})
```
2.兄弟组件互相传值，引入bus.js文件，发布者订阅者模式：

```javascript
import Bus from './bus.js'
```
```javascript
//一个子组件触发
methods:{
  Bus.$emit('触发的方法名'，需要传递的值);
}
```
```javascript
//一个子组件监听
   mounted:{
       bus.$on("方法名",(传递的值)=>{ })
   }
```
3.兄弟组件互相传值`$root`

```javascript
//一个子组件触发
this.$root.$emit('触发的方法名'，需要传递的值);
//一个子组件监听
this.$root.$off("方法名");//每次进入先关闭一下
this.$root.$on("方法名",(传递的值)=>{ })
```



#### 3.vue的生命周期有哪些？它们有什么不同？

| 生命周期钩子  | 组件状态                                                     | 响应类型                                                     | 最佳实践                                                     |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| beforeCreate  | 实例初始化之后，this指向创建的实例，不能访问到data、computed、watch、methods（都不存在）上的方法和数据 | 拿不到任何信息，无法篡改数据，一般做loding，这个时候的vue实例还什么都没有，但是$route对象是存在的，可以根据路由信息进行重定向之类的操作。 | 常用于初始化非响应式变量                                     |
| created       | 实例创建完成，可访问data、computed、watch、methods上的方法和数据，还未挂载到DOM，不能访问到$el属性，$ref属性内容为空数组 | $el,没有初始化，数据已加载完成，可以篡改数据，并更新，不会触发beforeUpdate，updated，在这结束loading，还做一些初始化，实现函数自执行 ，$ref属性内容为空数组；定义getter、setter存储器属性，在实例创建之后被调用，该阶段可以访问data，可以使用this。该阶段允许执行http请求操作。 | 常用于简单的ajax请求，页面的初始化                           |
| beforeMount   | 在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数 | $el已被初始化，数据已加载完成，阔以篡改数据，并更新，不会触发beforeUpdate，updated。将HTML解析生成AST节点，再根据AST节点动态生成渲染函数。**相关render函数首次被调用**(划重点)。 | \-                                                           |
| mounted       | 实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问 | $el已被初始化,，数据已加载完成，阔以篡改数据，并更新，并且触发beforeUpdate，updated，在这发起后端请求，拿回数据，配合路由钩子做一些事情；在挂载完成之后被调用，执行render函数生成虚拟dom，创建真实dom替换虚拟dom，并挂载到实例。可以操作dom，比如事件监听 | 常用于获取信息和操作，**ajax请求**                           |
| beforeUpdate  | 响应式数据更新时调用，发生在虚拟DOM打补丁之前                | $vm.data更新之后，虚拟dom重新渲染之前被调用。在这个钩子可以修改$vm.data，并不会触发附加的重渲染过程。 | 适合在**更新之前访问**现有的DOM，比如手动移除已添加的事件监听器 |
| updated       | 虚拟DOM重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作 | 虚拟dom重新渲染后调用，若再次修改$vm.data，会再次触发beforeUpdate、updated，进入死循环 | 避免在这个钩子函数中操作数据，可能**陷入死循环**             |
| beforeDestroy | 实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例 |                                                              | **常用于销毁**定时器、解绑全局事件、销毁插件对象等操作       |
| destroyed     | 实例销毁后调用，调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 |                                                              | -                                                            |

注：

1. 其中created和mounted中**ajax请求**的区别：created的时候视图未出现，请求较多的情况下，会出现**白屏**；
2. 初始化组件的时候，仅执行beforeCreated/created/beforeMount/mounted四个钩子函数；
3. 当改变data中定义的**响应式变量**时，会执行beforeUpadate/updated；
4. 初始化和销毁时的钩子函数只会执行一次，beforeUpadate/updated**可执行多次**；
5. 挂载的时候，子组件完成挂载后，父组件才会挂载；
6. 当子组件完成挂载后，父组件会**主动执行一次**beforeUpdate/updated钩子函数（仅首次）；
7. 销毁父组件时，先将子组件销毁后，才会销毁父组件；

8. created 是加载DOM,html之后 就马上执行, 比如初始化,获取屏幕高度调整,赋值等等；

而mounted就是执行包括js之后,准备开始调用方法,也就是说 类似传统开发那样,先加载jquery 再调用插件；

9. 总结来说，虚拟dom开始渲染是在beforeMount时，dom实例挂载完成在mounted阶段显示。那么接下来了解就是render函数。render函数最终返回的是createNodeDescription(节点描述)，即俗称virtual node(虚拟节点)。



#### 4. vuex的功能？能否进行兄弟组件之间的传值？

vuex专为 Vue.js 应用程序开发的**状态管理模式**。主要用于管理vue中的数据，可以兄弟组件互相传值；

![](/img/assets_2019/vuex.png)

state：管理项目的数据（进行数据初始化）；

mutations：主要用于操作state中的数据`store.commit('increment')`；

action：通过提交 mutation 的方式，而非直接改变 `store.state.count`，是因为我们想要更明确地追踪到状态的变化；

getter：就像计算属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算；getter 接受 state 作为其第一个参数；

```html
<div id="app1">
    {{count}}
</div>
```

```javascript
//store.js
import Vue from 'vue';
import Vuex from 'vuex';

Vue.use(Vuex);

const store = new Vuex.Store({
    state:{
        count:0
    }
});

new Vue({
    el:'#app1',
    store,
    computed:{
        count(){
            return this.$store.state.count
        }
    }
})
```



#### 5. Axios调取数据？

[页面直接引用 `<script src="https://unpkg.com/axios/dist/axios.min.js"></script>`]

#### axios的特性

1.可以从浏览器中创建XHR对象
2、可以从nodeJS中创建HTTP请求
3、支持Promise
4、可以拦截请求和响应
5、可以转换请求数据和响应数据
6、可以取消请求
7、可以自动转换JSON数据
8、客户端支持防御XSRF

**axios get 方法**：仅仅请求后台数据

```javascript
axios.get('index.php')
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
```

**aixos post方法**：post请求更多的是要提交数据，params属性里的数据会出现在请求主体中。

```javascript
axios.post('/user', {
    firstName: 'Fred',
    lastName: 'Flintstone'
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
```

**多并发请求,一次性发几个请求**

```javascript
function getUserAccount() {
  return axios.get('/user/12345');
}

function getUserPermissions() {
  return axios.get('/user/12345/permissions');
}

axios.all([getUserAccount(), getUserPermissions()])
  .then(axios.spread(function (acct, perms) {
    // acct为第一个请求的结果，perms为第二个请求的结果
  }));
```

**设置拦截器**：

```javascript
//请求拦截器
		axios.interceptors.request.use(  
        config => {
            btn.innerHTML='请求数据中';
            return config;
        },
        // 错误时发生的事情
        err => {
            console.log(err)
        });
```

```javascript
 // 响应应拦截器
        axios.interceptors.response.use(
        config => {
            btn.innerHTML='请求数据成功';
            return config;
        },
        // 错误时发生的事情
        err => {
            console.log(err)
        });
```

**设置自定义请求头**：

先安装Axios：`npm install axios --save`

再在main.js中引入Axios：

```javascript
import axios from 'axios'
Vue.prototype.$http = axios;
```

即可在组件中调用Axios：

```javascript
this.$axios.get('index.php/url')
  .then(response => {
    console.log(response)
  }).catch(error => {
    console.log(error)
  });
```

然后设置自定义的头请求：

`axios.defaults.timeout = 5000;//请求超时的时间设定`

`axios.defaults.headers.post['Content-Type'] = 'application/json'; //axios默认的请求方式`

`axios.defaults.baseURL = 'http://localhost:8008';//axios默认的请求地址 `

`axios.defaults.headers.common["token"] = "noname";//有些接口必须登录才可以调用，而登陆注册并未写好，后台给了一个故固定的token，写在了头里面`



#### 6. vue使用的UI框架？

**animate.css**是一款前端动画库，相似的有velocity-animate；

（element ui框架的按钮组件；

​	iView 是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品

​	Vuetify.js根据材料设计规格提供 UI 布局；

​	基于 Vue.js 的 Bootstrap 组件；

​	cube-ui 是滴滴团队开发的基于 Vue.js 实现的精致移动端组件库；

​	vue-beauty 是一套基于 vue.js 和 ant-design样式 的PC端 UI 组件库；

​	AT-UI 是一个模块化的前端 UI 框架，基于Vue.js 的快速和强大的 Web 界面；专门为桌面应用程序构建；

​	Vue-Blu是基于Vue.js和Bulma开发的开源UI组件库。旨在为PC端的前端开发(特别是中后台产品)提供一个快速且灵活的解决方案。）

**使用步骤：**

1. **首先`npm install animate.css --save`；**
2. 然后在vue文件的script中**引入`import animate from 'animate.css'`；**
3. 最后**绑定元素使用**，如下：

```vue
<template>
    <div class="song">
        <p id="f" @click='fade'>hello</p>
    </div>
</template>
```

```javascript
methods:{
    fade:function(){
        $('#f').addClass('animated bounceOutLeft')
    }
}
```

部分api常见：

```javascript
	fade: {
        title: '淡入淡出',
        fadeIn: '淡入',
        fadeOut: '淡出',
      },
      bounce: {
        title: '弹跳类',
        bounceIn: '弹跳进入',
        bounceOut: '弹跳退出',
      },
      zoom: {
        title: '缩放类',
        zoomIn: '放大进入',
        zoomOut: '缩小退出',

      },
      rotate: {
        title: '旋转类',
        rotateIn: '顺时针旋转进入',
      },
      flip: {
        title: '翻转类',
      },
      strong: {
        title: '强调类',
        bounce: '弹跳',
        flash: '闪烁',
      }
```



#### 7.v-if和v-show之间的区别？

​	相同点：v-if与v-show都可以动态控制dom元素显示隐藏

​	不同点：

实现**本质方法**区别

- vue-show本质就是标签`display:为none;`，控制隐藏，DOM结构是一直存在的
- vue-if是动态的向DOM树内**添加或者删除DOM元素**

编译的区别

- v-show其实就是在**控制css**
- v-if切换有一个局部编译/卸载的过程，切换过程中合适地**销毁和重建内部的事件监听和子组件**

编译的条件

- v-show**都会编译**，初始值为false，只是将display设为none，但它也编译了
- v-if初始值为false，就不会编译了

性能

- v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故**v-show性能更好一点**。



#### 8.v-for中key值的作用？

​	key的作用主要是为了**高效的更新虚拟DOM**。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以**区分它们**，否则vue只会替换其内部属性而不会触发过渡效果。

​	在用v-for更新已渲染的元素列表的时候，会使用就地复用的策略；这就是说列表数据修改的时候，他会根据key值去判断某个值是否修改，如果修改了就重新渲染，不然就复用之前的元素。



#### 9.vue中插槽的作用？

​	插槽就是Vue实现的一套**内容分发的API**，将`<slot></slot>`元素作为承载分发内容的出口，没有插槽的情况下在组件标签内些一些内容是不起任何作用的。

​	插槽内可以是任意内容。在`<child-component>你好</child-component>`内放置一些内容，输出内容还是在组件中的内容，直接在父组件的` <child-component>`标签中定义的内容不会被渲染。**在子组件template中加入`<slot>`元素占位，便能渲染父组件`<child>`标签下的内容**。

​	**具名插槽**，当需要多个插槽时，可以使用`<slot>`的特性：name。这个特性可以用来定义额外的插槽。

```html
	<div id="root">
        <child>
            <header slot="header">header</header>
            <footer slot="footer">footer</footer>
        </child>
    </div>
```

```javascript
       Vue.component('child',{
            template:`<div>
                            <slot name="header">default header</slot>
                            <div>content</div>
                            <slot name="footer">default footer</slot>
                        </div>`
            }
        )
        var vm=new Vue({
            el:'#root'
        })
 //输出结果是 header   content   footer
```

​	**插槽默认内容** ，插槽可以提供一个默认内容，如果如果父组件没有为这个插槽提供了内容，会显示默认的内容。如果父组件为这个插槽提供了内容，则默认的内容会被替换掉。

​	**作用域插槽**，作用域插槽就是父组件在**调用子组件的时候给子组件传了一个插槽**，这个插槽为作用域插槽，该插槽必须放在template标签里面，同时声明从子组件接收的数据放在一个自定义属性内，并定义该数据的渲染方式。（解决的问题：调用了两次child组件，因为调用的是同一个子组件，所以显示的内容完全一样。如何在每次调用时能有各自的渲染效果？）

```html
	<div id="root">
        <child>
            <template slot-scope="props"><!--该插槽必须放在template标签内-->
                <li>{{props.value}}</li> <!--定义渲染方式-->
            </template>
        </child>
        <child>
            <template slot-scope="props">
                <h1>{{props.value}}</h1><!--定义渲染方式-->
            </template>
        </child>
    </div>
```

```javascript
Vue.component('child',{
            data: function(){
                return {
                    list:[1,2,3,4]
                }
            },
            template: `<div>
                            <ul>
                                <slot v-for="value in list" :value=value>//使用slot占位
                                </slot>
                            </ul>
                        </div>`
        })
        var vm=new Vue({
            el: '#root'
        })
```



#### 10.vue中watch和computed有什么区别？分别在哪种场合下使用？监听的是data里面的值吗？

| computed 计算属性                                            | watch 观察的动作                                            | methods                          |
| ------------------------------------------------------------ | ----------------------------------------------------------- | -------------------------------- |
| 数据会被缓存，只要依赖不发生改变，即使页面重新渲染，该方法就不会调用 | 直接监测一个值的变化，监测值不发生变化，该方法就不会调用    | 每次页面发生渲染，都会被重新调用 |
|                                                              | 监听复杂数据类型需用深度监听（在被监听对象中使用`handler`） |                                  |



#### 11.数据请求应该添加在生命周期的哪里？

​	看实际情况，一般在 created（或beforeRouter） 里面就可以，如果涉及到需要页面加载完成之后的话就用 mounted。主要的区分在于**是否需要操作DOM结构**。
​	1.在created的时候，视图中的html并没有渲染出来，所以此时如果直接去操作html的dom节点，一定找不到相关的元素；
​	2.而在mounted中，由于此时html已经渲染出来了，所以可以直接操作dom节点，（此时document.getelementById 即可生效了）；