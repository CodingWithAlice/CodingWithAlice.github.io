---
layout:     post
title:      面试题整理（较深）
subtitle:  
date:       2019-07-09
author:     
header-img: 
catalog: true
tags:
    - < 面试题整理 >
typora-root-url: ..
---

# 面试题整理（较深）



1. 大致讲一下ES6新特性；
2. Canvas绘图；
3. Node.js；
4. Webpack；
5. html中首行<!doctype>的作用？
6. css中的动画特性可以用js实现，那为什么还要用css来实现？
7. Ajax遇到拦截器，请求数据要重新处理怎么做？
8. bootstrap中的栏栅一行有24个，是怎么做到的？
9. 轮播图实现的时候是怎么考虑的？
10. git的使用，常用操作代码有哪些？
11. 简单说一下get和post区别？
12. h5的新特性、css3的新特性简单说一下？
13. SEO搜索引擎优化？
14. const定义的对象能够被改变？为什么？
15. let和var在全局定义的时候有什么区别？
16. 三大事件冒泡、捕获是怎么执行的？



详解：

### 1. 大致讲一下ES6新特性；

① **箭头函数**；

② 增加了对类的**支持class关键字**；继承：`class Programmer extends Animal`

③ 增强了**对象字面量**：可以在对象字面量里面**定义原型**

` __proto__: human, //设置此对象的原型为human,相当于继承human ` ；

定义方法**可以不用function关键字**

` work() {console.log('working...'); } `；

④ **字符串模板**：反引号 ` 来创建字符串；

⑤ **解构**：[name,age]=[Alice,'male','secrect'];//数组解构；

⑥ 参数默认值，不定参数，拓展参数：

​	**参数默认值**：在定义函数的时候指定参数的默认值

```javascript
function sayHello2(name='dude'){
	console.log(`Hello ${name}`);
}
```

​	**不定参数**：在函数中使用命名参数同时接收不定数量的未命名参数，**三个句点后跟代表所有不定参数的变量名**。

```javascript
function add(...x){
	return x.reduce((m,n)=>m+n);
}
```

​	**拓展参数**：允许传递数组或者类数组直接做为函数的参数而不用通过apply。

```javascript
var people=['Wayou','John','Sherlock'];
sayHello(...people);//输出：Hello Wayou,John,Sherlock
```

⑦ `let` 与`const`关键字

⑧ `for of `值遍历：for in 循环用于遍历数组，类数组或对象，for of循环功能相似，不同的是每次循环它**提供的不是序号而是值**。

⑨ iterator, generator：iterator拥有一个next方法；generator是一种特殊的iterator，通过function*来声明的，**yield 关键字**可以暂停函数的执行，随后可以再进进入函数继续执行。

⑩ **模块module**

```javascript
// point.js
module "point" {
    export class Point {
        constructor (x, y) {
            public x = x;
            public y = y;
        } 
    }
}

// myapp.js
module point from "/point.js";	//声明引用的模块
import Point from "point";		//可以看出，尽管声明了引用的模块，还是可以通过指定需要的部分进行导入
var origin = new Point(0, 0);
console.log(origin);
```

① **Map，Set 和 WeakMap，WeakSet**：提供了更加方便的获取属性值的方法，不用像以前一样用hasOwnProperty来检查某个属性是属于原型链上还是当前对象的。同时，在进行属性值添加与获取时有专门的get，set 方法。WeakMap,WeakSet更加安全，作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉。

② Proxies：**监听对象**身上发生了什么事情，并在这些事情发生后执行一些相应的操作。

③ Symbols：是一种基本类型，不是一个对象。可以用symbol这种值来做为对象的键。

④ Math，Number，String，Object 的新API；

⑤ Promises：**处理异步操作的一种模式**，then()

### 2. Canvas绘图；

### 3.Node.js；

### 4.Webpack；

### 5.html中首行<!doctype>的作用？

​	**文档类型声明**，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档；声明必须是HTML文档的第一行，位于html标签之前；

### 6.css中的动画特性可以用js实现，那为什么还要用css来实现？

​	当您为 UI 元素采用较小的独立状态时，使用 CSS。 CSS 变换和动画非常适合于从侧面引入导航菜单，或显示工具提示。最后，可以使用 JavaScript 来控制状态，但动画本身是采用 CSS。**用CSS制作动画是让元素在屏幕上移动的最简单方法**。

​	**在需要对动画进行大量控制时，使用 JavaScript**。 Web Animations API 是一个基于标准的方法，现已在 Chrome 和 Opera 中提供。该方法可提供实际对象，非常适合复杂的对象导向型应用。在需要停止、暂停、减速或倒退时，JavaScript 也非常有用。

**那么如何从两者中抉择？**

​	根据 Google Developer，**渲染线程分为 主线程 (main thread) 和 合成线程 (compositor thread)**。如果 CSS 动画**只是改变` transforms` 和` opacity`，这时整个 CSS 动画得以在 合成线程 完成（而JS动画则会在 主线程 执行**，然后触发合成线程进行下一步操作），在 JS 执行一些昂贵的任务时，主线程繁忙，CSS 动画由于使用了合成线程可以保持流畅。

​	在许多情况下，也可以由合成线程来处理 transforms 和 opacity 属性值的更改。

​	对于帧速表现不好的低版本浏览器，**CSS3可以做到自然降级，而JS则需要撰写额外代码**。

​	CSS动画**有天然事件支持**（TransitionEnd、AnimationEnd，但是它们都需要针对浏览器加前缀），**JS则需要自己写事件**。

​	如果有任何**动画触发绘画，布局或两者，则需要 “主线程” 才能完成工作。** 这对于基于 CSS 和 JavaScript 的动画都是如此，布局或绘制的开销可能会使与 CSS 或 JavaScript 执行相关的任何工作相形见绌，这使得问题没有实际意义。

​	**CSS3有兼容性问题，而JS大多时候没有兼容性问题。**

### 7.Ajax遇到拦截器，请求数据要重新处理怎么做？



### 8.bootstrap中的栏栅一行有12个，是怎么做到的？

​	总共有**五个栅格等级**，每个响应式分界点隔出一个等级：特小`.col-`、小`.col-sm-`、中 `.col-md-`、大`.col-lg-`、特大`.col-xl-`。

​	使用的row行必须包裹在`container`和`container-fluid`下，外部容器一个是`container`，一个是`container-fluid`，第一个**`container`是固定宽度，居中在网页中间**，第二个**`container-fluid`是百分比宽度，宽度为100%**，根据情况我们可以选择不同的容器。

![](/img/assets_2019/container.png)

**工作原理**：

​	栅格系统提供了**内容居中**、**水平填充**网页内容的方法，`.container`实现固定的宽度并居中呈现，`.container-fluid`实现全宽度，并和其它网格实现对齐。

​	行(.row)是列(.col-*)的横向组合和父容器，**每列都有水平的padding值**，用于控制列与列之间的间隔，同时在负边距的行上抵消，从而实现列中的所有内容在视觉上是左侧对齐的体验。

​	.row上带有`margin-left: -15px;margin-right: -15px;`属性，你可以在.row上上定义`.no-gutters`属性，从而消除这个属性，使页面不会**额外宽出30px**，即`<div class="row no-gutters"...`。

​	`.col-*`的`width`属性(即列宽)是**用百分比来表现**和定义的，所以它们总是流式的，其尺寸大小受父元素的定义影响。

|                                    | 超小屏幕（新增规格）<576px | 小屏幕  次小屏≥576px | 中等屏幕  窄屏≥768px | 大屏幕  桌面显示器≥992px | 超大桌面  大桌面显示器≥1200px |
| ---------------------------------- | -------------------------- | -------------------- | -------------------- | ------------------------ | ----------------------------- |
| container最大宽度                  | None（auto）               | 540px                | 720px                | 960px                    | 1140px                        |
| 类前缀                             | \.col\-                    | \.col\-sm\-          | \.col\-md\-          | \.col\-lg\-              | \.col\-xl\-                   |
| 列数                               | 12列                       | 12列                 | 12列                 | 12列                     | 12列                          |
| Gutter width（都是每列两侧各15px） | 30px                       | 30px                 | 30px                 | 30px                     | 30px                          |
| 列间隙（都是每列两侧各15px）       | 30px                       | 30px                 | 30px                 | 30px                     | 30px                          |
| 都可嵌套、可排序                   |                            |                      |                      |                          |                               |



### 9.轮播图实现的时候是怎么考虑的？

四种方式实现：

​	swiper插件实现轮播图；

​	JS实现轮播图；

​	jQuery实现轮播图；

​	css3实现轮播图；

```javascript
		// 1. 克隆元素
        ul.appendChild(ul.children[0].cloneNode(true));
        // 2.创建ol 和li
        var ol = document.createElement("ol");//创建ol元素
        scroll.appendChild(ol);// 把ol放到scroll盒子里面去
        for (var i=0;i<ulList.length-1;i++) {
            var li = document.createElement("li");// 创建li元素
            li.innerHTML = i + 1;// 给li里面添加文字  1 2 3 4 5
            ol.appendChild(li);// 将li元素添加到ol里面
        }
        ol.children[0].className = "current";
// ol中的第一个li背景色为purple现无缝滚动就需要多一张图片才行，即克隆第一张图片，放到最后面
```

```javascript
//动画函数：
		// 动画函数的第一个参数，代表动画对象；第二个参数代表动量
        // 让图片做匀速运动，匀速动画的原理是:当前的位置 + 速度,即 offsetLeft + speed
        function animate(obj,target){
            // 首先清除掉定时器
            clearInterval(obj.timer);
            // 用来判断 是+ 还是 -  即说明向左走还是向右走
            var speed = obj.offsetLeft < target ? 15 : -15;
            obj.timer = setInterval(function(){
                var result = target - obj.offsetLeft;//它们的差值不会超过speed
                obj.style.left = obj.offsetLeft + speed + "px";
                // 有可能有小数的存在，所以在这里要做个判断             
                if (Math.abs(result) <= Math.abs(speed)) {
                    clearInterval(obj.timer);
                    obj.style.left = target + "px";
                }
            },10);
        }
```

```javascript
//定时器函数：
		var timer = null; 	// 轮播图的定时器
        var key = 0;		// 控制播放的张数
        var circle = 0;		// 控制小圆点

        timer = setInterval(autoplay,1000);// 自动轮播
        function autoplay(){
/*自动轮播时,要对播放的张数key进行一个判断,如果播放的张数超过ulLis.length-1,就要重头开始播放.  
		因为我们克隆了第一张并将其放在最后面,所以我们要从第二张图片开始播放*/
            key++; 						// 先++
            if(key > ulLis.length-1){	// 后判断
                ul.style.left = 0; 		// 迅速调回
                key = 1; 				// 因为第6张是第一张，所以播放的时候是从第2张开始播放
            }
// 动画部分
            animate(ul,-key*liWidth);

// 小圆点circle，当显示第几张图片是，对应的小圆点的颜色也发生变化 
            /*同理,对小圆点也要有一个判断*/
            circle++;
            if (circle > olLis.length-1) {
                circle = 0;
            }
            // 小圆点颜色发生变化
            for (var i = 0 ; i < olLis.length;i++) {
                // 先清除掉所用的小圆点类名
                olLis[i].className = ""; 
            }
            // 给当前的小圆点 添加一个类名
            olLis[circle].className = "current";

        }
```



### 10.git的使用，常用操作代码有哪些？



### 11.简单说一下get和post区别？



### 12.h5的新特性、css3的新特性简单说一下？



### 13.SEO搜索引擎优化？



### 14.const定义的对象能够被改变？为什么？



### 15.let和var在全局定义的时候有什么区别？



### 16.三大事件冒泡、捕获是怎么执行的？

**先捕获再冒泡**

事件冒泡的概念下在p元素上发生click事件的顺序应该是**p -> div -> body -> html -> document**；

事件捕获的概念下在p元素上发生click事件的顺序应该是**document -> html -> body -> div -> p**；