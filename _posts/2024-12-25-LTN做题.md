---
layout:     post
title:     Vuex
subtitle:  
date:       2021-10-01
author:     
header-img: 
catalog: true
tags:
    - < vue相关知识点 >
typora-root-url: ..
---

# LTN做题

> LTN ①②

2024.12.25 做LTN2 - 117min

✅作业3：迭代器原理
❌作业25：简单写下 请求创建过程
✅作业41：TED 如何解决焦虑
❌作业49：牛顿三大定律、热力学两大定律
❌ 作业54：举杯邀明月，对影成三人。的上一句
❌LTN2.1 显示省略号
✅LTN2.2 position属性 - 都是什么占位？相对于什么定位
❌LTN2.3 HTTP/2特性
✅LTN2.4 红宝书19章
✅LTN2.5 红宝书18章
❌LTN2.6 模块化
❌LTN2.7 包管理工具
✅LTN2.8 给定时间切换状态
❌LTN2.9 数组去重
✅LTN2.10 数组乱序 洗牌算法

```js
// LTN2.10 数组乱序 洗牌算法
// 从最后一个元素开始，从数组中随机选出一个位置，交换，直到第一个元素。
function chaos(arr) {
    const length = arr.length;
    for(let i = length -1 ; i >= 0; i--){
		let random = Math.floor(Math.random()*length);
        [arr[random], arr[i]] = [arr[i], arr[random]]
    }
    return arr
}
// while 循环来写
function chaos(arr) {
	let cur = arr.length - 1;
    while(cur >= 0) {
        let random = Math.floor(Math.random()*arr.length);
        [arr[random], arr[i]] = [arr[i], arr[random]];
        cur --;
    }
    return arr
}
```

```js
// LTN2.9 数组去重  // ⭐️ 125最重要，其实 4 和 5 是一个逻辑， 3 和 2 很像
1、new Set([...arr]) // ❌ [...new Set(arr)] Array.from(new Set(arr))
2、arr.filter((it, index) => arr.indexOf(it) === index);
5、function unique(arr){
    let hash = {};
	return arr.filter(it => hash[it] ? false :  hash[it] = true)
}
3、function unique(arr) {
    return arr.reduce((pre, cur) => {
        if(!pre.includes[cur]) {
            pre.push(cur);
        }
        return pre;
    }, [])
}
4、function unique(arr) {
	let hash = {};
    let res = [];
    arr.forEach(it => {
        if(!hash[it]) {
            res.push(it);
            hash[it] = true;
        }
    })
    return res
}
```

```js
// LTN2.8 给定时间切换状态
async function (promise, time) {
    const timePro = new Promise((resolve, reject) => { setTimout(reject, time, new Error('time out!')) });
	return await Promise.race([promise, timePro])
}
```

```js
// LTN2.7 包管理工具
npm：
	将依赖提升、拍平存储在node_modules；7.x有针对peer dependencies的break change；package-lock.json(npm>5) + .npmrc
yarn v1/classic：
	将依赖提升、拍平存储在node_modules;针对早期npm优化，可以并行加载多个依赖；yarn.lock + .yarnrc
pnpm：❌ // 「不是pnpm.yml，而是 pnpm-lock.yml」
	保留结构化的node_modules，采用内容寻址存储，只物理存储一次，节省空间；pnpm.yml + .npmrc
yarn v2/Berry： // ⭐️「即插即用」
	不再使用node_modules，使用依赖查找表 .pnp.cjs 和 /.yarn/cache 存储 zip文件；yarn.lock + .yarnrc.yml
```

```js
// LTN2.6 模块化
CommonJS：同步加载，适用于服务器端，输出的是值的拷贝，运行时加载，require + exports
AMD：异步加载，可以并行加载多个模块，依赖前置 define(['a.js', 'b.js'], function (a, b) {})
❌ // 少写了 ：加载模块后直接执行，无法保证执行顺序
CMD：异步加载，可以并行加载多个模块，依赖就近 define(function(require, exports, module){
    let a = require('a.js'); a.callback();
})
❌ // 少写了 ：加载后，直到调用才按需执行
ES6模块化：异步加载，是客户端和服务端的通用解决方案，输出的是值的引用，编译时加载， import as from default export
```

```js
// LTN2.3 HTTP/2特性
和HTTP/1.1相比，语义层面完全兼容，语法层面大力改造
1、压缩头部信息，采用 HPACK 字典表算法
2、不再使用纯文本传送，而是二进制帧 - 双向传输序列 - 形成虚拟的流，在一个连接上可以处理多个请求响应（多路复用），多个请求响应之间没有了顺序，解决了队头阻塞
3、设置请求优先级
4、采用HTTPS
❌  // 少写一个 5、服务器推送
```

```js
// LTN2.2 position属性 - 都是什么占位？相对于什么定位
static - 标准文档流，占位
relative - 标准文档流，占位，相对定位 // ⭐️「相对自己本身的定位」
absolute - 脱离文档流，绝对定位，相对于上一个 position 非 static 的父级元素
fixed - 脱离文档流，粘性定位，相对视口
sticky - 原本是标准文档流，超过一个阈值后，变成 fixed
```

```js
// LTN2.1 显示省略号
.line {
    overflow: hidden;
	white-space: nowrap;
    text-overflow: ellipsis;
}
.lines {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-direction: vertical; ❌ // 『不是 direction 是 orient: -webkit-box-orient: vertical;』
    -webkit-line-clamp: 3;
    // 解决 padding 带来的露出问题
    line-height: 30px;
    height: 90 - padding距离;
}
```


```js
// 作业54：举杯邀明月，对影成三人。的上一句
起舞弄清影，独酌无相亲 ❌ 『花间一壶酒，独酌无相亲』
```

```js
// 作业49：牛顿三大定律、热力学两大定律
 + 加速度 a=F/m + 作用力与反作用力 ❌ 『惯性定律』
能量守恒 + 熵增定律
```

```js
// 作业41：TED 如何解决焦虑
1、do it badly - anything worth doing worth doing badly the first time
2、给自己一些同情，我们都不会和一个天天批评自己的朋友长久交往 - 你也不要做自己这样的朋友
3、找到意义 - 即使别人不知道，自己一定要认可自己做得事情，觉得有价值

- 如何停止过度思考 - 
“思考”和抽烟、喝酒一样，是一件上瘾行为 - 想要不上瘾，就是允许念头在脑中出现，get it then let it go
不跟着念头走，回到当下
焦虑是一种对失败的恐惧 - 写下可能导致自己失败的事情 - 每个失败的可能都找到应对方案，do it
```

```js
// 作业25：简单写下 请求创建过程
function require(url) {
    let  xhr = new XMLHttpRequest(); // 1、实例 ⭐️「使用const」
    // 2、回调
    xhr.onerror = () => {};
    xhr.ontimeout = () => {};
    xhr.onreadyStateChange = function (res) { // ⭐️「原生函数全小写字母 onreadystatechange」
        switch(res.readyState) {
            case 0: // 未开始
                break;
            case 4:
                if(this.status === 200 || this.status === 304) {
                    console.log(this.responseText);
                }
                break; // ⭐️「记得写 break」
        }
    }
    // 3、创建
    xhr.open(url, 'GET', true); // true 表示异步 ❌ 『xhr.open('GET', url, true)』
    // 4、属性设置
    xhr.timeout = 3000;
    xhr.responseType = 'text';
    xhr.setRequestHeader(key, value);
    // 5、发送请求
    xhr.send();
}
```

```js
// 作业3：迭代器原理
迭代器：调用 next() 将可迭代对象的值一一返回，不用关注对象类型，只要是可迭代对象都有默认迭代器 [Symbol.iterator]
```

2024.12.25 先做LTN4 - 62min

✅作业1：写一个只能被迭代指定次数的类
✅作业7：原始值包装类型和原始类型在使用 typeof 和 instanceof 进行类型判断时，有什么异同？
✅作业9：数组自带排序 sort() 为什么经常要传比较函数？写一个降序的比较函数。如果数组元素全是数值，请给出简写形式
✅作业11：写出一个用 yield 实现的递归算法，从0数到指定n
✅作业12：画出一个原型链，到 null 为止
✅作业8：ES6新增了两个创建数组的静态方法：Array.from()和Array.of()两个有什么区别？
✅作业10：说出WeakMap/WeakSet和Map、Set的区别，为什么有这两个弱类型，经常用在什么场景
❌作业16（2）：arguments 对象对待命名参数和设置了默认值的命名参数有什么不同？数组作为参数传入函数得到的arguments 是什么？怎么实现arguments是数组？怎么收集独立参数？在对象字面量和数组字面量中，扩展运算符有什么不同的表现？

````js
// 作业16（2）：arguments 对象对待命名参数和设置了默认值的命名参数有什么不同？数组作为参数传入函数得到的arguments 是什么？怎么实现arguments是数组？怎么收集独立参数？在对象字面量和数组字面量中，扩展运算符有什么不同的表现？
arguments 默认同步命名参数，比如在函数内修改了 arguments[0]，如果对应的是命名参数，那么值会同步
但是 arguments 不同步设置了默认值的命名参数
数组作为参数 - arguments:[1,2,3]❌『[[1,2,3]]』
可以用扩展运算符转换 (...arr)
收集独立参数 (first, second, ...rest) -> rest 是一个数组 只能作为最后一项收集
扩展运算符 - 对象字面量 {...obj} 浅拷贝对象中所有实例属性❌『创建一个新对象，并复制所有可枚举属性』
扩展运算符 - 数组字面量 [...obj] 将可迭代对象一一返回
````

```js
// 作业10：说出WeakMap/WeakSet和Map、Set的区别，为什么有这两个弱类型，经常用在什么场景
WeakMap/WeakSet 分别是 Map、Set 的弱类型，特点是键/值只能是对象类型，并且在对象是空对象，没有引用时，垃圾回收程序会清理当前弱类型
目的：避免内存泄漏
场景：比如监听 DOM 节点，如果节点被删除，弱类型会被清理
```

```js
// 作业8：ES6新增了两个创建数组的静态方法：Array.from()和Array.of()两个有什么区别？
Array.from() - 用于将类数组(arguments+Nodelist)/可迭代对象转换成数组类型，浅拷贝
Array.of() - 用于将一连串参数转换成数组类型，主要用于替代 Array.prototype.slice.call(arguments)
```

```js
// 作业12：画出一个原型链，到 null 为止
function Person() {}
let person = new Person();
person.__proto__ === Person.prototype

Person.prototype.constructor === Person
Person.prototype.__proto__ === Object.prototype

Object.prototype.constructor === Object
Object.prototype.__proto__ === null
```

```js
// 作业11：写出一个用 yield 实现的递归算法，从0数到指定n
function * nTimes(n) {
    if(n>0) {
        yield* nTimes(n-1);
        yield (n-1);
    }
}
```

```js
// 作业9：数组自带排序 sort() 为什么经常要传比较函数？写一个降序的比较函数。如果数组元素全是数值，请给出简写形式
sort函数会把数组中的值转换成字符串后比较，比如排序后会出现 [1,10,15,3,5]
// 降序
[].sort((a,b) => {
    return a > b ? -1 : a < b ? 1 : 0
})
// 简写
[].sort((a, b) => b - a)
```

```js
// 作业7：原始值包装类型和原始类型在使用 typeof 和 instanceof 进行类型判断时，有什么异同？
String Boolean Number
原始类型-使用 typeof v 可以得到具体类型的字符串 VS 使用 v instanceof S/B/N 都是 false
原始值包装类型 - 使用 typeof v 得到 'object'  VS  v instanceof S/B/N 得到 true
typeof 用于判断基础数据类型（null array object 都是 'object'，函数是 'function'）
instanceof 在对象的原型链上查找是否有指定构造函数的原型对象 [Symbol.hasinstance]
```

```js
// 作业1：写一个只能被迭代指定次数的类
class nTimes{
    constructor(n) {
        this.limit = n;
    }
    [Symbol.iterator](){
        let max = this.limit;
        let times = 0;
        return {
            next() {
                if(times < max) {
                    return {value: times++, done: false};
                } else {
                    return {value: undefined, done: true};
                }
            }
            return() {
                return {value: undefined, done: true}
            }
        }
    }
}
// 答题核心：迭代器返回的是迭代器对象(包含next()、return()) + next 返回一个 done+value组成的对象
```



