---
layout:     post
title:     LTN做题
subtitle:  
date:       2021-10-01
author:     
header-img: 
catalog: true
tags:
    - < LTN1 >
typora-root-url: ..
---

# LTN做题

> LTN ①② 错题重做
>
> （错题重做，做对了不记录，记录二次错）

```js
// 作业55：flex 常见缩写
- 第一遍 -
flex: 0; // 0 0 auto ❌ 「缩写其实是 flex: none;」
flex: 1; // 1 1 0
flex: auto; // 1 1 auto
flex: initial; // 0 1 auto
- 第二遍 -
// 所以我错的不是缩写不清晰，是每次 0 0 auto 的简写是 none ，而我写成 0 
flex: 0; // 0 0 auto ❌❌ 「缩写其实是 flex: none;」
flex: initial; // 0 1 auto
flex: 1; // 1 1 0 
flex: auto; // 1 1 auto
```

```js
// 作业59：什么是高阶函数?什么是高阶组件？什么是副作用？简单举例
- 第一遍 -
高阶函数 - 输入参数是函数的函数 arr.map(it => +it)，map 就是高阶函数
❌ // 高阶函数 - 以函数作为【输入或者输出】的函数
高阶组件 - 输入参数是组件的组件，做一些包装，可以统一添加监控、报错等功能
❌ // 高阶组件 - 接收组件作为参数，并返回一个新组件 
// - 常用于1、包装一层功能2、属性代理/组合3、动态行为添加
副作用 - 除了返回值，在函数执行过程中会影响其他值、IO等
❌ // 副作用是函数式编程的概念 - 除了函数的返回值外，还对外部环境产生了影响(例如：1、修改全局变量 2、改变输入参数 3、进行IO操作等)
高阶函数-权限校验示例：
class Wrap extends React.Component {
    constructor(props) {
        super();
    }
    render() {
        return <div>{props}</div>
    }
} // 写法是对的，但是传入的 props 不是明确的组件 ❌

- 第二遍 -
高阶函数就是输入输出的参数是函数。最常见的就是map。
高阶组件就是输入的参数也是组件。
副作用是函数式编程当中的说法，含义是除了return的返回值。在函数当中还会影响到外部值，比如说传入的参数，全局变量。Io下载等
const my = (MyComponents, requiredType) => {
    return class extends React.Component {
        constructor(props) {
            super(props);
            this.state = { permit: false }
        }
        // ❌❌ 1、这里少写了一个 componentDidMount 用于初始化的时候计算 state 中的值
        componentDidMount() {
            const myPermit = check('id'); // 查询
            this.setState({ permit: myPermit === requiredType })
        }
        render() {
            if(this.state.permit) {
                return this.props.children;
                // ❌❌ 2、子组件作为参数传入了  return <MyComponents {...this.props} />
            } else {
                return <div> Error. </div>
            }
        }
    }
}
```

```js
// 作业62：fiber架构优点？ 是怎么实现的？
- 第一遍 -
fiber 是为了解决CPU瓶颈 - 连续的 js 执行会占用主线程，导致渲染阻塞，低于60帧/秒出现卡顿
❌ // 1、不是「连续的 js 执行」会长时间占用主线程，是「React递归构建整颗 DOM 树、比较、更新」
❌ // 2、明确 React 由于每次构建的都是整颗树 + 之前是同步渲染 - fiber 做到了异步渲染
优点：时间分片 + 优先级调度
	1、将React的代码执行分成很多小模块，在帧和帧之间的小间隙里面，检测时间是否充足用于执行模块 - 不会占据很长时间的主线程，不影响渲染
	❌ // 3、分成小模块的自然也不只是「代码执行」，是「渲染工作」被分解成了「小任务单元」 + 同时可以「暂停 + 恢复」 -> 使得 在每帧开始前检查剩余时间，能否执行的也就是「小渲染任务单元」
	2、标记优先级，如果遇到用户交互，则优先处理，提高渲染效率和用户体验
    ❌ // 4、少写了：渐进式渲染
    
❌ // 上述写的都是原理，并不是具体实现 1、双缓存机制 current tree 和 work-in-progress tree 2、任务调度和优先级管理 3、Diff 算法优化为增量式 Diff

- 第二遍 -
Fiber架构分为三个部分
第一个是schedule调度器，在整个渲染流程当中不直接参与渲染，但作为总把控。
⭐️ // 主要用于优先级调度，宏观调控
第二个是 Reconciler ，对应的是render阶段。
上述两个部分都是异步执行的，随时会被以下几种情况打断1️⃣错误2️⃣更高优先级的任务，比如用户交互。3️⃣时间分片时间不够。
第三个是render。对应的是commit阶段。
这个部分是同步无法被打断，直到渲染到真实页面的dom。

优点
1.在Fiber架构出现以前，react的渲染更新流程是同步执行的。耗时比较久会阻塞。页面渲染性能差。
通过fiber实现了时间分片和优先级调度。拥有了暂停和恢复执行渲染任务的能力，将整个渲染任务拆分成了很多小的渲染单元，在针和针的渲染间隙进行执行，尽可能不影响渲染帧的执行。
2.同时优先级调度任务可以让react优先处理和用户的交互。将一些没那么重要的渲染任务稍后执行，例如不再是口中的画面的图块处理。
⭐️ // 总结：「渐进式渲染」、「暂停恢复渲染能力」、「优先级调度」、「时间分片管理」

1.双fiber node的虚拟dom树 
2.优先级调度器，对任务进行统一调度。
⭐️ // 「优先级调度器」其实是两样，「任务调度」 + 「优先级管理」
3.模拟了生成器和yield。有了暂停和恢复渲染任务的能力。
❌❌ // 1、这里缺少一个 Diff 算法的执行优化：增量式 
4.在每次渲染之前都会调用 shouldYield 判断当前是否拥有足够多的时间处理小的渲染单元任务。
⭐️ // 这里就是时间分片的原理
```

```js
// 作业63：React渲染怎么实现的
- 第一遍 -
❌ // 1、「componentDidMount、componentDidUpdate」 都在「commit 阶段-修改更新到真实 DOM 后」执行，还有少写了：「componentWillUnMount、useLayoutEffect、ref引用」也在这个时机是执行
JSX 描述 UI
1、render：componentDidMount
❌ // 2、还有几个生命周期在「render 阶段」执行：「shouldComponentUpdate + 所有状态相关的 hooks（例如 useState、useMemo、useCallback等）」
❌ // 4、 需要描述下 render 的「主要任务」 - 可以作为记忆的纲要：①构建新的Fiber树②存储 hooks③副作用的收集和标记④Diff
	① 创建 FiberHostNode 作为实例
❌ // 5、先创建「FiberRootNode 作为根节点」，再创建「HostRootFiber 作为起始点」，也就是根节点存储的当前树 WIP tree - FiberRootNode.current
    ② DFS 遍历：类组件-执行 render 函数/函数组件 - 编译成 FiberNode tree [hooks链表的第一个存储在 memoriesState]
❌ // 6、没有在这里执行 render 函数/函数组件，它们俩的执行时机是渲染之前-它们的执行就是重新渲染的时机
❌ // 7、「生成 WIP tree 的过程」其实是：执行「beginWork」-通过wip.tag来不同类型元素生成 fiberNode；遍历到叶子节点的时候，执行「completeWork」构建出 tree + flags 冒泡
❌ // 8、在此期间， 为「每个FiberNode，存储 hooks 链表」(memorizedSate) ，而不是整颗 tree
2、pre-commit：componentDidUpdate
❌ // 3、没有 pre-commit 阶段
	③ 执行过程中，标记 flag 收集副作用链表 side-effects-list/EffectFalgs
❌ // 9、对，但是「标记 flag 收集副作用链表」是两件事，一个是对有副作用需要「在更新阶段执行」的节点进行标记 fiberNode.subtreeFlags，另一个是在 fiberNode.updateQueue「构建 side-effects-list 用于收集副作用链表」
	④ 执行完副作用列表后，得到 WIP tree，将 FiberHostNode.current 切换到 WIP tree
❌ // 10、不是在这里执行的副作用列表(在commit更新DOM后执行)，也不是在这里切换指针(commit全部完成后)
❌ // 12、render 阶段的最后，进行「Diff 比较」
3、commit-Diff
❌ // 11、Diff 在 render 阶段
❌ // 17、描述 commit 阶段的主要任务：「将更新应用到真实DOM，同步执行，不可中断 + 执行副作用、类组件生命周期」
❌ // 18、这个 commit 阶段涉及的生命周期 如 第1条 错误所示
	⑤ 将 current tree(和真实DOM对应的) 和 WIP 树进行对比，将计算后的 更新 应用到真实 DOM
❌ // 19、这里前面描述的是 Diff，应用到真实 DOM 之后，还有两个步骤：①「执行生命周期」 ②「commit 工作都完成后，切换 FiberRootNode.current 指向 WIP 树」
Diff 算法 - 增量式更新：
❌ // 13、描述不对，Diff 算法主要是「找出最小更新量」来更新真实 DOM
	1、分层遍历，对比标签是否一致，一致则复用标签修改属性；不一致则标记重新渲染（删除重建）
    ❌ // 14、少描述了：「先对比根节点，再遍历子节点」，之后才是具体的「同层比较」
    2、生成 FiberNode 描述的增量修改 UI，可以根据优先级调度和时间分片，逐步渲染，提高 diff 效率
    ❌ // 15、这里的「增量式」描述是 fiber 架构在 commit 阶段做的事情
    ❌ // 16、提高 diff 效率 - 实际上对应的 Diff 操作是「对于列表组件，使用 key 从新老树中匹配对应节点比较」

- 第二遍 -
❌❌ // 3、在 render 之前，运行时就会执行 JIT 先将 JSX 描述的 UI 编译为 React createElement 方法
1.render ：创建一颗完整的Fibernode的虚拟树 + diff
❌❌ // 1、中间少写了两个关键步骤：存储 hooks + 标记、收集副作用链表
-创建FiberRootnode，然后再创建hostfibernode，作为起点深度遍历按照标签的所属类型转换成对应的fibernode
❌❌ // 2、创建 FiberRootNode 后，创建 fiber 作为 HostRootFiber，也就是 FiberRootNode.current
-核心就是通过react.createelement创建。React element类型。
❌❌ // 4、以单个组件为例，fiberNode 存储 hooks，按序执行时标记、收集副作用链表
-diff 计算最小更新量
2.commit 将计算出来的最小更新量，UI更新到真实dom上 + 执行相关生命周期和副作用列表（hooks不在这边执行，hooks不作为单独的流程执行。）
❌❌ // 5、更新时会重新调用渲染函数，按序执行所有 hooks，所以也算是流程的一部分
3.将fiberrootnode.current指向新的fiberNode的树
```

```js
// 作业64：Vue渲染怎么实现的？
- 第一遍 -
1、render
❌ // 1、整个渲染「不止是 render + patch」，应该分成4步，①html：先「模版编译，得到render函数」 ②js：「实例化组件，同时收集依赖」(也就是数据双向绑定-实现响应式数据) ③html+js：「执行渲染函数/更新，得到 VDOM」 ④Diff/patch：「计算最小更新，应用到真实 DOM」
主要任务：生成新的 VDOM 树
相关生命周期：created、beforeMounted
❌ // 2、Vue 的生命周期很难罗列，这里模版编译前，js 都没执行到，怎么会有生命周期
①模版语法，静态编译 AOT 优化，标记静态节点
❌ // 3、这里就是第一步：「模版编译，生成render函数」
// 分三步：①parse - 递归解析 template(词法/语法分析)，「转换成AST」抽象语法树
// ②optimize - 对AST静态内容优化，「标记静态节点」 ③generate - 递归「转换AST，创建render字符串」
②DFS遍历，发布订阅模式+双向数据绑定 - 在 Dep 收集相关的 Watcher，更新时通知这些订阅的 Watcher
❌ // 4、这里说得很粗糙，还少了「实例化组件」来触发，第二步：「实例化组件+创建响应式数据」 - 也就是「数据双向绑定」，是通过「数据劫持」和「发布订阅」模式相结合实现的 - Object.defineProperty/Proxy 劫持重新定义 getter和setter
❌ // 5、没说 Dep 是怎么收集依赖的：在创建 Watcher 访问 getter 时，把当前正在计算的Watcher订阅到 Dep
❌ // 6、没说怎么触发更新：setter 被触发，通知 Dep 中的所有订阅者 - dep.notify()
❌ // 7、数据双向绑定也有缺点：Vue2使用的 Object.defineProperty 在递归处理 data 中的属性时，必须要指定具体属性，所以不在 data 中声明的对象无法拥有双向绑定 - Vue3 改为 Proxy 劫持
③生成 VDOM
❌ // 8、这是第三步，没有说清楚怎么生成 VDOM：执行渲染函数（更新时重新计算/执行渲染函数），得到 VDOM
2、patch
主要任务：利用 Diff 算法，计算出需要更新的UI + 将更新应用到真实DOM上
相关生命周期：Mounted 
❌ // 9、这里 patch 后，VDOM 已经更新到真实 DOM，除了 mounted，updated 也会在更新后在此执行
Diff 算法：两棵树，每棵各双指针，进行往复的节点比较，找到最小更新量
❌ // 10、Diff 比较的是新旧两棵 VDOM树

- 第二遍 -
1.模板编译 将模板编译成render函数。执行的步骤分别是 parse optimize render
❌❌ // 1、执行步骤的最后一步是 generate
// 三个步骤分别作用（AOT参与全程）：① parse 词法解析+语法解析 template 得到 AST ② optimize 对AST静态内容优化 ③ generate 递归转换 AST 得到 render 函数

2.先通过AOT进行预编译标记静态节点。拿到可编译文件后对代码进行语法分析，词法分析转换为抽象语法树AST
❌❌ // 2、AOT 预编译功能是针对 template 的，不是针对 js 的（第一次做的时候知道，这次做的时候误以为预编译是针对 js 的 -> 其实通过 AOT 和 JIT 的区别就可以推断，AOT 既然依赖的是静态编译，就是需要像模版语法这种，方便标记静态节点 - js 那么动态肯定是不行🚫的）
进行双向数据绑定。通过object.define property或者是proxy，对数据进行getter和setter的重写。   
渲染组件时，也就是实例化watcher时。执行getter触发收集相关的正在执行的watcher 到deps
更新组件时也就是触发数据的setter函数。通知所有的订阅 deps.notify（）
⭐️ // Dep 用于依赖收集，作为容器管理多个订阅者 Watcher
3.执行render函数生成vdom树
4.patch也就是diff算法通过双端比较算法计算出最小UI的更新量，更新到真实 DOM
```

```js
// 作业65： ①computed/watch/methods 的区别？②created和mounted之间的区别 ③父子组件挂载顺序 ④vue组件中的data为什么是函数
- 第一遍 -
① computed 有缓存，值不变就不会重新计算触发更新
❌ // 1、这里其实对 computed 缓存的内容理解有误差，不是「值」，是「计算属性依赖的值」，同时 computed 必须return 返回
watch 主要是监听一个值，变化一次就执行一次 ❌ // 2、执行回调
methods 方法，在初始化时定义，后续渲染时被调用 ❌ // 3、每次页面发生变化，都会被调用

② created 时， data+methods+computed+watch 已经定义存在，但是 DOM 还没有挂载到真实DOM
mounted时，DOM已经更新到真实 DOM，可以访问/操作DOM了✅

③ 父 beforeCreated - 父 created - 子 beforeCreated - 子 created - 子 beforeMounted - 子 mounted - 父 beforeMounted - 父 mounted
❌ // 子组件挂载完成后，父组件才会挂载 - 子组件在父组件执行 父 beforeMounted 后触发

④ 因为组件会被多次调用、实例化，函数保证了每个组件实例都可以拥有自己的 data 数据✅
⭐️ // 这里补充：每个组件实例都有自己的「作用域」，不会互相影响

- 第二遍 -
1、Compute需要返回值进行缓存。如果值不变的话就不会重新计算。
❌❌ // 1、咦，和上次错误的逻辑一样，不是「存储的值」是否变化，是「依赖的值」是否变化
Watch是监听的值变化一次则触发一次回调函数。
Methods当中的函数每次更新组件渲染一次，执行一次。
2、Created的时候，页面当中的dom还没有挂载，在其中，不可以操作dom组件。但是data methods，computer和watch都已经处理了。
Mounted的时候已经挂载了，这个时候是可以操作。Dom节点的
3、父组件before created，父组件created，子组件before created子组件created，子组件beforemount，子组件mount，父组件before mount，父组件mounted。
❌❌ // 2、和上次错得一样 - 因为上次答案就是错的 😅，这就纠正了，下次不许再错了：子组件在父组件执行 父 beforeMounted 后触发
 卸载组件也是父组件before destroy子组件before destroy子组件destroyed的父组件destroyed。
4、 如果不返回函数式的结构的话，每一个组件被实例化后，所有的实例访问的data都是一个引用对象。通过函数形式返回后，每一个被实例化的组件都拥有。自己的data作用域。
```

```js
// 作业66：React如何处理错误
- 第一遍 -
React 提供了两个错误 API，使用两个 API 可以组装错误边界
❌ // 1、捕获的错误是： React render+commit 中的错误
// 2、两个 API 分别是： static getDerivedStateFromError() [callback UI 有错误时提供渲染时机]
// componentDidCatch()[组件实例方法 有错误时提供时机记录错误]
// 3、为什么要有专门的错误边界处理错误：因为它可以捕获渲染、生命周期、构造函数中的错误，防止错误传播到整个应用，使其他页面能够正常展示
// 4、不会被捕获的四种错误：①事件回调中的错误，因为不在react工作流里（错误处理API被设计的目的是避免错误影响 UI显示，只有commit阶段会造成UI变化）②异步代码(setTimeout)③SSR④在错误边界组件内部发生的错误
<ErrorBoundary><MyComponent /></ErrorBoundary>
class ErrorBoundary extends React.Component {
    constructor(props){
        super(props);
        this.state = { hasError: false };
    }
    static getDerivedStateFromError(err){
        return { hasError: true }
    }
    componentDidCatch(err, errInfo) {
        console.log(err, errInfo);
    }
    render() {
        if(this.state.hasError) {
            return <h1> Sth wrong.</h1>
        }
        return this.props.children;
    }
}
- 第二遍 -
React提供两个错误处理API，用于获取render和commit 期间生命周期当中的错误，避免错误传递影响到整个应用页面的展示。 ⭐️ // 是为了 UI 正常显示设计的
Static Getderivedstatefromerror 捕获错误，提供重新渲染UI的时机(需要返回 state 对象来更新)
Componentdidcatch 捕获错误，提供记录错误的时机。
class MyBoundaryError extends React.Component {
    constructor() { ❌❌ // 1、错误边界这里需要传入 props - 才能传入子组件
        ❌❌ // 2、派生类使用 this 需要调用 super(props);
        this.state = { hasError: false };
    }
    static getDerivedStateFromError() {
        return { hasError: true };
    }
    componentDidCatch(e) {
        console.log(e);
    }
    render() {
        if(this.state.hasError) {
            return <div> There is error.</div>
        } else {
            return <p>Page.</p>
            ❌❌ // 3、如果没有错误，应该要渲染错误边界包裹的子组件
            // return this.props.children;
            // 可以看下使用：<MyBoundaryError><MyCom /></MyBoundaryError>
        }
    }
}
```

```js
// 作业68：React hooks 的原理是什么
- 第一遍 -
之前渲染流程类组件中是使用生命周期管理的，函数式组件也通过 hooks 实现了管理
❌ // 1、描述得不准确：hooks 可以在不编写类组件的情况下使用 state 及React其他特性
在 render 阶段，组件执行时，会通过链表形式存储 hooks - FiberNode.memorizeState 存储第一个链表
❌ // 2、hooks 链表说得不错，链表是为了在更新时，以稳定的顺序执行，输出最终的状态和相关副作用
❌ // 3、还有一个 hooks 利用闭包保存状态，在组件每次渲染时通过闭包保持其状态
触发更新/渲染时，会执行

❌ // 注意 hooks：1、不要在循环、条件、嵌套、try/catch/finally 中使用 - 无法保证顺序的稳定
❌ // 2、只有在 函数组件和hooks 中能够调用 hooks

- 第二遍 -
Hooks的实现目的是为了实现和类组件一样拥有对组建流程进行自定义的能力。
❌❌ // 1、和第一遍的逻辑是一样的，都是想到了「函数组件」缺失「类组件的生命周期」
// 但是 hooks 不只是「生命周期替代能力」，还有「状态管理能力」、「逻辑复用能力」
// 函数组件也不止缺失「生命周期」，还包括 state（没有 hooks 的函数组件主要接收 props 来展示 UI）
在首次渲染时，react会为每个组件收集所有的hooks并以链表形式存储在每个节点的memorizestate当中。当组件被更新，react会重新调用渲染函数，所有的hooks会按标记需要重新渲染的执行一遍。
（Hooks是和副作用链表哪个是被标记要重新渲染，然后重新渲染执行的呀？我记得hooks是在首次渲染的时候或者是后续更新的时候都会被全部按序执行一遍的，而副作用收集的链表是在commit渲染把dom更新到真实dom之后。执行副作用链表的）
❌❌ // 2、质疑是对的： hooks 在组件更新时是「全部按序重新执行一遍」，副作用链表是「在 hooks 执行过程中，如果 useEffect 依赖有更新」，就更新到副作用链表
// 和第一遍一样想到链表：第一遍想到存储位置，第二遍描述收集、执行过程 - 而不是原理
// 原理是从「链表+闭包」描述的：利用闭包保存状态，使用链表保存一系列的 hooks 与 Fiber关联。在 Fiber 更新时，就能从 hooks 中计算出最终输出的状态 和执行相关的副作用。
```

```js
// 作业69：useEffect useState模拟实现
- 第一遍 -
let states = [];
let cursor = 0;
function render() { ReactDOM.render(<App />, document.getElementById('root')) }
function useFakeState(init) {
    ❌ // 4、当前定义时的 cursor 需要被闭包保存 let currentCursor = cursor;
    const states[cursor] = states[cursor] ?? init;
    const setCurrentState = (new) => {
        states[cursor] = new;
        render();
    }
    ❌ // 3、少处理了游标自增： cursor++;
    return [states[cursor], setCurrentState];
}

let states = []; ⭐️ // 1、这里使用 allDeps 声明或许更合适
let cursor = 0;
function render() {
    ReactDOM.render(<App />, document.getElementById('root'));
    cursor = 0;
}
function fakeUseEffect(cb, depsArray) {
    const lastDeps = states(cursor);
    const hasChanged = lastDeps && depsArray.some((it, index) => it !== lastDeps[index]);
    ⭐️ // 2、这里的 some 回调可以使用 !Object.is(it, lastDeps[index])
    if(!lastDeps || hasChanged) {
        cb();
        states[cursor] = depsArray;
    }
    cursor ++;
}
- 第二遍 -
// ⭐️ 1、function render(){ 
// ReactDOM.render(<App />, document.getElementById('root'));
// cursor = 0; // 这里注意在 render 函数中，将 effect 的游标置 0
//}
const memorizedState = {};
const cursor = 0; ❌❌ // 1、这里应该是用 let
function fakeUseEffect(cb, depsArray) {
    const lastDeps = memorizedState[cursor];
    const hasChange = lastDeps && depsArray.some((it, index) => !Object.is(it, lastDeps[index]));
    if(!lastDeps || hasChange) {
        cb();
        memorizedState[cursor] = depsArray;
    }
    cursor++;
}

const memorizedState = {}; // ⭐️ 核心是链表，但是这里选择使用 [] 实现
const cursor = 0; ❌❌ // 1、这里应该是用 let
function fakeUseState(init){
    const value = memorizedState[cursor] ?? init;
    ❌❌ // 2、cursor 应该使用其他变量保存，和下文中 setValue 形成了闭包 - 在异步情况下，cursor 可能会变化，导致索引错误 const currentCursor = cursor; 这里使用 currentCursor 进行索引
    const setValue = function (newValue) {
        memorizedState[cursor] = newValue;
        ❌❌ // 4、更新使用闭包保存的 memorizedState[currentCursor] = newValue;
        ❌❌ // 5、这里还要触发一次 render() 函数执行
    }
    return [value, setValue]
}
```

```js
// 作业25：简单写下 请求创建过程
- 第一遍 -
function require(url) {
    let  xhr = new XMLHttpRequest(); // 1、实例 ⭐️「使用const」
    // 2、回调
    xhr.onerror = () => {};
    xhr.ontimeout = () => {};
    xhr.onreadyStateChange = function (res) { // ⭐️「原生函数全小写字母 onreadystatechange」
        switch(res.readyState) {
            case 0: // 未开始
                break;
            case 4:
                if(this.status === 200 || this.status === 304) {
                    console.log(this.responseText);
                }
                break; // ⭐️「记得写 break」
        }
    }
    // 3、创建
    xhr.open(url, 'GET', true); // true 表示异步 ❌ 『xhr.open('GET', url, true)』
    // 4、属性设置
    xhr.timeout = 3000;
    xhr.responseType = 'text';
    xhr.setRequestHeader(key, value);
    // 5、发送请求
    xhr.send();
}
- 第二遍 -
function request(url) {
    let xhr = new XMLHttpRequest();
    xhr.onerror = () => {};
    xhr.ontimeout = () => {};
    xhr.onreadystatechange = function(res) {
        switch(res.state) { ❌❌ // 1、res.readyState
            case 0: // 请求未开始
                break;
            case 4:
                if(this.status === 200 || this.status === 304) {
                    console.log(this.responseType);
                }
                break;
        }
    }
    xhr.open('GET', url,true);
    xhr.timeout = 3000;
    xhr.responseType = 'text';
    xhr.setRequestHeader('a', 'qiu');
    xhr.send();
}
```

> LTN ①②

2024.12.26 - 12.30 做LTN1 - 123+min

✅作业17：对斐波那切数列进行尾调用优化
✅作业20：浏览器打开一个 URL 发生了什么
✅作业26：给出一个场景，要求A、B请求执行结束后，再执行C请求，其中A、B请求同时开始，怎么实现
✅作业34：写出强缓存、协商缓存的流程及相关属性
作业36：多分支项目的大致情况
作业37：大盘的大致情况
作业38：部署两个项目的大致情况
❌作业55：flex 常见缩写
✅作业57：“假装成功”的意义是什么    
❌作业58：React和Vue是怎么描述UI的
❌作业59：什么是高阶函数?什么是高阶组件？什么是副作用？简单举例
❌作业60：虚拟DOM在 Vue 和 React 中的使用？分别有什么提升性能的方法？
❌作业61：常见的数据结构有哪些
❌作业62：fiber架构优点？ 是怎么实现的？
❌作业63：React渲染怎么实现的
❌作业64：Vue渲染怎么实现的？
❌作业65： ①computed/watch/methods 的区别？②created和mounted之间的区别 ③父子组件挂载顺序 ④vue组件中的data为什么是函数
❌作业66：React如何处理错误
❌作业67：React 怎么做的性能优化？
❌作业68：React hooks 的原理是什么？
❌作业69：useEffect useState模拟实现
❌作业70：Vue - patch 和 React 的reconciliation - Diff 算法
❌作业71：React为什么要合成事件？和原生事件有什么不同？原理是什么？
❌作业72：react 的 生命周期有哪些，在不同生命周期中做什么事情？
❌作业73：react 的 setState 是同步还是异步？为什么React有时候有两次 setState，却只执行一次？
✅2024.12 模拟实现jsonp
❌2024.12 模拟实现promise
❌2024.11 观察者模式 EventEmitter
✅2021.09 Object属性排序、与Map的区别
✅2021.07 防抖节流
✅2021.07 常见Webpack问题
❌2021.06 跨页面通信
✅2021.06 BFC特点、触发、存在/解决的问题
❌ 2021.05 XSS跨域脚本攻击 和 CSRF跨站请求伪造攻击
❌2021.05 29 WebSocket
✅2020.03 改变原数组+结束循环+性能排序
❌2019.07 深拷贝和浅拷贝的区别？怎么实现深拷贝？

```js
// 2019.07 深拷贝和浅拷贝的区别？怎么实现深拷贝？
- 第一遍 -
对于基础类型的数据深拷贝和浅拷贝都是数据的副本，修改新的数据不会影响原来的数据
对于引用类型的数据：浅拷贝拷贝指向数据的地址，修改后会影响原有数据；深拷贝的是引用地址指向的数据，修改新数据并不会影响原数据
浅拷贝：[...arr] Array.from(arr) arr.concat() arr.slice() {...obj} Object.assign({}, obj)
深拷贝：Json.parse(Json.stringify(obj))
function isObj(t) {
    const type = typeof t;
    return (t !== null) && (type === 'function' || type === 'object');
}
function handleNormal(t, type) {
    switch(type) {
        case '[object Date]':
            return new Date(t.getTime());
            break;
        case '[object RegExp]':
            return new RegExp(t.source, t.flag);
            ❌ // 1、正则类型的 t.flags
            break;
        case '[object Symbol]':
            return Symbol.for(t.description);
            break
        default:
            const ctor = t.constructor;
            return new ctor(t);
            break;
    }
}
function clone(target, m = new WeakMap()) {
    if(!isObj(target)) {
        return target;
    }
    
    const deepType = ['Map', 'Set', 'Array', 'Object'].map(it => `[object ${it}]`);
    const type = Object.prototype.toString.call(target);
    if(!deepType.includes(type)) {
        return handleNormal(target, type);
    }
    
    const ctor = target.constructor;
    let res = new ctor();
	if(m.has(target)) {
        return target
    }
    m.set(target, res);
    
    if(type === '[object Set]') {
        target.forEach(it => {
            res.add(clone(it, m));
        })
    }
    if(type === '[object Map]') {
        target.forEach((value, key) => {
            res.set(key, clone(value, m));
        })
    }
    if(Array.isArray(target)) {
        for(let i = 0, len = target.len; i<len;i++) {
            res[i] = clone(target[i], m);
        }
    } else {
        for(let i of target) {
            ❌ // 2、 object 不是可迭代对象，不能使用 for...of，这里应该改为 for...in
            res[i] = clone(target[i], m)
        }
    }
    return res;
}
```

```js
// 2020.03 改变原数组+结束循环+性能排序
可以改变原数组的数组方法有:shift unshift pop push reverse sort splice fill
不可以通过return和break结束循环 filter map reduce forEach
排序：for>for...of>forEach>map>for...in
```

```js
// 2021.05 29 WebSocket
WebSocket和HTTP/1.1在语法、语义上完全不相同，HTTP/1.1因为请求-应答的模式无法实现实时通讯
❌ // 1、学名：全双工 - 双向通信协议
①使用不同的协议头 ws:80 wss:443
②使用不同的识别方式，websocket使用的是URI，HTTP使用的是IP+端口号
③websocket使用二进制帧，不受同源协议的限制
④websocket跑在HTTP协议之上，使用GET请求进行连接。请求头中携带Connection:upgrade，如果响应头中返回Upgrate:websocket 则建立连接
```

```js
// 2024.11 观察者模式 EventEmitter
- 第一遍 -
add remove emit once setMax
class EventEmitter() {
    constructor() {
        this.events = {};
        this._max = 10;
    }
    setMax(limit) {
        this._max = limit;
    }
    add(event, listener) {
        if(!this.events[event]) {
            this.events[event] = [];
        }
         ❌ // 4、少了计算监听事件数量 if(this.events[event].length > this._max) { throw Error('exceed') }
        this.events[event].push(listener);
    }
    remove(event, listener) {
        if(!listener) {
            delete this.events[event];
            return;
        }
        if(Array.isArray(this.events[event])) {
            let index = this.events[event].indexOf(listener);
            this.events[event].splice(index, 1);
            ❌ // 1、 这里要判断 index > -1，也就是 listener 存在才删除
        }
    }
    once(event, listener) {
        const onceFunc = (...args) => {
            listener(...args);
            this.remove(event, onceFunc);
        }
        this.add(event, onceFunc);
    }
    emit(event) {
        const argsList = arguments.slice(1);
        if(this.events[event]) {
            ❌ // 2、这里一定要注意，由于 once 的存在，this.events[event] 在执行过程是动态改变的
            ❌ // 所以这里一定要将 this.events[event] 拷贝下来再处理 let static = [...this.events[event]]
            this.events[event].forEach((it, index) => {
                const args = argsList[index];
                Array.isArray(args) ? it(...args) : it();
                 ❌ // 3、args 还是要传进函数的 Array.isArray(args) ? it(...args) : it(args)
            })
        } 
    }
}
```

```js
// 2021.05 XSS跨域脚本攻击 和 CSRF跨站请求伪造攻击
网络攻击的根本原因是浏览器给同源策略开的两个后门：①可以引入第三方数据 ②通过CORS向第三方资源发起请求
❌ // 1、可以引用第三方资源
XSS跨域脚本攻击：定义-在前端页面中恶意注入恶意代码，修改服务器数据
解决方案 ①纯前端渲染，服务端对输入、存储进行转义、过滤
②对 cookie 设置 httpOnly，只有 http 协议可以访问 cookie，js 引擎会禁止 js 对 cookie 的访问，例如document.cookie
③浏览器提供了白名单CSP：content-security-policy 设置的是可以访问该资源的域名
❌ // 2、少了一项：在渲染时禁止标签执行JavaScript的代码，例如a标签script的标签

CSRF跨站请求伪造攻击：定义-冒用用户的cookie信息获取服务器的信任，修改服务器数据
①对请求来源进行校验，例如请求头中的 referer
②开启 cookie 中的 samesite 配置，禁止其他非同源页面对 cookie的访问
③CSRF token，在请求中校验第三方无法模拟的 token
```

```js
// 2021.06 BFC特点、触发、存在/解决的问题
特点：①独立容器 ②从上到下，垂直排列 ③不和外部的浮动元素重合
触发：①float 非 none ②overflow 非 visible：hidden/auto/scroll ③display: flex/inline-block/table-caption/table-cell ④position: absolute/fixed ⑤根元素
问题：同一个BFC中相邻的两个盒子会出现 外边距重叠，只显示一个 margin
解决方案：给他们的父元素添加 display:flex
```

```js
// 2021.06 跨页面通信
同源页面：
1、localStorage:只能处理非当前页面✅
发送 localStorage.setItem(key, value) + 接收 window.onstorage
2、BroadChannel:❌ // 构造函数名字记错了：BroadCastChannel
发送 let b = new BroadChannel('one'); b.postMessage(value);
接收 创建同名频道，接收数据 b.onmessage
非同源页面：
3、postMessage(H5 API)✅
发送 let win = window.open(url); win.postMessage(value)
接收 在打开的页面中直接获取 window.onmessage
4、iframe：将 origin 设置为同源，然后使用方法1/2✅
```

```js
// 2021.07 常见Webpack问题✅
/** 1、webpack的几个核心概念理解：Chunk、Module、plugin
2、常见配置项：entry、output、module、resolve等
自定义 loader 怎么配置？
3、Code Splitting 和 Tree Shaking 的区别？懒加载怎么实现？
4、html-webpack-plugin 作用？
5、sourceMap不同环境的区别？怎么开启配置？
6、热更新怎么实现？
7、webpack原理/执行过程？
开发插件的桥梁？*/
1、Chunk：由多个Module组成
Module：万物皆模块
plugin：在构建过程中，特定时机注入代码执行
2、entry[配置入口文件]: 'src/main.js'; 或者 { main: 'src/main.js', sub: 'src/sub.js' }
output[配置输出]: { filename: '[name]-[hash].js', path: path.resolve(_dirname, 'dist') }
module[依赖解析、转换配置]: { rules: [ { test: '/.\js/', use: ['style-loader', 'css-loader', 'sass-loader'] }, { test: '/.\css/' } ] }
resolve[依赖查找配置]:{ 
	alias: { "@c": 'src/component' },
    extensions: ['jsx', 'js', 'josn'],
    modules: [path.resolve(_dirname, 'src/my'), 'node_modules']
}
配置自定义 loader 的两种方法
①如上，在 resolveModules 中添加自定义 loader 的路径 + 然后直接在 module.rules 直接引用即可 use:['style-loader', 'my-loader']
②在 use 中具体地址引用：use:['style-loader', path.resolve(_dirname, 'src/my/my-loader.js'), 'sass-loader']
3、coding splitting 按需加载，适用于单页应用，在加载首页时以entry配置入口分组，只加载当前使用的代码，其他的延迟/操作后再加载，提高渲染效率
⭐️ // 1、开启方式是 splitChunk 插件配置 - 加快响应速度
tree shaking 按需打包，按照 entry 为入口，递归查找实际被引用的代码进行打包，其他部分不进行打包，减小包大小
懒加载：利用 code splitting 按需加载首次渲染需要的代码，提高渲染效率
4、html-webpack-plugin：在 webpack 全部打包完成后，在 html 模版中将打包后文件引入，方便直接访问
5、生产环境：devtool:hidden-source-map; 不引入sourcemap
本地/测试以缓解：devtool:cheap-eval-source-map; （不提供列信息）方便代码调试
6、①在启动 webpack 的时候，通过 dev-server 在内存中启动一个服务，同时注入 HMR 相关代码，使用 websocket 协议 和浏览器保持实时通讯
②有代码更新时，通过监听 webpack 的 compiler done 事件，在编译结束后，得到 mainfest.json 和 chunk.js 文件，通过 websocket 将 mainfest 配置文件主动推送给 浏览器
③浏览器在 mainfest 中获得 ChunkId 等信息，发起 ajax 请求向内存中的服务获取 chunk.js 的模块代码文件
④执行 window.webpackHotUpdate->执行hotApply热更新函数，替换原有模块代码，不用刷新整个页面（模块代码通过 webpack.__require__来执行）
⭐️ // 2、第4步，其实就是开始 render
7、webpack原理/执行过程
①初始化配置参数：将shell脚本和配置文件中的配置整合，得到初始化配置
②利用得到的参数初始化 webpack Compiler，加载所有插件，执行 .run 开始构建
③根据entry配置为入口，依次执行 module.rules 配置的loader转换、解析，递归遍历所有依赖模块
④得到转换后的文件和依赖关系，按照entry配置，组合成一个一个chunk，输出到下载文件列表
⑤根据 output 输出配置，将列表中的文件输出到指定位置
Compiler：代表了webpack的生命周期，整个构建流程中就一个
Compilication：代表了一次构建，更新一次代码就创建一个
```

```js
// 2021.07 防抖节流 ✅
function debounce(fn, delay) {
    let timeId = null;
    return function (...args) {
        if(timeId) {
            clearTimeout(timeId);
        }
        timeId = setTimeout(() => {
            fn(...args);
        }, delay)
    }
}
function throttle(fn, delay) {
    let flag = true;
    return function(...args) {
        if(!flag) {
            return;
        }
        flag = false;
        fn(...args);
        setTimeout(() => {flag = true}, delay)
    }
}
```

```js
// 2021.09 Object属性排序、与Map的区别 ✅
Object 属性排序：正整数 > 字符串 > 负数 > 浮点数 > Symbol
与Map的区别：
① Map的键可以是任何类型 VS Object 的键只有字符串/Symbol
② Map可以记录插入顺序 VS Object 无法记录，自有自己的默认排序方式
③ Map写法简单，长度为 m1.size() VS Object.keys(Object).length
④ Map在大量数据时占用空间小，增删快
⑤ Map是可迭代对象 VS Object不是
```

```js
// 2024.12 模拟实现promise
- 第一遍 -
then catch finally resolve reject all race
const Status = {
    pending: 'pending',
    resolve: 'fulfilled',
    reject: 'rejected'
}
function MyPromise(executor) {
    this.status = Status.pending;
    this.value = null;
    this.reason = null;
    this.callbacksResolve = [];
    this.callbacksReject = [];
    const resolve = (value) => {
        if(this.status === Status.pending) {
            this.status = Status.resolve;
            this.value = value;
            this.callbacksResolve.forEach(it => it(value));
        }
    }
    const reject = (reason) => {
        if(this.status === Status.pending) {
            this.status = Status.reject;
            this.reason = reason;
            this.callbacksReject(it => it(reason))
        }
    }
    
    try{
        executor(resolve, reject);
    }catch(e) {
        reject(e);
    }
}
MyPromise.prototype.then = function (onResolve, onReject) {
    onResolve = typeof onResolve === 'function' ? onResolve : v => v;
    onReject = typeof onReject === 'function' ? onReject : r => {throw r};
    return new MyPromise((resolve, reject) => {
        const resolveFun = () => {
			setTimeout(() => {
                try{
                    const res = onResolve(this.value);
                    resolve(res);
                }catch(reject);
            }, 0)
        }
        const rejectFun = () => {
            setTimeout(() => {
                try{
                    const res = onReject(this.reason);
                    resolve(res);
                }catch(reject);
            }, 0)
        }
        switch(this.status) {
            case Status.pending:
                this.callbacksResolve.push(() => resolveFun());
                this.callbacksReject.push(() => rejectFun());
                break;
            case Status.resolve:
                resolveFun();
                break;
            case Status.reject:
                rejectFun()
                break;
        }
    })
}
MyPromise.prototype.catch = function (onReject) {
    return this.then(null, onReject);
}
MyPromise.prototype.finally = function(callback) {
    return this.then((value) => { callback(); return value; },
                    (reason) => { callback(); throw reason; })
}
MyPromise.resolve = (value) => {
    return new MyPromise((resolve, reject) => {
        if(value instanceof MyPromise) {
            return value.then(resolve, reject);
        }
        resolve(value);
    })
    ⭐️ // 3、这里的 return 可以删除，不影响
}
MyPromise.reject = (reason) => {
    return new MyPromise((resolve, reject) => {
        reject(reason);
    })
    ⭐️ // 2、简写成 return new MyPromise((resolve, reject) => reject(reason));
}
MyPromise.all = function (arr) {
    return new MyPromise((resolve, reject) =>{
        return arr.reduce((pre, cur, index) => {
             ⭐️ // 4、这里的 return 可以删除，不影响
            cur.then(res => {
                pre.push(res);
                if(index === arr.length -1) {
                    resolve(pre);
                }
            }).catch(reject);
            ❌ // 1、reject 是作为 then 的第二个函数 -> }, reject)
            return pre;
        }, [])
    })
}
MyPromise.race = function (arr) {
    return new MyPromise((resolve, reject) => {
        arr.forEach(it => {
            return MyPromise.resolve(it).then(resolve, reject);
        })
        ⭐️ // 5、这里科利简写 arr.forEach(it => MyPromise.resolve(it).then(resolve, reject))
    })
}
```

```js
// 2024.12 模拟实现jsonp
function jsonp(url, params, cb){
    const suffix = Object.entries(params).map(([key, value]) => `${key}=${value}`).join('&');
    const allUrl = url + (url.includes('?') ? '&' : '?') + suffix + (suffix ? '&' : '') + `callback=${cb}`;
    
    const dom = document.createElement('script');
    window[cb] = function (...args) {
        cb(...args);
        document.body.removeChild(dom);
    }
    
    dom.src = allUrl;
    document.body.appendChild(dom);
}
```

```js
// 作业73：react 的 setState 是同步还是异步？为什么React有时候有两次 setState，却只执行一次？
合成事件中的 setState 是异步的，冒泡到顶层容器才触发
❌ // 1、除了合成事件，还有「生命周期函数」中都是异步，原因是 React 对多个 setState 调用进行合并，在一个事件处理函数中，收集多个 setState 到一个更新队列，这个事件处理函数结束后，根据合并后的状态，合并为一个更新，触发一次重新渲染
原生事件中的 setState 是同步的，不在 React 管控中，捕获时触发 ✅
⭐️ // 2、补充：原生事件，比如 addEventListener、setTimeout/setTimeInterval，在其中调用 setState，状态更新会立即生效，并且会触发组件的重新渲染
React 做了 setState 合并，在执行过程中，收集变更，执行完事件函数后再触发 setState 更新
⭐️ // 3、学名「批量更新机制」：为了减少不必要的重新渲染次数
```

```js
// 作业72：react 的 生命周期有哪些，在不同生命周期中做什么事情？
react 的生命周期主要是针对 类组件 来讲的，函数组件通过 useEffect 等hooks 实现
❌ // 1、对也是对的，但是函数组件的生命周期还是可以「展开讲讲」
① componentDidMount - 首次渲染，在 commit 阶段，Diff 计算出的最小更新量 应用到真实 DOM 后触发，一般用于 初始化数据 ✅
② componentDidUpdate - 更新，commit 阶段，更新真实 DOM 后触发 ✅
❌ // componentDidUpdate(prevProps, prevState)，一般用于「操作DOM」和「执行副作用」
③ componentDidUnMount - 卸载组件之前调用，一般用于清理定时器、解除监听等，避免内存泄漏
❌ // componentWillUnMount
④ shouldComponentUpdate - 自定义组件是否重新渲染，传入的参数为 新的状态和属性 ✅
⭐️ // shouldComponentUpdate(nextProps, nextState)
❌ // 2、不止上面四个，还有 constructor()、render()，分三个阶段来描述：
// ⑤constructor - 类组件的构造函数，用于初始化组件状态 state + 绑定事件处理函数 + super(props) 传递 props
// ⑥render - 渲染函数，返回一个React元素
❌ // 3、分为三个阶段，分别执行对应的生命周期
// 挂载阶段：⑤constructor()、①componentDidMount、⑥render()
// 更新阶段：④shouldComponentUpdate、⑥render()、②componentDidUpdate
// 卸载阶段：③componentWillUnMount

❌ // 4、函数组件的生命周期
❌ // ① useEffect - 模拟了三个生命周期
// 模拟componentDidMount - 当组件首次渲染时，useEffect 内部的函数执行
// 模拟componentDidUpdate - 通过在 useEffect 的依赖数组中传入状态或属性，依赖发生变化时，内部函数再次执行
// 模拟componentWillUnMount - useEffect 可以 return 一个函数作为清理函数，会在组件卸载时执行
❌ // ② useLayoutEffect - [commit阶段]在DOM更新后，浏览器下一次重绘前，同步执行 - 会阻塞重绘
// 		   	   useEffect - [commit阶段]在DOM更新后，异步执行 - 适合不依赖DOM布局的副作用，例如数据获取、订阅事件等

```

```js
// 作业71：React为什么要合成事件？和原生事件有什么不同
合成事件的定义：React 统一了各个浏览器内核的原生 API 差异，抹平差异后，用户只需要关注功能实现，而不需要再关注宿主环境
合成事件是原生事件的高级集合
❌ // 1、内核是对的，不是“高级集合”，是「React对浏览器原生事件的封装」，是「一个跨浏览器兼容的事件系统」
// 优点/原因：① 跨浏览器兼容性 ②性能优化：通过事件委托到 document，减少大量事件绑定的开销
❌ // 2、“不同”需要具体的描述：
// ①事件对象(有一套标准的属性和方法，用于事件信息 VS 由浏览器提供，属性方法因浏览器而异)
// ②事件绑定方式(React中JSX属性中指定事件处理函数来绑定 VS 原生标签的 onclick/addEventListener)
// ③事件执行顺序(内部事件系统决定，冒泡执行，一般比原生晚 VS 先捕获再冒泡)
```

```js
// 作业70：Vue - patch 和 React 的reconciliation - Diff 算法
React：
❌ // 1、简单描述下 React 的 Diff 算法是「精确到单个节点的属性级别」，适合「大型复杂场景」，例如大量动态组件和频繁更新的场景
1、从根节点开始比较，采用分层比较
❌ // 2、对，这里可以标题记忆 「① 分层比较 + 同类型比较优先策略」
2、同类型节点，则比较属性的变更；不同类型则停止比较，标记为需要重新渲染✅
3、同类型+同key 的节点进行复用
❌ // 3、这里主要是指：「列表组件」中，根据 key 确定新老树子节点的关系
❌ // 4、少写了「② DFS 深度优先遍历子节点」

Vue：
❌ // 5、描述：「更新基于组件级别」
1、比较新老两棵 VDOM 树，采用双指针，分别从新老两棵树的头尾开始比较，适用于小型应用快速计算出最小更新量 UI
❌ // 6、双指针其实很不明确，「双端比较算法-双向指针」
2、同类型+同key 的节点进行复用
❌ // 7、是会复用，但是场景是「双端比较法没有找到足够匹配的节点，就根据节点的索引进行比较」
// 8、检索「同类型+同key 的节点」，「索引位置」没有变化，就认为这个节点不需要更新；若有变化，就「移动到新位置」，「复用旧列表」
3、跳过比较静态编译标记的静态节点，加快比较速度✅
```

```react
// 作业67：React 怎么做的性能优化？
React 每次更新都是重新生成一棵完整的树，更新颗粒度细
1、运行时优化：fiber 架构实现时间分片 + 优先级调度
❌ // 1、对，在运行时优化，但是这个「架构级别」的属于渲染层面的优化，性能方便还是两个优化策略
	①Time Slice 原理：每次渲染新的一帧前，fiber 都会查询 shouldYield 判断是否要执行一个渲染单元
    ②用户交互产生的渲染任务，优先级高于非视口下的页面渲染
2、在是否复用组件时，两个优化策略：
❌ // 2、对，但是一般不叫做「是否复用组件」，而是「避免组件重新渲染」
	①s？ 策略：？
    ❌ // 3、eagerState：在useState 更新过程中，如果新值不依赖于旧状态，则直接使用新状态来更新组件
	②bailout 策略：props+state不变，就可以进入该策略
	❌ // 4、只需要组件的 props 不变，即可避免重新渲染[state可能会影响子组件的 props，还是要考虑的]
3、日常一些写法也可以优化
❌ // 5、两个策略中，bailout 策略可以通过调用 API 来实现
	①把动态的变量和静态数据拆分组件
    ❌ // 6、React.memo - 针对函数组件，对组件的 props 浅比较，不变则跳过重新渲染
    const MyComponent = React.memo((props) => {return <div>{props.text}</div>}) // props.text 的值/引用不变，就不会重新渲染
    ❌ // 7、shouldComponentUpdate - 针对类组件，在组件更新前调用，自定义是否需要重新渲染
    class MyComponent extends React.Component {
        shouldComponentUpdate(nextProps, nextState) {
            return this.props.text !== nextProps.text; // 不同时，重新渲染
        }
        render() {return <div>{this.props.text}</div>}
    }
	❌ // 8、useMemo/useCallback - 依赖项不变，返回之前的缓存
    const expensiceValue = useMemo(() => { return count*2 }, [count])
    const handleClick = useCallback(() => {setCount(count + 1)}, [count])
❌ // 9、除了两个策略，还有 VDOM + Diff - 减少对真实 DOM 的操作，避免不必要的回流重绘
```

```js
// 作业61：常见的数据结构有哪些
❌ // 按逻辑结构分为：线性结构和非线性结构
结构型类型：数组、栈/队列、链表
非结构型类型：树、图
```

```js
// 作业60：虚拟DOM在 Vue 和 React 中的使用？分别有什么提升性能的方法？
❌ // 1、主要区别从 虚拟DOM 的「具体实现」体现
React：
1、先通过渲染得到一个新的 VDOM 树 
❌ // 2、需要详细描述一下：React使用JSX描述UI，JSX被编译为React createElement方法 -> 执行后返回一个由 React Element描述的UI - FiberNode构成，作为新的VDOM
2、和当前的 VDOM 比较，得到需要更新的节点，再修改真实 DOM 
❌ // 3、当前的 VDOM 也是 FiberNode，比较，计算出 FiberNode 描述的 UI 更新 - Diff
可以减少对真实 DOM 的操作和访问，减少回流重绘消耗的性能
由于 React 使用 JSX ，灵活性比较大，编译时优化很难实现，在运行时做了很多优化策略。 
❌ // 4、运行时优化是对的，主要策略是 fiber架构（时间分片 + 优先级调度）

Vue：
1、和 React 一样，也是通过渲染得到新的 VDOM 树
❌ // 5、一样的问题，要详细描述具体实现：Vue 使用模版语法描述UI，编译为 render 函数 -> 执行后返回 VDOM 描述的 UI「注意这里的差异」
2、和当前 VDOM 树比较，再修改真实节点
❌ // 6、描述是对的，专业一点说这里是 patch 的过程：Diff 主要是用的是 双向指针 + 静态解析
由于 Vue 使用的是模版语法，在编译时可以通过 AOT 进行优化。

编译分为两种：
❌ // 7、简单比较一下两种编译方式：JIT 应用首次加载会比AOT慢，体积也会更大
AOT 预编译，标记静态节点，运行时直接执行，速度比较快，占用内存空间小
❌ // 8、描述错误：编译后，下一步是「代码构建」-也就是准备执行，主语是「宿主环境」获得，宿主环境获得的是编译后的代码，可以直接执行 - 例如Vue3的静态/动态节点分析/跳过
JIT 即时编译，运行时需要先编译再执行，代码占用的空间会比较大，因为会有编译相关的代码需要存储
❌ // 9、少写了：代码依旧是在「宿主环境」中执行 - React
```

```js
// 作业58：React和Vue是怎么描述UI的
React: JSX - 由js+HTML组成，函数组件+类组件
// ❌ 少写了： 可以自定义组件 + 使用花括号{}将js嵌入JSX {note}
//	少写了： state-状态，组件内部自变量
//	少写了： props-属性，其他组件传入的自变量
Vue: 模版 - 花括号嵌入模版+指令<div v-if="show">
// ❌ 模拟语法 - 结合数据+预先定义的模版
//  少写了： 使用双大括号展示数据{{note}} + 指令v-if="show"/v-for="item in items"
```

```js
// 作业57：“假装成功”的意义是什么 
客观从物理层面说，肢体是可以改变人体内的睾丸酮和皮质醇(压力激素)
假装成功可以降低压力、提高自信心
人是有“自我预言”机制的，你越相信，你越能做到
you derserve better, fake it until you become it!
```

```js
// 作业34：写出强缓存、协商缓存的流程及相关属性
1、url 在本地查找是否存在缓存，存在的话直接使用[强缓存生效]
2、存在缓存，但是缓存失效 If-none-match/Etag、Last-Modified/If-modified-since ，如果服务器返回 304，代表缓存内容正确，使用缓存并刷新本地的缓存有效期[协商缓存生效]
有效期：Cache-Control: max-age=2000;（单位是秒）、Expires: deadline具体时间点；
```

```js
// 作业26：给出一个场景，要求A、B请求执行结束后，再执行C请求，其中A、B请求同时开始，怎么实现
1、Promise.all([A(), B()]).then(C);
2、async function () {
    await Promise.all([A(), B()]);
    C();
}
```

```js
// 作业20：浏览器打开一个 URL 发生了什么
1、浏览器进程-UI线程：将用户输入内容/链接转换为完整的URL
2、通过IPC协议传递给网络进程
	① 查询本地是否有缓存：有缓存且在有效期内-直接返回缓存
	②有缓存但无效/无缓存：DNS查询解析，得到ip
	③TCP队列排队，连接-三次握手
	④组装请求信息：请求头cookie等
    ⑤发起请求：301/302 重定向，取响应头中的Location作为新的url导航
    		  304 Not Modified，使用缓存，并刷新本地缓存有效期
              200 OK type类型为 o-stream 下载流
              				   html 和渲染进程建立管道，边下载边传输
3、渲染进程（主线程、合成线程、预解析线程）
	①和网络进程建立管道，并开启预解析，如果检测到js/css文件，提前下载
	②传输完成后，渲染进程还没解析完之前，页面会出现短暂空白，就是解析白屏
    ③传输完成后，会通知浏览器进程更新 页面+url+前进后退+安全锁
注意：解析过程中，遇到js代码，会暂停DOM解析（因为JS可能会改变DOM
渲染流程：
	主线程：解析DOM(DOM树)->样式计算(css样式表)->布局(布局树)->分层(分层树)->绘制(指令列表)
	合成线程：->栅格化(图块->位图)【此处会开启GPU进程加速】
	浏览器进程-UI线程：->合成展示
```

```js
// 作业17：对斐波那切数列进行尾调用优化
function fib(n) {
    if(n<2)return n;
    return fib(n-1)+fib(n-2);
} 0 1 1 2 3 5 8 
function optimizeFib(a=0, b=1, n){
    if(n === 0) return a;
    return optimizeFib(b, a+b, n-1)
}
```

2024.12.25 +1天 做LTN2 - 140min

✅作业3：迭代器原理
❌作业25：简单写下 请求创建过程
✅作业41：TED 如何解决焦虑
❌作业49：牛顿三大定律、热力学两大定律
❌ 作业54：举杯邀明月，对影成三人。的上一句
❌LTN2.1 显示省略号
✅LTN2.2 position属性 - 都是什么占位？相对于什么定位
❌LTN2.3 HTTP/2特性
✅LTN2.4 红宝书19章
✅LTN2.5 红宝书18章
❌LTN2.6 模块化
❌LTN2.7 包管理工具
✅LTN2.8 给定时间切换状态
❌LTN2.9 数组去重
✅LTN2.10 数组乱序 洗牌算法

```js
// LTN2.10 数组乱序 洗牌算法
// 从最后一个元素开始，从数组中随机选出一个位置，交换，直到第一个元素。
function chaos(arr) {
    const length = arr.length;
    for(let i = length -1 ; i >= 0; i--){
		let random = Math.floor(Math.random()*length);
        [arr[random], arr[i]] = [arr[i], arr[random]]
    }
    return arr
}
// while 循环来写
function chaos(arr) {
	let cur = arr.length - 1;
    while(cur >= 0) {
        let random = Math.floor(Math.random()*arr.length);
        [arr[random], arr[i]] = [arr[i], arr[random]];
        cur --;
    }
    return arr
}
```

```js
// LTN2.9 数组去重  // ⭐️ 125最重要，其实 4 和 5 是一个逻辑， 3 和 2 很像
1、new Set([...arr]) // ❌ [...new Set(arr)] Array.from(new Set(arr))
2、arr.filter((it, index) => arr.indexOf(it) === index);
5、function unique(arr){
    let hash = {};
	return arr.filter(it => hash[it] ? false :  hash[it] = true)
}
3、function unique(arr) {
    return arr.reduce((pre, cur) => {
        if(!pre.includes[cur]) {
            pre.push(cur);
        }
        return pre;
    }, [])
}
4、function unique(arr) {
	let hash = {};
    let res = [];
    arr.forEach(it => {
        if(!hash[it]) {
            res.push(it);
            hash[it] = true;
        }
    })
    return res
}
```

```js
// LTN2.8 给定时间切换状态
async function (promise, time) {
    const timePro = new Promise((resolve, reject) => { setTimout(reject, time, new Error('time out!')) });
	return await Promise.race([promise, timePro])
}
```

```js
// LTN2.7 包管理工具
npm：
	将依赖提升、拍平存储在node_modules；7.x有针对peer dependencies的break change；package-lock.json(npm>5) + .npmrc
yarn v1/classic：
	将依赖提升、拍平存储在node_modules;针对早期npm优化，可以并行加载多个依赖；yarn.lock + .yarnrc
pnpm：❌ // 「不是pnpm.yml，而是 pnpm-lock.yml」
	保留结构化的node_modules，采用内容寻址存储，只物理存储一次，节省空间；pnpm.yml + .npmrc
yarn v2/Berry： // ⭐️「即插即用」
	不再使用node_modules，使用依赖查找表 .pnp.cjs 和 /.yarn/cache 存储 zip文件；yarn.lock + .yarnrc.yml
```

```js
// LTN2.6 模块化
CommonJS：同步加载，适用于服务器端，输出的是值的拷贝，运行时加载，require + exports
AMD：异步加载，可以并行加载多个模块，依赖前置 define(['a.js', 'b.js'], function (a, b) {})
❌ // 少写了 ：加载模块后直接执行，无法保证执行顺序
CMD：异步加载，可以并行加载多个模块，依赖就近 define(function(require, exports, module){
    let a = require('a.js'); a.callback();
})
❌ // 少写了 ：加载后，直到调用才按需执行
ES6模块化：异步加载，是客户端和服务端的通用解决方案，输出的是值的引用，编译时加载， import as from default export
```

```js
// LTN2.3 HTTP/2特性
和HTTP/1.1相比，语义层面完全兼容，语法层面大力改造
1、压缩头部信息，采用 HPACK 字典表算法
2、不再使用纯文本传送，而是二进制帧 - 双向传输序列 - 形成虚拟的流，在一个连接上可以处理多个请求响应（多路复用），多个请求响应之间没有了顺序，解决了队头阻塞
3、设置请求优先级
4、采用HTTPS
❌  // 少写一个 5、服务器推送
```

```js
// LTN2.2 position属性 - 都是什么占位？相对于什么定位
static - 标准文档流，占位
relative - 标准文档流，占位，相对定位 // ⭐️「相对自己本身的定位」
absolute - 脱离文档流，绝对定位，相对于上一个 position 非 static 的父级元素
fixed - 脱离文档流，粘性定位，相对视口
sticky - 原本是标准文档流，超过一个阈值后，变成 fixed
```


```js
// 作业54：举杯邀明月，对影成三人。的上一句
起舞弄清影，独酌无相亲 ❌ 『花间一壶酒，独酌无相亲』
```

```css
// LTN2.1 显示省略号
- 第一遍 -
.line {
    overflow: hidden;
	white-space: nowrap;
    text-overflow: ellipsis;
}
.lines {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-direction: vertical; ❌ // 『不是 direction 是 orient: -webkit-box-orient: vertical;』
    -webkit-line-clamp: 3;
    // 解决 padding 带来的露出问题
    line-height: 30px;
    height: 90 - padding距离;
}
```

```js
// 作业49：牛顿三大定律、热力学两大定律
 + 加速度 a=F/m + 作用力与反作用力 ❌ 『惯性定律』
能量守恒 + 熵增定律
```

```js
// 作业41：TED 如何解决焦虑
1、do it badly - anything worth doing worth doing badly the first time
2、给自己一些同情，我们都不会和一个天天批评自己的朋友长久交往 - 你也不要做自己这样的朋友
3、找到意义 - 即使别人不知道，自己一定要认可自己做得事情，觉得有价值

- 如何停止过度思考 - 
“思考”和抽烟、喝酒一样，是一件上瘾行为 - 想要不上瘾，就是允许念头在脑中出现，get it then let it go
不跟着念头走，回到当下
焦虑是一种对失败的恐惧 - 写下可能导致自己失败的事情 - 每个失败的可能都找到应对方案，do it
```

```js
// 作业3：迭代器原理
迭代器：调用 next() 将可迭代对象的值一一返回，不用关注对象类型，只要是可迭代对象都有默认迭代器 [Symbol.iterator]
```

2024.12.25 先做LTN4 - 62min

✅作业1：写一个只能被迭代指定次数的类
✅作业7：原始值包装类型和原始类型在使用 typeof 和 instanceof 进行类型判断时，有什么异同？
✅作业9：数组自带排序 sort() 为什么经常要传比较函数？写一个降序的比较函数。如果数组元素全是数值，请给出简写形式
✅作业11：写出一个用 yield 实现的递归算法，从0数到指定n
✅作业12：画出一个原型链，到 null 为止
✅作业8：ES6新增了两个创建数组的静态方法：Array.from()和Array.of()两个有什么区别？
✅作业10：说出WeakMap/WeakSet和Map、Set的区别，为什么有这两个弱类型，经常用在什么场景
❌作业16（2）：arguments 对象对待命名参数和设置了默认值的命名参数有什么不同？数组作为参数传入函数得到的arguments 是什么？怎么实现arguments是数组？怎么收集独立参数？在对象字面量和数组字面量中，扩展运算符有什么不同的表现？

````js
// 作业16（2）：arguments 对象对待命名参数和设置了默认值的命名参数有什么不同？数组作为参数传入函数得到的arguments 是什么？怎么实现arguments是数组？怎么收集独立参数？在对象字面量和数组字面量中，扩展运算符有什么不同的表现？
arguments 默认同步命名参数，比如在函数内修改了 arguments[0]，如果对应的是命名参数，那么值会同步
但是 arguments 不同步设置了默认值的命名参数
数组作为参数 - arguments:[1,2,3]❌『[[1,2,3]]』
可以用扩展运算符转换 (...arr)
收集独立参数 (first, second, ...rest) -> rest 是一个数组 只能作为最后一项收集
扩展运算符 - 对象字面量 {...obj} 浅拷贝对象中所有实例属性❌『创建一个新对象，并复制所有可枚举属性』
扩展运算符 - 数组字面量 [...obj] 将可迭代对象一一返回
````

```js
// 作业10：说出WeakMap/WeakSet和Map、Set的区别，为什么有这两个弱类型，经常用在什么场景
WeakMap/WeakSet 分别是 Map、Set 的弱类型，特点是键/值只能是对象类型，并且在对象是空对象，没有引用时，垃圾回收程序会清理当前弱类型
目的：避免内存泄漏
场景：比如监听 DOM 节点，如果节点被删除，弱类型会被清理
```

```js
// 作业8：ES6新增了两个创建数组的静态方法：Array.from()和Array.of()两个有什么区别？
Array.from() - 用于将类数组(arguments+Nodelist)/可迭代对象转换成数组类型，浅拷贝
Array.of() - 用于将一连串参数转换成数组类型，主要用于替代 Array.prototype.slice.call(arguments)
```

```js
// 作业12：画出一个原型链，到 null 为止
function Person() {}
let person = new Person();
person.__proto__ === Person.prototype

Person.prototype.constructor === Person
Person.prototype.__proto__ === Object.prototype

Object.prototype.constructor === Object
Object.prototype.__proto__ === null
```

```js
// 作业11：写出一个用 yield 实现的递归算法，从0数到指定n
function * nTimes(n) {
    if(n>0) {
        yield* nTimes(n-1);
        yield (n-1);
    }
}
```

```js
// 作业9：数组自带排序 sort() 为什么经常要传比较函数？写一个降序的比较函数。如果数组元素全是数值，请给出简写形式
sort函数会把数组中的值转换成字符串后比较，比如排序后会出现 [1,10,15,3,5]
// 降序
[].sort((a,b) => {
    return a > b ? -1 : a < b ? 1 : 0
})
// 简写
[].sort((a, b) => b - a)
```

```js
// 作业7：原始值包装类型和原始类型在使用 typeof 和 instanceof 进行类型判断时，有什么异同？
String Boolean Number
原始类型-使用 typeof v 可以得到具体类型的字符串 VS 使用 v instanceof S/B/N 都是 false
原始值包装类型 - 使用 typeof v 得到 'object'  VS  v instanceof S/B/N 得到 true
typeof 用于判断基础数据类型（null array object 都是 'object'，函数是 'function'）
instanceof 在对象的原型链上查找是否有指定构造函数的原型对象 [Symbol.hasinstance]
```

```js
// 作业1：写一个只能被迭代指定次数的类
class nTimes{
    constructor(n) {
        this.limit = n;
    }
    [Symbol.iterator](){
        let max = this.limit;
        let times = 0;
        return {
            next() {
                if(times < max) {
                    return {value: times++, done: false};
                } else {
                    return {value: undefined, done: true};
                }
            }
            return() {
                return {value: undefined, done: true}
            }
        }
    }
}
// 答题核心：迭代器返回的是迭代器对象(包含next()、return()) + next 返回一个 done+value组成的对象
```



