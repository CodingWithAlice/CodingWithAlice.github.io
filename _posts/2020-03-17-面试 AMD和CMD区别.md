---
layout:     post
title:     面试 AMD和CMD区别
subtitle:  
date:       2020-03-17
author:     
header-img: 
catalog: true
tags:
    - < 面试题整理 >
typora-root-url: ..
---


# 面试 AMD和CMD区别

场景：网易面试最后问的几个完全不会的问题之一

参考：阮一峰的es6、掘金的几篇博客



总结：

**明显的区别**就是在模块定义时对依赖的处理不同

**1、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块**
**2、CMD推崇就近依赖，只有在用到某个模块的时候再去require**

**最大的区别**：**对依赖模块的执行时机处理不同**，注意不是加载的时机或者方式不同（都是异步加载）



| CommonJS 模块                                                | 名称     | ES6 模块 import                                              |
| ------------------------------------------------------------ | -------- | ------------------------------------------------------------ |
| 模块输出：只有一个出口module.exports，<br />加载模块：require |          |                                                              |
| 输出的是一个值的**拷贝**<br />（一旦输出一个值，模块内部的变化就影响不到这个值） | 输出     | 输出的是值的**引用**<br />（动态引用，脚本执行时，再根据引用，到模块里面取值，若原始值变了，`import`加载的值也会跟着变） |
| **运行**时加载，只有在脚本运行完才会生成                     | 时机     | **编译**时输出接口**（更早）**，在代码静态解析阶段就会生成   |
| 一个模块就是一个脚本，`require`命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。<br />（这个对象的`id`属性是模块名，`exports`属性是模块输出的各个接口，`loaded`属性是一个布尔值，表示该模块的脚本是否执行完毕）<br />以后需要用到这个模块的时候，就会到`exports`属性上面取值。也就是说，**不会再次执行该模块，而是到缓存之中取值，只会在第一次加载时运行一次**。 | 加载原理 |                                                              |

CommonJS中，require需要代码是同步执行的，但是在浏览器端实现的时候，加载使用srcipt标签，但脚本标签天生异步，导致传统CommonJS无法正常加载。

| AMD异步模块定义                                              | CMD通用模块定义                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 在浏览器端模块化开发的规范<br />RequireJS主要解决了：1⃣️有依赖关系需要顺序加载的js文件；2⃣️js加载阻塞 | 在浏览器端模块化开发的规范<br />浏览器的实现SeaJS            |
| AMD**依赖前置**，js可以方便知道依赖模块是谁，立即加载        | 而CMD**就近依赖**，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，以性能换便利 |
| AMD在**加载模块完成后就会执行**模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，依赖模块的执行顺序**和书写顺序不一定一致** | CMD**加载完某个依赖模块后并不执行**，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序**和书写顺序是完全一致**的 |
| 需要用到对应的库函数RequireJS<br />**定义函数** 语法：define(id?, dependencies?, factory);<br />id：可选参数，用来定义模块的标识，默认脚本文件名；<br />dependencies：当前模块依赖的模块名称数组；<br />factory：工厂方法，模块初始化要执行的函数或对象。 | 语法：define(id?, deps?, factory)<br />其中常用文件名作id；推崇依赖就近，依赖一般不写deps中，写在factory中；factory：是个函数，function(require, exports, module)<br />require：是个方法，require(id)，用来获取其他模块提供的接口；<br />exports：是个对象，用来向外提供模块接口；<br />module：是个对象，存储了与当前模块相关联的一些属性和方法。 |
| 在页面上使用require函数**异步加载模块**，<br />语法：require([dependencies], function(){});<br />[dependencies]：数组，表示所依赖的模块；<br />function(){}：回调函数，前面依赖的模块加载完成后，加载的模块以参数形式传入函数，被调用。 |                                                              |

