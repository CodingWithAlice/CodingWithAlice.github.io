---
layout:     post
title:      面试题整理7（海康）
subtitle:  
date:       2019-07-11
author:     
header-img: 
catalog: true
tags:
    - < 面试题整理 >
typora-root-url: ..
---

# 面试题整理7（海康）



1. 闭包是什么？有什么优点和缺点？
2. css中怎么使盒子上下居中（面试官说水平居中太简单了orz...）？
3. js中本地存储有哪些？有什么不同？
4. cookie中的session了解吗？
5. 跨域了解吗？
6. this的指向问题？
7. vue使用的UI框架？
8. npm中的工具了解过吗？（yarn）
9. Node.js了解吗？
10. 详细讲一下项目？后端调用？



详解：

1. ## 闭包是什么？有什么优点和缺点？

   解答：闭包是指有权访问另一个函数作用域中的变量的函数。

   **优点**：① 能够读取函数内部的变量；②让这些变量一直存在于内存中，不会在调用结束后被垃圾回收机制回收；

   **缺点**：由于闭包会使用函数中的变量存在在内存中，内存消耗很大，所以不能滥用闭包；解决的办法是退出函数之前，将不使用的局部变量删除；

2. ## css中怎么使盒子上下居中（面试官说水平居中太简单了orz...）？

   解答：方法一：设置垂直居中的时候要注意，先**给祖先元素`html`和`body`的高度设置为100%**（默认是0）；并且**清除默认样式**（`margin`和`padding`都设置为0，否则浏览器就会出现滚动条），然后**给子盒子相对定位和位移**`position：relative;top:50%;`，然后**减去本身宽度的一半**即可（`margin-top：负自身高度的一半` // `transform：translateY(-50%)`向上偏移自身高度的一半；

   注意：top、bottom、left、right的百分比值都是相对于包含块的高度、宽度的；

   方法二：**弹性盒子**。给**父元素设置`display:flex; align-items:center;`**设置body里的元素垂直居中；（`justify-content:center;`定义body里的元素水平居中）

3. ## js中本地存储有哪些？有什么不同？

   cookie、localStorage、sessionStorage

   相同点：都保存在浏览器端

   不同点：

   **①传递方式不同**

   ​	cookie数据始终在**同源的http请求中携带**（即使不需要），即cookie在浏览器和服务器间来回传递。

   ​	sessionStorage和localStorage不会自动把数据发给服务器，**仅在本地保存**。

   **②数据大小不同**

   ​	（cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。）
   ​	存储大小限制也不同，cookie数据**不能超过4k**，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。

   ​	sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

   **③数据有效期不同**

   ​	sessionStorage：仅在当前**浏览器窗口关闭前有效**，自然也就不可能持久保持；

   ​	localStorage：**始终有效**，窗口或浏览器关闭也一直保存，因此用作持久数据；

   ​	cookie只在设置的**cookie过期时间之前**一直有效，即使窗口或浏览器关闭。

   **④作用域不同**

   ​	sessionStorage**不在不同的浏览器窗口中共享**，即使是同一个页面；

   ​	localStorage 在所有**同源窗口中都是共享**的；

   ​	cookie也是在所有**同源窗口中都是共享**的。

4. ## cookie中的session了解吗？

   cookie和sessiom是两种**保持会话**状态的方法。

   ​	cookie就是指客户端在向服务端发起请求的时候，服务端会在进行response的时候给当前客户端的一小段文本信息，并保存在当前的客户端的浏览器中，这一小段cookie文本信息也就是这个客户端去访问服务端的通行证，有了这个通行证，以后当这个客户端再去访问服务端的时候，服务端便知道是谁拿着通行证去进行访问了。

   ​	session和cookie的功能类似，也是一种保持会话状态的方式，在用户使用浏览器发起会话时，服务器会为每一个用户浏览器提供一个单独的session对象来保存用户的数据，并将它保存在服务端，而当用户访问其他web资源的时候，则可以从保存用户数据的session对象中把用户数据抽取出来并进行访问。

   区别：

   1. cookie的用户数据是保存在**用户浏览器**的cookie中的；

   session的用户数据是保存在**服务器为用户浏览器单独创建的session对象**中的。

   2. 数据的读取和调用，cookie可以采用request.getCookies这种方法；

      session则可以用request.Session的方法。

   3. 安全性，cookie是存储在**用户浏览器**中的；

      而session是**存储在服务器**上的，所以session比cookoe要相对安全；

5. ## 跨域了解吗？

   跨域，指的是浏览器不能执行其他网站的脚本。浏览器执行`javascript`脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。

      解决办法：

      ①**JSONP**：注意JSONP只支持GET请求，不支持POST请求。

      原理：ajax请求受同源策略影响，不允许进行跨域请求，而**script标签src属性**中的链接却可以**访问跨域的js脚本**，利用这个特性，服务端不再返回JSON格式的数据，而是**返回一段调用某个函数的js代码**，在src中进行了调用，这样实现了跨域。

      ②**代理**：写后端接口，在后端调用页面拿到返回值返回给html文件。相当于绕过了浏览器，就不会存在跨域问题。

      ③**PHP端修改header**

      ```javascript
      header('Access-Control-Allow-Origin:*');//允许所有来源访问
      header('Access-Control-Allow-Method:POST,GET');//允许访问的方式
      ```

6. ## this的指向问题？

   this的最终指向的是那个调用它的对象。

   改变this指向的方法：

   1. 使用**箭头函数**；
   2. 在函数内部使用`_this=this;`
   3. 使用**apply、call、bind**
   4. new**实例化一个对象**；

7. ## vue使用的UI框架？

   animate.css是一款前端动画库，相似的有velocity-animate；

   ​	（element ui框架的按钮组件；

   ​	iView 是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品

   ​	Vuetify.js根据材料设计规格提供 UI 布局；

   ​	基于 Vue.js 的 Bootstrap 组件；

   ​	cube-ui 是滴滴团队开发的基于 Vue.js 实现的精致移动端组件库；

   ​	vue-beauty 是一套基于 vue.js 和 ant-design样式 的PC端 UI 组件库；

   ​	AT-UI 是一个模块化的前端 UI 框架，基于Vue.js 的快速和强大的 Web 界面；专门为桌面应用程序构建；

   ​	Vue-Blu是基于Vue.js和Bulma开发的开源UI组件库。旨在为PC端的前端开发(特别是中后台产品)提供一个快速且灵活的解决方案。）

   首先`npm install animate.css --save`；

   然后在vue文件的script中引入`import animate from 'animate.css'`；

   最后绑定元素使用

   ```vue
   <template>
       <div class="song">
           <p id="f" @click='fade'>hello</p>
       </div>
   </template>
   ```

   ```javascript
   methods:{
       fade:function(){
           $('#f').addClass('animated bounceOutLeft')
       }
   }
   ```

   部分api

   ```javascript
   	fade: {
           title: '淡入淡出',
           fadeIn: '淡入',
           fadeInDown: '向下淡入',
           fadeInDownBig: '向下快速淡入',
           fadeInLeft: '向右淡入',
           fadeInLeftBig: '向右快速淡入',
           fadeInRight: '向左淡入',
           fadeInRightBig: '向左快速淡入',
           fadeInUp: '向上淡入',
           fadeInUpBig: '向上快速淡入',
           fadeOut: '淡出',
           fadeOutDown: '向下淡出',
           fadeOutDownBig: '向下快速淡出',
           fadeOutLeft: '向左淡出',
           fadeOutLeftBig: '向左快速淡出',
           adeOutRight: '向右淡出',
           fadeOutRightBig: '向右快速淡出',
           fadeOutUp: '向上淡出',
           fadeOutUpBig: '向上快速淡出'
         },
         bounce: {
           title: '弹跳类',
           bounceIn: '弹跳进入',
           bounceInDown: '向下弹跳进入',
           bounceInLeft: '向右弹跳进入',
           bounceInRight: '向左弹跳进入',
           bounceInUp: '向上弹跳进入',
           bounceOut: '弹跳退出',
           bounceOutDown: '向下弹跳退出',
           bounceOutLeft: '向左弹跳退出',
           bounceOutRight: '向右弹跳退出',
           bounceOutUp: '向上弹跳退出'
         },
         zoom: {
           title: '缩放类',
           zoomIn: '放大进入',
           zoomInDown: '向下放大进入',
           zoomInLeft: '向右放大进入',
           zoomInRight: '向左放大进入',
           zoomInUp: '向上放大进入',
           zoomOut: '缩小退出',
           zoomOutDown: '向下缩小退出',
           zoomOutLeft: '向左缩小退出',
           zoomOutRight: '向右缩小退出',
           zoomOutUp: '向上缩小退出'
         },
         rotate: {
           title: '旋转类',
           rotateIn: '顺时针旋转进入',
           rotateInDownLeft: '从左往下旋入',
           rotateInDownRight: '从右往下旋入',
           rotateInUpLeft: '从左往上旋入',
           rotateInUpRight: '从右往上旋入',
           rotateOut: '顺时针旋转退出',
           rotateOutDownLeft: '向左下旋出',
           rotateOutDownRight: '向右下旋出',
           rotateOutUpLeft: '向左上旋出',
           rotateOutUpRight: '向右上旋出'
         },
         flip: {
           title: '翻转类',
           flipInX: '水平翻转进入',
           flipInY: '垂直翻转进入',
           flipOutX: '水平翻转退出',
           flipOutY: '垂直翻转退出'
         },
         strong: {
           title: '强调类',
           bounce: '弹跳',
           flash: '闪烁',
           pulse: '脉冲',
           rubberBand: '橡皮筋',
           shake: '左右弱晃动',
           swing: '上下摆动',
           tada: '缩放摆动',
           wobble: '左右强晃动',
           jello: '拉伸抖动'
         }
   ```

8. ## npm中的工具了解过吗？（warn）

   npm就是JavaScript的包管理工具。npm主要用来下载，安装，管理第三方模块。

   创建一个包描述文件：`npm init [-y]`

   查看包的信息 `npm info <package-name>`

   查看包的版本信息 `npm info <package-name> versions`

   安装指定的包：`npm install <package-name>`
    默认会安装在当前目录下的 node_modules 目录下，如果 node_modules 不存在，则会自动创建。
   本地安装包，如果包里有可执行文件，则npm会把可执行文件安装到 node_modules/.bin 目录下。
   
   安装指定版本的包：`npm install <package-name>@<version>`

   安装包并记录依赖，会在 package.json 中 dependencies 属性记录依赖`npm install <package-name> --save`

   卸载包：`npm uninstall <package-name>`

   更新包：`npm update <package-name>`

   全局安装包，把包安装在全局目录，供所有项目使用:`npm install <package-name> -g`
   全局安装包，如果包里有可执行文件，则npm会把可执行文件安装到 node_modules 上一级目录中。

   查看全局目录：`npm root -g`
   
   修改全局目录的路径：`npm config set prefix ``"新路径"`
	默认情况下全局安装的包不能直接在项目中加载，如果要直接加载，需要在系统环境变量中添加一个名为 NODE_PATH 的变量，值为全局安装目录下 node_modules 位置。

   查看npm配置 `npm config list`


9. ## Node.js了解吗？

   ​		根据官方文档可以知道，node就是一个给予谷歌v8引擎的一个javascript的运行时，可以理解为运行js的一个虚拟机。他使用的是一个事件驱动，非阻塞I/O模型 ，他是将js的运行环境搬到了服务器端，和客户端没有一点关系。是一个纯服务端的东西，node只是为js提供了一个平台。

   　　node里面其实还分了两块，一是封装了v8引擎，目的是为了执行es（如定义变量，定义函数等），另外一个提供了大量的工具库,是帮助node实现各种功能的，提供了一些以前js的环境办不到的事情，比如文件操作，网络操作，操作系统的操作。

   　　既然node是一个平台（所谓的平台就是用来运行特定语言的），也就意味着node是用来运行语言的，那么java也是语言，node能运行java吗？据nodejs创始人Ryan Dahl回忆，他最初是选择了Ruby这门语言，但是Ruby这门语言的虚拟机效率不怎么样最终放弃了，按照这种思路，貌似node将java的虚拟机集成进来应该可以运行java，但node作者最终选择了javascript。

   　　这样js就实现了在服务端运行的可能，js运行在node平台上（分为v8部分，用来执行es，和大量的工具库组件（API）称之为libuv，提供了以前js的环境办不到的事，如文件操作，网络操作等等）。

   用途：

   ​		（1）node可以**接受客户端用户的所有请求**，并且能够快速的给出响应，因此node可以用来做网站。

   　　（2）node可以作为一个**中间层来来分发调用数据接口**，比如有一个网站数据是有java提供的，我们可以让node作为一个中间层，来接受用户的请求，然后通过node来调用java数据接口，获取到数据后直接在node层面做html的瓶装，然后将渲染好的页面直接给用户。为什么要这样做，直接请求java接口不行吗，这是因为node被称之为高性能的web服务器，在并发和抗压方面都比传统的平台要好很多，因此这样一包装可以极大的减轻服务器的开发。

   　　通过上面的两点，可以总结出，node在web中要么从前端页面到后端服务全包了，一个是只做其中的一点。

   　　**一言以蔽之，node就是一个javascript的运行环境（平台），他不是一门语言，也不是javascript的框架。可以用来开发服务端应用程序，web系统。其特点是体积小，快速，高性能。**

10. ## 详细讲一下项目？后端调用？