---
layout:     post
title:     06 JS执行顺序：编译+执行
subtitle:  
date:       2021-04-10
author:     
header-img: 
catalog: true
tags:
    - < 浏览器原理 >
typora-root-url: ..
---


# 06 JS执行顺序：编译+执行

<img src="/../img/assets_2019/image-20210410153255736.png" alt="image-20210410153255736" style="zoom:30%;" />

## 1、编译阶段
<img src="/../img/assets_2019/image-20210410153313919.png" alt="image-20210410153313919" style="zoom:50%;" />

编译阶段会生成两部分内容：
-   创建执行上下文 The Creation Phase
-   可执行代码
### 创建执行上下文（Execution context）

    执行上下文是JavaScript执行一段代码时的运行环境。

对于每个执行上下文，都有三个重要属性：

1、**this**

2、**作用域链** (Scope chain)：当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链

3、**变量对象** (Variable object，VO) - 保存了**变量提升**的内容



- **this** 值的决定，即我们所熟知的 **This 绑定**

    - 全局执行上下文中 —> `this` 指向**全局对象**（浏览器中 - `window`）

    - 函数执行上下文中 —> `this` 的值取决于**该函数是如何被调用的**。

        —> 如果它被一个 **引用对象** 调用，那么 `this` 会被设置成那个对象，

        —> 否则 `this` 的值被设置为全局对象或者 `undefined`（在严格模式下）。

        ```js
        let foo = {
            baz: function() {
                console.log(this);
            }
        }
        foo.baz();   // 'this' 引用 'foo', 因为 'baz' 被对象 'foo' 调用
        
        let bar = foo.baz;
        bar();       // 'this' 指向全局 window 对象，因为没有指定引用对象
        ```

- 创建**词法环境**组件 — `let/const`

    - 定义：

        词法环境由 **环境记录器**（<span style="color:red">存储变量和函数声明的实际位置 -- **作用域在函数定义的时候就决定**</span>） 和一个 **外部词法环境的引用**（可以访问其父级词法环境 - 作用域链） 组成。

    - **词法环境**有两种类型：

        - **全局环境** 没有外部环境引用的词法环境 -> `null`；环境记录器用于定义全局上下文中的变量和函数
        - **函数环境** 外部环境引用可能是全局环境，也可能是任何包含此内部函数的外部函数；环境记录起用于存储变量、函数、参数

- 创建**变量环境**组件 — `var`

    - 定义：同样是一个词法环境，其环境记录器持有 **变量声明语句** 在执行上下文中创建的**绑定关系**

## 2、执行阶段
按照顺序一行一行地执行可执行代码

注意：
-   一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数
```js
function showName() {
    console.log('我是个坑');
}
showName();
function showName() {
    console.log('我还是个坑');
}
showName(); // 我还是个坑
```
输出的结果是：‘我还是个坑’

