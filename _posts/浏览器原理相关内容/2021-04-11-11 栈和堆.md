---
layout:     post
title:     11 栈和堆
subtitle:  
date:       2021-04-11
author:     
header-img: 
catalog: true
tags:
    - < 浏览器原理 >
typora-root-url: ..
---


# 11 栈和堆

## 几个基础概念：
静态语言：在声明变量之前需要先定义变量类型，例如C
动态语言：在运行过程中需要检查数据类型的语言，例如JS

弱类型语言：支持隐式类型转换的语言
强类型语言：不支持隐式类型转换的语言

<img src="/../img/assets_2019/image-20210411143958862.png" alt="image-20210411143958862" style="zoom:30%;" />

JS是一种**弱类型**（不需要提前声明类型，JS在运行代码时自己计算），**动态**类型（一个变量可以保存多种类型的数据）语言。【**js中字符串不能被修改**】

## js数据类型
<img src="/../img/assets_2019/image-20210411144048172.png" alt="image-20210411144048172" style="zoom:30%;" />
原始类型：前面的 7 种数据类型 -- 存在栈中
引用类型：对象类型 -- 存在堆中


## 存储空间

    JavaScript 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据

```js
function foo(){
    var a = " 极客时间 "
    var b = a
    var c = {name:" 极客时间 "}
    var d = c
}
foo()
```
如上代码的执行栈如下图，JavaScript 引擎执行到`var c = {name:" 极客时间 "}`时判断右边的值是一个引用类型，将它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址，然后再将该数据的地址写进 c 的变量值：
<img src="/../img/assets_2019/image-20210411144222302.png" alt="image-20210411144222302" style="zoom:30%;" />

## 为什么要划分堆和栈，全部都放在栈里面不行么？
JavaScript 引擎需要用**栈**来维护程序**执行期间上下文的状态**，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。
所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是**分配内存和回收内存**都会占用一定的时间。
<img src="/../img/assets_2019/image-20210411144337024.png" alt="image-20210411144337024" style="zoom:40%;" />


## 再看闭包
产生闭包的核心：
-   第一步是需要预扫描内部函数
-   第二步是把内部函数引用的外部变量保存到堆中
```js
function foo() {
    var myName = " 极客时间 "
    let test1 = 1
    const test2 = 2
    var innerBar = { 
        setName:function(newName){
            myName = newName
        },
        getName:function(){
            console.log(test1)
            return myName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName(" 极客邦 ")
bar.getName()
```
内存模型的角度来分析这段代码的执行流程，示意图如下：
-   当`JavaScript`引擎执行到`foo`函数时，首先会编译，并创建一个空执行上下文
-   在编译过程中，遇到内部函数`setName`，JavaScript引擎还要对内部函数做一次**快速的词法扫描**，发现该内部函数引用了`foo`函数中的`myName`变量，由于是内部函数引用了外部函数的变量，所以JavaScript引擎判断这是一个**闭包**，于是在**堆空间创建**一个`closure(foo)`的对象（这是一个内部对象，JavaScript是无法访问的），用来保存`myName`变量
-   接着继续扫描到`getName`方法时，发现该函数内部还引用变量`test1`，于是 JavaScript引擎又将`test1`添加到`closure(foo)`对象中
-   由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中
<img src="/../img/assets_2019/image-20210411150011033.png" alt="image-20210411150011033" style="zoom:35%;" />




