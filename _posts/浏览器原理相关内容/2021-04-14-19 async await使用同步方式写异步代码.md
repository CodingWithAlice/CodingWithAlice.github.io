---
layout:     post
title:     19 async await使用同步方式写异步代码
subtitle:  
date:       2021-04-14
author:     
header-img: 
catalog: true
tags:
    - < 浏览器原理 >
typora-root-url: ..
---


# 19 async await使用同步方式写异步代码

Promise 的缺点：处理流程复杂时，代码充斥了`.then`方法，语义化不明显

###  JS 异步编程的重大改进 - async await
async await - 提供了在不阻塞主线程的情况下**使用同步代码实现异步访问资源**的能力，并且使得代码逻辑更加清晰

## JS 引擎如何实现 async/await 
async/await 使用了 Generator 和 Promise 两种技术

### 什么是生成器
生成器函数是一个带星号函数，而且是**可以暂停执行和恢复执行**的。

具体使用方式：
-   在生成器函数内部执行一段代码，如果遇到 **yield** 关键字，那么 JS 引擎将返回关键字后面的内容给外部，并暂停该函数的执行
-   外部函数可以通过 **next** 方法恢复函数的执行

示例代码：
```js
function* genDemo() {
    console.log(" 开始执行第一段 ")
    yield 'generator 2'
 
    console.log(" 开始执行第二段 ")
    yield 'generator 2'
 
    console.log(" 开始执行第三段 ")
    yield 'generator 2'
 
    console.log(" 执行结束 ")
    return 'generator 2'
}
 
console.log('main 0')
let gen = genDemo()
console.log(gen.next().value)
console.log('main 1')
console.log(gen.next().value)
console.log('main 2')
console.log(gen.next().value)
console.log('main 3')
console.log(gen.next().value)
console.log('main 4')
```

### 生成器（Generator）是如何工作的
JS引擎是如何实现一个函数的暂停与恢复执行的？ -- 首先要了解协程的概念

#### Generator 的底层实现机制——协程

##### 协程定义
协程是一种比线程更加轻量级的存在。你可以把协程看成是**跑在线程上的任务**，**一个线程上可以存在多个协程**，但是在线程上**同时只能执行一个协程**

##### 协程优势
协程**不是被操作系统内核所管理**，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源

##### 协程的特征
1、调用生成器创建的协程，创建之后并不会直接执行
2、想要协程执行，需要调用`.next`方法
3、协程正在执行的时候，可以通过`yield`暂停协程，并返回信息给父协程
4、在协程的执行期间，遇到了`return`关键词，JS引擎会结束当前协程，并返回给父协程

##### 切换协程的调用栈实现
第一点：gen 协程和父协程是在主线程上**交互执行**的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的。

第二点：当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息。

<img src="/../img/assets_2019/image-20210414134853816.png" alt="image-20210414134853816" style="zoom:40%;" />

### 生成器示例代码的执行过程
简单了解了协程的概念后，我们用协程看下生成器示例代码的执行过程
![image-20210414135211223](/../img/assets_2019/image-20210414135211223.png)


### 生成器实现一个复杂业务
基于协程能够提供更好的性能，以及暂停/恢复特性，实现一个比较复杂的业务，可以如下考虑：
![image-20210414135231872](/../img/assets_2019/image-20210414135231872.png)

## async await语法糖的实现
`async await`让开发彻底告别执行器和生成器，实现更加直观简洁的代码。
其实 `async/await` 技术背后的秘密就是 **Promise 和生成器**应用，往低层说就是**微任务和协程**应用。

### async
MDN描述：`async` 是一个通过**异步执行**并**隐式返回 Promise 作为结果**的函数
```js
async function foo() {
    return 2
}
console.log(foo())  // Promise {<resolved>: 2}
```

### await
结合 `async` 一起看下
![image-20210414135259911](/../img/assets_2019/image-20210414135259911.png)
`await 100`这个语句做了几件事：
1、默认创建一个 Promise 对象，其中的`resolve`函数被提交给微任务队列
2、暂停当前`foo`协程，并将创建的`promise_`返回给父协程
3、父协程通过调用`promise_.then`方法监控`Promise`对象状态的改变
然后继续进行父协程，在父协程任务执行完，结束之前，到达检查点，检查微任务队列
--> 执行微任务列表中的`resolve(100)`，激活`.then`方法监控的回调函数，并将主线程的控制权交给`foo`协程，并将`value`传给协程
-->`foo`协程被激活后，将`value`值赋值给`a`，继续执行后面的`console.log`语句
-->执行完成后将主线程的控制权归还给父协程