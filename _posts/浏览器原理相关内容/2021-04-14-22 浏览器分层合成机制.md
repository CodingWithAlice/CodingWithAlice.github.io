---
layout:     post
title:     22 浏览器分层合成机制
subtitle:  
date:       2021-04-14
author:     
header-img: 
catalog: true
tags:
    - < 浏览器原理 >
typora-root-url: ..
---


# 22 浏览器分层合成机制



## 帧 + 帧率
    显示器怎么显示图像？

每个显示器都有自己的刷新频率，一般是60HZ（每秒更新60张图片 -- 来源于显卡中的**前缓冲区**），将读取的图像显示到显示器上。

    显卡的作用？

显卡的作用是**合成新的图像**，并将图像保存到后缓冲区 -- 一旦合成的图像写到后缓冲区，系统就让前/后缓冲区互换 --> 为了保证显示器能够读取到最新显卡合成的图像。

    动画效果怎么实现？

在滚动鼠标或者缩放页面时，**渲染引擎**会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。【如果要保持动画流畅，渲染引擎需要每秒更新60张图片到显卡的后缓冲区】

    帧？

把渲染流水线生成的每一幅图片为一帧

    帧率？

把渲染流水线每秒更新了多少帧称为帧率

举例：滚动过程中1秒更新了60帧，那么帧率就是 60HZ/60FPS

## 渲染引擎为了不卡顿做了什么？
最卓有成效的策略就是引入了【分层和合成】机制。

### 如何生成一幅图像
关于其中任意一帧的生成方式，有**重排、重绘和合成**三种方式，每种方式的渲染路径是不同的。

重排：根据CSSOM+DOM计算布局 --> 整个渲染流水线的每个阶段都要执行一遍；
重绘：没有计算布局 --> 依然需要计算绘制信息，然后继续执行后面的流程；
合成：并不需要计算布局、绘制两个阶段；

### 分层和合成

如果没有分层 --> 从布局树直接生成目标图片的话，每次很小的变化都会重排/重绘；
分层 --> 将素材分解为多个图层的操作；
合成 --> 最后将这些图层合并到一起的操作；

-   分层、合成流程

在 Chrome 的渲染流水线中，生成**布局树**之后 --> 开始分层：渲染引擎会根据布局树的特点将其转换为**层树**（Layer Tree）（层树是渲染流水线后续流程的基础结构）--> 层树中的**每个节点都对应着一个图层**（下一步的绘制阶段就依赖于层树中的节点）--> 绘制阶段：将绘制指令组合成一个**绘制列表** --> 光栅阶段：按照绘制列表中的指令生成图片，每一个图层都对应一张图片 --> **合成线程**将这些图片合成为“一张”图片，并最终将生成的图片发送到**后缓冲区**

合成操作是在**合成线程**上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因

### 分块
合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。

注意：还有一个优化点，首次合成土块的时候用一个低分辨率的图片显示，然后合成器继续绘制网页，完成后再替换低分辨率内容。


## 写代码的时候能做什么优化？
如果需要对某些元素做【几何形状变换、透明度变换或者一些缩放操作】，如果使用JS来实现这些效果，会涉及到整个渲染流水线。
-   优化方案：利用下面这个样式的添加，渲染引擎会将该元素**单独实现一帧**（不能随意增加，因为从渲染引擎准备一个独立层开始，后面的每一个阶段都会多一个层结构，都会占用额外的内存），等到这些变换发生时，渲染引擎会通过**合成线程**直接处理，就不会涉及到主线程 --> 这也就是为什么CSS动画比JS动画高效
```css
.box {
    will-change: transform, opacity;
}
```