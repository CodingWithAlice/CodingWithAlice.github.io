---
layout:     post
title:     12 垃圾回收机制
subtitle:  
date:       2021-04-11
author:     
header-img: 
catalog: true
tags:
    - < 浏览器原理 >
typora-root-url: ..
---


# 12 垃圾回收机制

## 垃圾数据回收分为两种策略：
-   手动回收：C/C++（手动分配内存/销毁）
-   自动回收【垃圾回收器】：js、java、python

内存泄漏：如果这段数据已经不再需要了，但是又没有销毁

## 栈 - 垃圾回收机制
提问：我们之前说到，函数执行完后，函数的执行上下文会从堆中被销毁掉，怎么销毁的呢？
-   解答：有一个记录当前执行状态的指针（称为`ESP`），指向调用栈中`showName`函数的执行上下文，表示当前正在执行`showName`函数。
   执行完`showName`后，JavaScript会将`ESP`下移到`foo`函数的执行上下文，这个**下移操作就是销毁`showName`函数执行上下文的过程**。
   上面`showName`的执行上下文虽然保存在栈内存中，但是已经是**无效内存**了。比如当`foo`函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文
![image-20210411195059967](/../img/assets_2019/image-20210411195059967.png)


## 堆 - 垃圾回收机制(JS引擎V8)
代际假说特点：
-   第一个大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
-   第二个是不死的对象，会活得更久

垃圾回收算法：有很多种，需要权衡来确定什么时候使用哪一种

在 V8 中会把堆分为**新生代**和**老生代**两个区域：

| 新生代 | 老生代 |
| --- | --- |
| 存放生存时间短的对象 | 存放生存时间久的对象 |
| 通常只支持 1～8M 的容量 | 容量大很多 |
| 副垃圾回收器 | 主垃圾回收器 |

### 垃圾回收器的工作流程
主副垃圾回收器有一套共同的执行流程：
-   第一步是**标记**空间中活动对象和非活动对象
（所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象）
-   第二步是**回收**非活动对象所占据的内存
（其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象）
-   第三步是做内存**整理**
（一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为**内存碎片**。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况）
**副垃圾回收器不产生内存碎片**

### 副垃圾回收器
新生区的垃圾回收 - 区域虽然不大，但是垃圾回收还是比较频繁的 -- **Scavenge 算法**

Scavenge 算法：把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示
<img src="/../img/assets_2019/image-20210411195415523.png" alt="image-20210411195415523" style="zoom:30%;" />

新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。

但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。

也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

### 主垃圾回收器
老生区中的垃圾回收 - 除了新生区中晋升的对象，一些大的对象会直接被分配到老生区 - **标记 - 清除**（Mark-Sweep）的算法

老生区对象有两个特点：一个是对象占用空间大，另一个是对象存活时间长。

首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。

当 showName 函数执行结束之后，ESP 向下移动，指向了 foo 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。由于 1050 这块数据被变量 b 引用了，所以这块数据会被标记为活动对象。这就是大致的**标记过程**。
<img src="/../img/assets_2019/image-20210411195458566.png" alt="image-20210411195458566" style="zoom:40%;" />

接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其**清除过程**:
<img src="/../img/assets_2019/image-20210411195551014.png" alt="image-20210411195551014" style="zoom:30%;" />

不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——**标记 - 整理**（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
<img src="/../img/assets_2019/image-20210411195637678.png" alt="image-20210411195637678" style="zoom:30%;" />


## 全停顿
全停顿现象：由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。

在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。
为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为**增量标记**（Incremental Marking）算法。
<img src="/../img/assets_2019/image-20210411195717116.png" alt="image-20210411195717116" style="zoom:30%;" />
