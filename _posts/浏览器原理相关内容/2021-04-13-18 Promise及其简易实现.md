---
layout:     post
title:     18 Promise及其简易实现
subtitle:  
date:       2021-04-13
author:     
header-img: 
catalog: true
tags:
    - < 浏览器原理 >
typora-root-url: ..
---


# 18 Promise及其简易实现

JS的异步编程模型，典型的如下图：
<img src="/../img/assets_2019/image-20210413205034686.png" alt="image-20210413205034686" style="zoom:40%;" />

### 异步回调
Web 页面的单线程架构决定了异步回调，而异步回调影响到了我们的编码方式。
--> 将异步回调函数封装是一个很好的思维，
--> 但是封装后，如果遇到比较复杂的业务场景嵌套了太多的回调函数就很容易使得自己陷入了回调地狱
代码之所以看上去很乱，归结其原因有两点：
-   第一是嵌套调用，下面的任务依赖上个任务的请求结果，并在上个任务的回调函数内部执行新的业务逻辑，这样当嵌套层次多了之后，代码的可读性就变得非常差了。
-   第二是任务的不确定性，执行每个任务都有两种可能的结果（成功或者失败），所以体现在代码中就需要对每个任务的执行结果做两次判断，这种对每个任务都要进行一次额外的错误处理的方式，明显增加了代码的混乱程度。

### Promise解决了什么问题呢？
-   第一是消灭嵌套调用
-   第二是合并多个任务的错误处理

### Promise 怎么解决嵌套回调问题
1、`Promise` 实现了回调函数的延时绑定 - 创建完 `Promise` 后再用 `.then` 方法绑定回调函数
2、将回调函数 `onResolve` 的返回值穿透到最外层 - 需要通过返回值确认创建什么类型的`Promise`任务
<img src="/../img/assets_2019/image-20210413205128118.png" alt="image-20210413205128118" style="zoom:40%;" />


### Promise 怎么处理异常
即使一个`Promise`有多个回调函数，也可以通过一个 `.catch` 方法来捕获异常 
-->  `Promise` 对象的错误具有“冒泡”性质，会一直向后传递，直到被 `onReject `函数处理或 `catch` 语句捕获为止


### Promise 为什么要使用微任务
我们先来简单实现一个Promise
![image-20210413205156971](/../img/assets_2019/image-20210413205156971.png)
因为定时器的执行效率不是太高，**采用微任务实现了回调函数延迟绑定**，这就是为什么Promise使用微任务的原由了

简单对Promise的实现放在下方
```js
function Bromise(executor) {
    var onResolve_ = null
    var onReject_ = null
     // 模拟实现 resolve 和 then，暂不支持 rejcet
    this.then = function (onResolve, onReject) {
        onResolve_ = onResolve
    };
    function resolve(value) {
          setTimeout(()=>{
            onResolve_(value)
           },0)
    }
    executor(resolve, null);
}
```