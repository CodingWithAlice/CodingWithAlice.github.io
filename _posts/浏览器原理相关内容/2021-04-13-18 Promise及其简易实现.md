---
layout:     post
title:     18 Promise及其简易实现
subtitle:  
date:       2021-04-13
author:     
header-img: 
catalog: true
tags:
    - < 浏览器原理 >
typora-root-url: ..
---

# 18 Promise及其简易实现

参考文章：[这一次，彻底弄懂 Promise 原理](https://juejin.cn/post/6844904063570542599) - 对 Promise 源码进行了解析 - 没看完

[30分钟，让你彻底明白Promise原理](https://segmentfault.com/a/1190000009478377) - 真的看不进去，有需要再看吧

JS的异步编程模型，典型的如下图：

<img src="/../img/assets_2019/image-20210413205034686.png" alt="image-20210413205034686" style="zoom:40%;" />

### 异步回调
Web 页面的单线程架构决定了异步回调，而异步回调影响到了我们的编码方式。

--> 将异步回调函数封装是一个很好的思维，

--> 但是封装后，如果遇到比较复杂的业务场景 **嵌套了太多的回调函数** 就很容易使得自己陷入了回调地狱

代码之所以看上去很乱，归结其原因有两点：

-   第一是嵌套调用，下面的任务依赖上个任务的请求结果，并在上个任务的回调函数内部执行新的业务逻辑，这样当嵌套层次多了之后，代码的可读性就变得非常差了。
-   第二是任务的不确定性，执行每个任务都有两种可能的结果（成功或者失败），所以体现在代码中就需要对每个任务的执行结果做两次判断，这种对每个任务都要进行一次额外的错误处理的方式，明显增加了代码的混乱程度。

### Promise解决了什么问题呢？
-   第一是消灭嵌套调用 -> 可以**实现链式的写法**来实现同步异步操作
-   第二是合并多个任务的错误处理

### Promise 怎么解决嵌套回调问题
1、`Promise` 实现了回调函数的延时绑定 - 创建完 `Promise` 后再用 `.then` 方法绑定回调函数

2、将回调函数 `onResolve` 的返回值穿透到最外层 - 需要通过返回值确认创建什么类型的`Promise`任务

<img src="/../img/assets_2019/image-20210413205128118.png" alt="image-20210413205128118" style="zoom:38%;" />


### Promise 怎么处理异常
即使一个`Promise`有多个回调函数，也可以通过一个 `.catch` 方法来捕获异常 

-->  `Promise` 对象的错误具有“冒泡”性质，会一直向后传递，直到被 `onReject ` 函数处理或 `catch` 语句捕获为止

### Promise 特点 - 状态凝固

**resolve下面的语句其实是可以执行的**，那么为什么 `reject` 的状态信息在下面没有接受到呢？

<img src="/../img/assets_2019/image-20210708164129103.png" alt="image-20210708164129103" style="zoom:38%;" />

`new` 出一个 `Promise` 对象 - 初始化实例时，这个对象的起始状态就是 `Pending` 状态，在根据 `resolve` 或 `reject` 返回 `Fulfilled` 状态/ `Rejected` 状态 —> **resolve与reject只能执行一个**

```javascript
new Promise((resolve, reject) => {
    var param = '🌹🌹🌹';
    if( error ) {
        reject(new Error('Promise 异步执行异常'));
    } else {
        resolve(param);
    }
}).then((res) => {
    console.log(res);  //  🌹🌹🌹
    var param = '🦕🦕🦕';
    return param;
}).then((res) => {
    console.log(res);  //  🦕🦕🦕
}).catch((error) => {
    console.log(error); //  Promise 异步执行异常
});
```

### Promise 特点 - then

`then` 中返回了<span style="color:red">**新的 `Promise`**</span>，但是 `then` 中注册的**回调仍然是属于上一个 Promise** 的；

 `then` 函数是**负责注册回调**的，真正的**执行是在 `Promise` 的状态被改变之后**

<img src="/../img/assets_2019/image-20210708165548959.png" alt="image-20210708165548959" style="zoom:40%;" />

### Promise 特点 - finally

**不管 `Promise` 最后的状态如何，都要执行一些最后的操作**。我们把这些操作放到 `finally` 中，也就是说 `finally` 注册的函数是与 `Promise` 的状态无关的，不依赖 `Promise` 的执行结果。


### Promise 为什么要使用微任务
我们先来简单实现一个Promise -> 仅为展示微任务相关，不作为 Promise 的简单代码实现

<img src="/../img/assets_2019/image-20210413205156971.png" alt="image-20210413205156971" style="zoom:50%;" />

因为定时器的执行效率不是太高，**采用微任务实现了回调函数延迟绑定**，这就是为什么Promise使用微任务的原由了

