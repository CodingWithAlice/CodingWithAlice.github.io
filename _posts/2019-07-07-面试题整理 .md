---
layout:     post
title:      面试题整理
subtitle:  
date:       2019-07-07
author:     
header-img: 
catalog: true
tags:
    - < 面试题整理 >
typora-root-url: ..
---

# 试题整理

刷题错题整理：

1. `setTimeout`的回调函数会**在遍历结束后执行**；

3. static静态方法被设为只能被创建他们的构造器使用，并且不能传递给实例；

   即 **静态方法不能被实例调用**；

4. **函数名**可以**用点语法新增属性**因为函数也是对象（**除了基本类型，都是对象**）；

   **除了基本对象，所有对象都有原型**；

5. 不能够直接给构造函数添加属性，要通过原型结构给函数添加属性；

6. **使用new**后函数中**this指向新创建的对象**；不使用new，函数中this指向全局对象；

7. 

8. 在**测试相等性**时，基本类型通过它们的值进行比较；对象通过它们的引用进行比较（判断是否具有**对内存中相同位置的引用**）；

9. **关闭tab标签页后，`sessionStrorage`存储的数据才会删除**；

10. 使用var声明变量，可以使用**相同的名称，变量将保存最新值**；

11. 如果对象有两个相同名称的键，则键会被替换掉：它仍然处于第一个键出现的位置，但是值是最后出现的那个键的值；

12. **隐式字符串化**：当对象的键也被设置为对象时，会字符串化一个对象，它会变成`[Object object]`;

13. **`call`是立即执行传递this的；`bind`不是立即执行的，返回的是函数的副本**；

14. 只有6种falsy值：**undefined、null、NaN、0、‘’、false**（注：**对象是true**）；

15. `typeOf typeOf 1 =“string”`；

    `typeOf`检测null类型时，返回的是`object`；

    `typeOf`可以检测出的变量的基本数据类型：Number、String、Boolean、Undefined、Symbol、Object（null返回的是Object）、function

16. BOM对象：Screen、Location、History、Navigator；

17. 不要在块内声明一个函数，如果需要的话，就使用函数表达式；

18. **new构造函数的步骤**：

    1. **创建**一个新对象；
    2. 将构造函数的**作用域赋给新对象**（用新对象的隐式原型指向构造函数的显式原型，用call改变this指向，因此this就指向了这个新对象）；
    3. 执行构造函数中的代码（**为这个新函数添加属性**）；
    4. **返回**新对象；

19. 怎么**改变this指向**？

    1. 使用**箭头函数**；
    2. 在函数内部使用`_this=this;`
    3. 使用**apply、call、bind**
    4. new**实例化一个对象**；

21. `stopPropagation()`**阻止事件冒泡**，但不会阻止定义在元素上的其他事件；

    `stopImmediatePropagation()`**彻底阻止事件**，在其之后绑定在元素上的其他监听事件都不会触发；

22. 视口的缩放配置的目的：为了让css样式中的逻辑像素匹配手机终端的物理像素，让网页视图适合手机屏幕；

    使用rem单位的目的：为了让一份代码适应大部分不同屏幕的手机；

    自适应：在同一终端下，页面布局根据视口本身的变化而自动调节布局（如PC端页面变化、resize事件等）；

    响应式：指页面根据检测到的不同终端类型，自动调整布局；





### 1. 跨域怎么实现？jsonp的原理是什么？

跨域，指的是浏览器不能执行其他网站的脚本。浏览器执行`javascript`脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。

![img](/img/assets_2019/1620)

解决办法：

①**JSONP**：注意JSONP只支持GET请求，不支持POST请求。

原理：ajax请求受同源策略影响，不允许进行跨域请求，而**script标签src属性**中的链接却可以**访问跨域的js脚本**，利用这个特性，服务端不再返回JSON格式的数据，而是**返回一段调用某个函数的js代码**，在src中进行了调用，这样实现了跨域。

②**代理**：写后端接口，在后端调用页面拿到返回值返回给html文件。相当于绕过了浏览器，就不会存在跨域问题。

③**PHP端修改header**

```javascript
header('Access-Control-Allow-Origin:*');//允许所有来源访问
header('Access-Control-Allow-Method:POST,GET');//允许访问的方式
```



### 2. 有哪几种存储方式？有什么不同？

`cookie`、`localStorage`、`sessionStorage`；

相同点：都保存在浏览器端；

不同点：

**①传递方式不同**

​	`cookie`数据始终在**同源的http请求中携带**（即使不需要），即`cookie`在浏览器和服务器间来回传递。

​	`sessionStorage`和`localStorage`不会自动把数据发给服务器，**仅在本地保存**。

**②数据大小不同**

​	（`cookie`数据还有路径（path）的概念，可以限制cookie只属于某个路径下。）
​	存储大小限制也不同，cookie数据**不能超过4k**，同时因为每次http请求都会携带`cookie`，所以cookie只适合保存很小的数据，如会话标识。

​	`sessionStorage`和`localStorage` 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

**③数据有效期不同**

​	`sessionStorage`：仅在当前**浏览器窗口关闭前有效**，自然也就不可能持久保持；

​	`localStorage`：**始终有效**，窗口或浏览器关闭也一直保存，因此用作持久数据；

​	`cookie`只在设置的**cookie过期时间之前**一直有效，即使窗口或浏览器关闭。

**④作用域不同**

​	`sessionStorage`**不在不同的浏览器窗口中共享**，即使是同一个页面；

​	`localStorage `在所有**同源窗口中都是共享**的；

​	`cookie`也是在所有**同源窗口中都是共享**的。



### 3.点击按钮进行数据请求，怎么实现按序执行请求？

问：点击页面上一个按钮发送两个ajax请求，其中一个请求会不会等待另一个请求执行完毕之后再执行？

答：不会，这两个异步请求会同时发送，执行的快与慢是看响应的数据量的大小及后台逻辑的复杂程度。

问：怎么让它们按序执行？

答：两种方案：

1. Ajax2()方法的执行放到Ajax1()的success**回调函数**的最后一行。
2. Ajax1()的异步请求方法中，增加一个回调函数 ：**complete : Ajax2**



### 4. jQuery和Vue使用起来有什么区别？

​        从jquery到vue或者说是到mvvm的转变则是一个思想想的转变，是将原有的直接操作dom的思想转变到操作数据上去。

​        从技术角度讲，Vue.js 专注于 MVVM 模型的 ViewModel 层。它通过双向数据绑定把 View 层和 Model 层连接了起来，通过对数据的操作就可以完成对页面视图的渲染。



​        jQuery是使用选择器（$）**选取DOM对象**，对其进行赋值、取值、事件绑定等操作，和原生的区别只在于可以更方便的选取和操作DOM对象，其数据和界面是在一起的。

​        Vue则是通过Vue对象将数据和View层分离开来。**对数据进行操作**不再需要引用相应的DOM对象，通过Vue对象这个vm实现相互的绑定。



​        vue**适用的场景**：复杂数据操作的后台页面，表单填写页面；vue侧重数据绑定；

　　jquery**适用的场景**：比如说一些html5的动画页面，一些需要js来操作页面样式的页面；jquery侧重样式操作，动画效果等；



## 5.cookie和session了解吗？

`cookie`和`sessiom`是两种**保持会话**状态的方法。

​	cookie就是指客户端在向服务端发起请求的时候，服务端会在进行response的时候给当前客户端的一小段文本信息，并保存在当前的客户端的浏览器中，这一小段cookie文本信息也就是这个客户端去访问服务端的通行证，有了这个通行证，以后当这个客户端再去访问服务端的时候，服务端便知道是谁拿着通行证去进行访问了。

​	session和cookie的功能类似，也是一种保持会话状态的方式，在用户使用浏览器发起会话时，服务器会为每一个用户浏览器提供一个单独的session对象来保存用户的数据，并将它保存在服务端，而当用户访问其他web资源的时候，则可以从保存用户数据的session对象中把用户数据抽取出来并进行访问。

**区别**：

1. cookie的用户数据是保存在**用户浏览器**的cookie中的；

session的用户数据是保存在**服务器为用户浏览器单独创建的session对象**中的。

2. 数据的读取和调用，cookie可以采用request.getCookies这种方法；

   session则可以用request.Session的方法。

3. 安全性，cookie是存储在**用户浏览器**中的；

   而session是**存储在服务器**上的，所以session比cookoe要相对安全；



## 30. npm中的工具了解过吗？（yarn）

**npm就是JavaScript的包管理工具。**npm主要用来下载，安装，管理第三方模块。

创建一个包描述文件：`npm init [-y]`

查看包的信息 `npm info <package-name>`

查看包的版本信息 `npm info <package-name> versions`

安装指定的包：`npm install <package-name>`
 默认会安装在当前目录下的 node_modules 目录下，如果 node_modules 不存在，则会自动创建。
本地安装包，如果包里有可执行文件，则npm会把可执行文件安装到 node_modules/.bin 目录下。

安装指定版本的包：`npm install <package-name>@<version>`

安装包并记录依赖，会在 package.json 中 dependencies 属性记录依赖`npm install <package-name> --save`

卸载包：`npm uninstall <package-name>`

更新包：`npm update <package-name>`

全局安装包，把包安装在全局目录，供所有项目使用:`npm install <package-name> -g`
全局安装包，如果包里有可执行文件，则npm会把可执行文件安装到 node_modules 上一级目录中。

查看全局目录：`npm root -g`

修改全局目录的路径：`npm config set prefix ``"新路径"`
默认情况下全局安装的包不能直接在项目中加载，如果要直接加载，需要在系统环境变量中添加一个名为 NODE_PATH 的变量，值为全局安装目录下 node_modules 位置。

查看npm配置 `npm config list`



## 7. Node.js了解吗？

​		根据官方文档可以知道，node就是一个给予谷歌v8引擎的一个javascript的运行时，可以理解为**运行js的一个虚拟机**。他使用的是一个事件驱动，非阻塞I/O模型 ，他是**将js的运行环境搬到了服务器端**，和客户端没有一点关系。是一个纯服务端的东西，node只是**为js提供了一个平台**。

　　node里面其实还分了两块，一是封装了v8引擎，目的是为了执行es（如定义变量，定义函数等），另外一个提供了大量的工具库，是帮助node实现各种功能的，提供了一些以前js的环境办不到的事情，比如文件操作，网络操作，操作系统的操作。

​	既然node是一个平台（所谓的平台就是用来运行特定语言的），也就意味着node是用来运行语言的，那么java也是语言，node能运行java吗？据nodejs创始人Ryan Dahl回忆，他最初是选择了Ruby这门语言，但是Ruby这门语言的虚拟机效率不怎么样最终放弃了，按照这种思路，貌似node将java的虚拟机集成进来应该可以运行java，但node作者最终选择了javascript。

　　这样js就实现了在服务端运行的可能，js运行在node平台上（分为v8部分，用来执行es，和大量的工具库组件（API）称之为libuv，提供了以前js的环境办不到的事，如文件操作，网络操作等等）。

用途：

​		（1）node可以**接受客户端用户的所有请求**，并且能够快速的给出响应，因此node可以用来做网站。

　　（2）node可以作为一个**中间层来来分发调用数据接口**，比如有一个网站数据是有java提供的，我们可以让node作为一个中间层，来接受用户的请求，然后**通过node来调用java数据接口**，获取到数据后直接在node层面做html的封装，然后将渲染好的页面直接给用户。为什么要这样做，直接请求java接口不行吗，这是因为node被称之为**高性能的web服务器**，在**并发和抗压**方面都比传统的平台要好很多，因此这样一包装可以极大的减轻服务器的开发。

　　通过上面的两点，可以总结出，node在web中要么从前端页面到后端服务全包了，一个是只做其中的一点。

　　**一言以蔽之，node就是一个javascript的运行环境（平台），他不是一门语言，也不是javascript的框架。可以用来开发服务端应用程序，web系统。其特点是体积小，快速，高性能。**



### 8.城市搜索和区块联动用的组件怎么实现的？

城市搜索功能是将input输入的内容，绑定到变量keyword上面，然后用watch监听这个变量，一旦变量变化，就用变量执行indexOf的方法去便利城市的name和value值，将得到的值push进入数组，然后将数组遍历显示在ul>li里面。

```javascript
 watch: {
    keyword () {
      if (this.timer) {
        clearTimeout(this.timer)
      }
      if (!this.keyword) {
        this.list = []
        return
      }
      this.timer = setTimeout(() => {
        const result = []
        for (let i in this.cities) {
          this.cities[i].forEach((value) => {
            if (value.spell.indexOf(this.keyword) > -1 || value.name.indexOf(this.keyword) > -1) {
              result.push(value)
            }
          })
        }
        this.list = result
      }, 100)
    }
  },
```

```html
	<div
      class="search-content"
      ref="search"
      v-show="keyword"
    >
      <ul>
        <li
          class="search-item border-bottom"
          v-for="item of list"
          :key="item.id"
          @click="handleCityClick(item.name)"
        >
          {{item.name}}
        </li>
        <li class="search-item border-bottom" v-show="hasNoData">
          没有找到匹配数据
        </li>
      </ul>
    </div>
```

区块联动的组件

给每个字母都绑定ref，同时绑定方法，点击的时候；移动的时候，根据高度来进行区域块的联动

```html
<template>
  <ul class="list">
    <li
      class="item"
      v-for="item of letters"
      :key="item"
      :ref="item"
      @touchstart.prevent="handleTouchStart"
      @touchmove="handleTouchMove"
      @touchend="handleTouchEnd"
      @click="handleLetterClick"
    >
      {{item}}
    </li>
  </ul>
</template>
```

```javascript
<script>
export default {
  name: 'CityAlphabet',
  props: {
    cities: Object
  },
  computed: {
    letters () {
      const letters = []
      for (let i in this.cities) {
        letters.push(i)
      }
      return letters
    }
  },
  data () {
    return {
      touchStatus: false,
      startY: 0,
      timer: null
    }
  },
  updated () {
    this.startY = this.$refs['A'][0].offsetTop
  },
  methods: {
    //点击字母的时候，将点击得到的内容字母向父级传输，触发change的方法
    handleLetterClick (e) {
      this.$emit('change', e.target.innerText)
    },
    handleTouchStart () {
      this.touchStatus = true
    },
    //手指移动的时候，节流一下，同时也是触发父级的change，将手指滑动的内容传递
    handleTouchMove (e) {
      if (this.touchStatus) {
        if (this.timer) {
          clearTimeout(this.timer)
        }
        this.timer = setTimeout(() => {
          const touchY = e.touches[0].clientY - 79
          const index = Math.floor((touchY - this.startY) / 20)
          if (index >= 0 && index < this.letters.length) {
            this.$emit('change', this.letters[index])
          }
        }, 16)
      }
    },
    handleTouchEnd () {
      this.touchStatus = false
    }
  }
}
</script>
```



### 9.用Ajax的时候，get和post有什么区别？

​	GET和POST都是HTTP协议中的两种发送请求的办法，都是基于TCP/IP。

​	get 和post 安全等级是同级别的，不要说安全区别，都不安全，get有数据缓存的问题，清缓存query需要加时间戳，post就不会有这个问题。（站友分享思路）

| GET                                    | POST                               |
| -------------------------------------- | ---------------------------------- |
| 向服务器获取指定资源                   | 向服务器提交数据，数据放在请求体里 |
| **把参数包含在`URL`中**                | 通过`request body`传递参数         |
| 有长度限制，2kB                        | 没有限制                           |
| 只能进行`URL`编码                      | 支持多种编码方式                   |
| 在浏览器**回退时是无害的**             | 在浏览器回退时，POST会再次提交请求 |
| GET请求会被浏览器**主动cache**         | POST不会缓存，除非手动设置         |
| 请求参数会被完整保留在浏览器历史记录里 | 参数不会被保留                     |



### 10.bootstrap中的栏栅一行有12个，是怎么做到的？

​	总共有**五个栅格等级**，每个响应式分界点隔出一个等级：特小`.col-`、小`.col-sm-`、中 `.col-md-`、大`.col-lg-`、特大`.col-xl-`。

​	使用的row行必须包裹在`container`和`container-fluid`下，外部容器一个是`container`，一个是`container-fluid`，第一个**`container`是固定宽度，居中在网页中间**，第二个**`container-fluid`是百分比宽度，宽度为100%**，根据情况我们可以选择不同的容器。

![](/img/assets_2019/container.png)

**工作原理**：

​	栅格系统提供了**内容居中**、**水平填充**网页内容的方法，`.container`实现固定的宽度并居中呈现，`.container-fluid`实现全宽度，并和其它网格实现对齐。

​	行(.row)是列(.col-*)的横向组合和父容器，**每列都有水平的padding值**，用于控制列与列之间的间隔，同时在负边距的行上抵消，从而实现列中的所有内容在视觉上是左侧对齐的体验。

​	.row上带有`margin-left: -15px;margin-right: -15px;`属性，你可以在.row上上定义`.no-gutters`属性，从而消除这个属性，使页面不会**额外宽出30px**，即`<div class="row no-gutters"...`。

​	`.col-*`的`width`属性(即列宽)是**用百分比来表现**和定义的，所以它们总是流式的，其尺寸大小受父元素的定义影响。

|                                    | 超小屏幕（新增规格）<576px | 小屏幕  次小屏≥576px | 中等屏幕  窄屏≥768px | 大屏幕  桌面显示器≥992px | 超大桌面  大桌面显示器≥1200px |
| ---------------------------------- | -------------------------- | -------------------- | -------------------- | ------------------------ | ----------------------------- |
| container最大宽度                  | None（auto）               | 540px                | 720px                | 960px                    | 1140px                        |
| 类前缀                             | \.col\-                    | \.col\-sm\-          | \.col\-md\-          | \.col\-lg\-              | \.col\-xl\-                   |
| 列数                               | 12列                       | 12列                 | 12列                 | 12列                     | 12列                          |
| Gutter width（都是每列两侧各15px） | 30px                       | 30px                 | 30px                 | 30px                     | 30px                          |
| 列间隙（都是每列两侧各15px）       | 30px                       | 30px                 | 30px                 | 30px                     | 30px                          |
| 都可嵌套、可排序                   |                            |                      |                      |                          |                               |



### 11.轮播图实现的时候是怎么考虑的？

四种方式实现：

​	swiper插件实现轮播图；

​	JS实现轮播图；

​	jQuery实现轮播图；

​	css3实现轮播图；

```javascript
		// 1. 克隆元素
        ul.appendChild(ul.children[0].cloneNode(true));
        // 2.创建ol 和li
        var ol = document.createElement("ol");//创建ol元素
        scroll.appendChild(ol);// 把ol放到scroll盒子里面去
        for (var i=0;i<ulList.length-1;i++) {
            var li = document.createElement("li");// 创建li元素
            li.innerHTML = i + 1;// 给li里面添加文字  1 2 3 4 5
            ol.appendChild(li);// 将li元素添加到ol里面
        }
        ol.children[0].className = "current";
// ol中的第一个li背景色为purple现无缝滚动就需要多一张图片才行，即克隆第一张图片，放到最后面
```

```javascript
//动画函数：
		// 动画函数的第一个参数，代表动画对象；第二个参数代表动量
        // 让图片做匀速运动，匀速动画的原理是:当前的位置 + 速度,即 offsetLeft + speed
        function animate(obj,target){
            // 首先清除掉定时器
            clearInterval(obj.timer);
            // 用来判断 是+ 还是 -  即说明向左走还是向右走
            var speed = obj.offsetLeft < target ? 15 : -15;
            obj.timer = setInterval(function(){
                var result = target - obj.offsetLeft;//它们的差值不会超过speed
                obj.style.left = obj.offsetLeft + speed + "px";
                // 有可能有小数的存在，所以在这里要做个判断             
                if (Math.abs(result) <= Math.abs(speed)) {
                    clearInterval(obj.timer);
                    obj.style.left = target + "px";
                }
            },10);
        }
```

```javascript
//定时器函数：
		var timer = null; 	// 轮播图的定时器
        var key = 0;		// 控制播放的张数
        var circle = 0;		// 控制小圆点

        timer = setInterval(autoplay,1000);// 自动轮播
        function autoplay(){
/*自动轮播时,要对播放的张数key进行一个判断,如果播放的张数超过ulLis.length-1,就要重头开始播放.  
		因为我们克隆了第一张并将其放在最后面,所以我们要从第二张图片开始播放*/
            key++; 						// 先++
            if(key > ulLis.length-1){	// 后判断
                ul.style.left = 0; 		// 迅速调回
                key = 1; 				// 因为第6张是第一张，所以播放的时候是从第2张开始播放
            }
// 动画部分
            animate(ul,-key*liWidth);

// 小圆点circle，当显示第几张图片是，对应的小圆点的颜色也发生变化 
            /*同理,对小圆点也要有一个判断*/
            circle++;
            if (circle > olLis.length-1) {
                circle = 0;
            }
            // 小圆点颜色发生变化
            for (var i = 0 ; i < olLis.length;i++) {
                // 先清除掉所用的小圆点类名
                olLis[i].className = ""; 
            }
            // 给当前的小圆点 添加一个类名
            olLis[circle].className = "current";

        }
```



#### 12.前端性能优化的方法，举例说明

##### ①内容方面

减少HTTP请求次数
减少DOM操作
减少DNS查询
使用Ajax 可缓存

##### ②css方面

把css样式HTML代码页的上端
从页面中分离css代码，从外部引入
压缩代码
不要使用@import
避免css表达式

##### ③js方面

脚本放到HTML代码页底部
从页面中分离js代码，从外部引入
压缩代码
减少对DOM的访问
移除重复的脚本

##### ④图片方面

优化图片（少用图片用css3新特性代替，使用矢量图代替位图）
矢量图：图标字体。 位图：GIF、JPG、PNG
不要在HTML中使用缩放图片
使用恰当的图片格式
按照HTTP协议设置合理的缓存
用css或js实现预加载
WebP图片格式能给前端带来优化
WebP格式：谷歌开发一种旨在加快图片加载速度的图片格式

```
(function(){
	try{
		console.log(a);
		
		var a="a";
		console.log(a);
		b();
		c(); 
		
		function b(){
			console.log("b");
		}
		var c=function(){
			console.log("c");
		}
		console.log("d")
        
        }
})
```



#### 13.SEO搜索引擎优化有哪些方法？

1.创建唯一且准确的**网页标题` <title>`**

```html
<title>前端搜索引擎优化的技巧</title>
```

2.使用 **`<meta>` 的 `keywords` 元数据**来提炼网页重要关键字，以及 `description` 元数据准确总结网页内容。

```html
<meta name='keywords' content='SEO,title,meta,语义化,alt'>
<meta name='description' content='介绍搜索引擎优化的技巧:语义化标签、img的alt属性等。'>
```

3.使用**语义化元素**：`<em>` 或 `<strong>`

4.利用**` <img> `中的`alt` 属性**

5.设置`rel='nofollow' `忽略跟踪

6.尽量让结构（HTML）、表现（CSS）及行为（JavaScript）**三者分离**。如果在一个 HTML 页面中，编写大量的 CSS 样式或脚本，会拖慢其加载速度，此外，如果不为 `<img>` 定义宽高，那么会引起页面重新渲染，同样也会影响加载速度。一旦加载超时，“蜘蛛”就会放弃爬取。如果这个 HTML 文档内容比较独特丰富（合理插入图片说明）等，会被认为质量较高符合用户需求，从而提高 SEO 的排名。









1.数组常用的遍历方法有哪几种？（for...in一般用于对象）

2.Canvas绘图；

14.Webpack；

4.Ajax遇到拦截器，请求数据要重新处理怎么做？

5.git的使用，常用操作代码有哪些？

8.左边固定，右边自适应

9.学过哪些基础框架？

10.vue源码了解过吗？怎么实现数据的劫持？

12.Promise、async await 的使用？

15.jQuery中绑定时间用的on和bind有什么区别？

16.前端常用的性能优化有哪些？加快页面打开的速度怎么处理？

17.vue-cli如何使用json数据模拟？

19.数组的常用操作方法？其中splice 和slice有什么区别？

20.js中怎么绑定事件？

21.事件委托是什么？

22.HTTP请求中，头部有一个请求，请求头：content-type，发送请求的数据类型

23.ES6中的Promise方法，有两个参数，分别代表什么（记不清了，引到for in）

24.for...in和for ...of 的区别：for...of循环的i代表的是value（多用于数组），for...in循环的是key（多用于对象）

25.bootstrap用了哪些，jQuery用了哪些，css选择器有哪几种，有哪些优先级，+  > 分别表示什么，子代/后代

26.vue中的计算属性computed、watch有什么区别，分别应用于什么场景

27.vue的生命周期，用过的有哪些，怎么用的描述一下；一般在mounted里面用什么

28.Photoshop的使用，学校竞赛的情况，写的项目详细描述一下，用的vue的什么版本

29.项目中轮播图、列表、联动、递归展示使用，后台数据怎么模拟，获取的地址是怎么写的，面试官会详细听，问到代码，甚至会给出一定的意见（v-for改为数组管理），项目的难点在哪里

30.项目中用到v-for，其中的key值作用，使用效率如何，没有用key会怎么样

31.vue中父子组件传值，用vuex组件传值的时候，代码是怎么写的

32.学习的方法有哪些，《js高级程序设计》中函数重载了解吗

33.在js的浏览器对象模型中，window对象的（）属性是用来指定浏览器状态栏里面的临时消息

35.eval()函数可以解释由js源代码组成的字符串吗？该函数能用调试工具进行断点调试吗？该函数是js自带的函数，会不会引起安全性问题？该函数动态解释字符串，会存在效率问题吗？

36.一般html网页元素加载完成后，会触发哪个事件？onready onchange onload onblur

37.addEventListener可以多次给DOM对象增加监听事件吗？

38.attachEvent可以删除DOM对象的监听事件吗

` attachEvent`绑定的事件，如果需要注销，应该使用`detachEvent`

40.form标签对之间，可以出现p、ul等非表单域元素吗

41.在js中，两个整数进行除（/）运算，结果也为整数吗？

42.属性document.body.scrolWidth表示网页中滚动条的宽度吗？

43.HTTP常见的状态码

44.js或DOM操作方便，浏览器兼容的注意项有哪些

45.Web前端开发常见的安全漏洞

46.冒泡排序

47.深拷贝代码

49.单页面应用的优缺点

50.轮播图的实现及后台数据抓取

51.安全性，在无法使用HTTPS的情况下，局域网如何实现防止报文攻击

52.列举常用浏览器以及说明其内核

53.http和https分别是什么，有什么区别

55.从输入URL到页面加载完成，发生了什么

56.可以通过什么途径查看一个网站所使用的技术

57.react的核心是什么

59.为什选择`vue+element`这样一个体系搭建系统？有什么吗优点？

60.在实习的项目中，你学到了什么？你认为现在的项目有什么可以优化的地方？

61.公司要求写代码，用js原生仿照发布者订阅者模式写。

62.写一个左侧导航栏，不能调试，鼠标移动底部变色，参照京东左侧导航栏

63.原型链有了解么？
64.虚拟DOM说一下？在生命周期里的对应阶段？
65.用的前端组件是什么？
66.画一下项目的界面结构并且简单介绍下项目
67.问了一下通讯录界面的布局
68.验证码有写过没
69.npm有学过除简单命令之外的服务构建么？
70.说一下webpack的配置问题
71.echarts有用过么？WebGL知道么？
73.数据结构了解多少？数据库呢？
74.es6怎么声明类？继承怎么写？提出是为了解决什么问题？

75.在这半年多的学习过程中，觉得前端学习的难点在哪里：封装的太好，原生其实很难

76.评价一下现在实习的这个项目，包括系统设计之类的：优点：功能和样式都还原了 缺点：html和样式耦合；组件化成都不高，代码难以维护

77.怎么样去查看内存、性能：性能chrome调试的时候用network的网络选项，内存不清楚

78.react用过吗？讲了一下react和vue之前，jQuery和bootstrap，问学过吗？

79.数据结构、算法之类的了解吗：学习过但是使用较少，大致讲了下堆栈；讲一下数组去重的题；思想很重要

81.http与https
82.画一个三角形
83.实现0.5px横线
84.rem 与em
rem相对于根节点。em相对于父元素
87.盒子模型height
88.定时器一秒加一次
89.滚动条
90.Webscoket（解决痛点）

