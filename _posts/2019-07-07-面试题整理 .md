---
layout:     post
title:      面试题整理
subtitle:  
date:       2019-07-07
author:     
header-img: 
catalog: true
tags:
    - < 面试题整理 >
typora-root-url: ..
---

# 面试题整理

刷题错题整理：

1. `setTimeout`的回调函数会**在遍历结束后执行**；

2. 箭头函数中的**this指向定义时**当前周围的作用域；

3. static静态方法被设为只能被创建他们的构造器使用，并且不能传递给实例；

   即 **静态方法不能被实例调用**；

4. **函数名**可以**用点语法新增属性**因为函数也是对象（**除了基本类型，都是对象**）；

   **除了基本对象，所有对象都有原型**；

5. 不能够直接给构造函数添加属性，要通过原型结构给函数添加属性；

6. **使用new**后函数中**this指向新创建的对象**；不使用new，函数中this指向全局对象；

7. 如果使用标记模板字面量，第一个参数的值总是字符串的数组。其余的参数获取的是传递的表达式的值；

8. 在**测试相等性**时，基本类型通过它们的值进行比较；对象通过它们的引用进行比较（判断是否具有**对内存中相同位置的引用**）；

9. **关闭tab标签页后，`sessionStrorage`存储的数据才会删除**；

10. 使用var声明变量，可以使用**相同的名称，变量将保存最新值**；

11. 如果对象有两个相同名称的键，则键会被替换掉：它仍然处于第一个键出现的位置，但是值是最后出现的那个键的值；

12. **隐式字符串化**：当对象的键也被设置为对象时，会字符串化一个对象，它会变成`[Object object]`;

13. **`call`是立即执行传递this的；`bind`不是立即执行的，返回的是函数的副本**；

14. 只有6种falsy值：**undefined、null、NaN、0、‘’、false**（注：**对象是true**）；

15. `typeOf typeOf 1 =“string”`；

    `typeOf`检测null类型时，返回的是`object`；

    `typeOf`可以检测出的变量的基本数据类型：Number、String、Boolean、Undefined、Symbol、Object（null返回的是Object）、function

16. BOM对象：Screen、Location、History、Navigator；

17. 不要在块内声明一个函数，如果需要的话，就使用函数表达式；

18. **new构造函数的步骤**：

    1. **创建**一个新对象；
    2. 将构造函数的**作用域赋给新对象**（用新对象的隐式原型指向构造函数的显式原型，用call改变this指向，因此this就指向了这个新对象）；
    3. 执行构造函数中的代码（**为这个新函数添加属性**）；
    4. **返回**新对象；

19. 怎么**改变this指向**？

    1. 使用**箭头函数**；
    2. 在函数内部使用`_this=this;`
    3. 使用**apply、call、bind**
    4. new**实例化一个对象**；

20. **css3有哪些新特性**？
    1. 实现圆角`border-radius`、阴影`box-shadow`、`border-image`；
    2. 对文字加特效`text-shadow`、线性渐变`gradient`、旋转`transform`；
    3. `transform`：旋转`rotate（9deg）`、缩放`scale（0.85,0.9）`、定位`translate（0px，-30px）`、倾斜`skew（-9deg、0deg）`；
    4. 增加了更多的css选择器、多背景、rgba
    5. 在css3中引入为一个的伪类：：selection
    6. 媒体查询、多栏布局

21. `stopPropagation()`**阻止事件冒泡**，但不会阻止定义在元素上的其他事件；

    `stopImmediatePropagation()`**彻底阻止事件**，在其之后绑定在元素上的其他监听事件都不会触发；

22. 视口的缩放配置的目的：为了让css样式中的逻辑像素匹配手机终端的物理像素，让网页视图适合手机屏幕；

    使用rem单位的目的：为了让一份代码适应大部分不同屏幕的手机；

    自适应：在同一终端下，页面布局根据视口本身的变化而自动调节布局（如PC端页面变化、resize事件等）；

    响应式：指页面根据检测到的不同终端类型，自动调整布局；





# 面试题整理（笔试）

1. **跨域**怎么实现？**jsonp**的原理是什么？

2. **h5**新标签有哪些？为什么要加强语义化？

3. 为什么要**清除浮动**？怎么清除浮动？

4. **行内元素、块元素**有哪些？它们有什么不同？

5. 有哪几种**存储方式**？有什么不同？

6. **setTimeout**输出值的时候，如何实现i按序输出？

7. vue实现**双向绑定的原理**？

8. vue**组件之间的传值**？

9. 点击按钮进行数据请求，怎么实现**按序执行请求**？

10. 怎么让文本**不自动换行**？怎么让超过文本部分变成省略号？

11. vue的**生命周期**有哪些？它们有什么不同？

    

12. **vuex**的功能？能否进行兄弟组件之间的传值？

13. **Axios**调取数据？

14. **继承prototype**大概是怎么实现的？

15. es6中和原型一样用来继承的**class和继承**是怎么实现的？

16. **jQuery和Vue**使用起来有什么区别？

17. vue父子组件传值怎么实现的？（参考8）

18. 兄弟组件传值怎么实现的？（参考8）

19. 怎么**调程序**中出现的代码？

20. js的**垃圾回收机制**？

21. es6中**const、let、var**之间的区别？

22. **闭包**是什么？用let怎么实现闭包？

    

23. 闭包是什么？有什么**优点和缺点**？
24. css中怎么使盒子**上下居中**（面试官说水平居中太简单了orz...）？
25. js中本地存储有哪些？有什么不同？（参考第5题）
26. **cookie、session**了解吗？
27. 跨域了解吗？（参考第1题）
28. **this**的指向问题？
29. vue使用的**UI框架**？
30. **npm、yarn**的工具了解过吗？
31. **Node.js**了解吗？  
32. 详细讲一下项目？后端调用？（无答案）



33. js中的**闭包**是什么？

34. **v-if和v-show**之间的区别？

35. v-for中**key值**的作用？

36. vue中**插槽**的作用？

37. js的**执行机制**？

    

详解：

### 1. 跨域怎么实现？jsonp的原理是什么？

跨域，指的是浏览器不能执行其他网站的脚本。浏览器执行`javascript`脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。

解决办法：

①**JSONP**：注意JSONP只支持GET请求，不支持POST请求。

原理：ajax请求受同源策略影响，不允许进行跨域请求，而**script标签src属性**中的链接却可以**访问跨域的js脚本**，利用这个特性，服务端不再返回JSON格式的数据，而是**返回一段调用某个函数的js代码**，在src中进行了调用，这样实现了跨域。

②**代理**：写后端接口，在后端调用页面拿到返回值返回给html文件。相当于绕过了浏览器，就不会存在跨域问题。

③**PHP端修改header**

```javascript
header('Access-Control-Allow-Origin:*');//允许所有来源访问
header('Access-Control-Allow-Method:POST,GET');//允许访问的方式
```



### 2. h5新标签有哪些？为什么要加强语义化？

新标签：

**文档类型设定**：`<!doctype html>`；

**字符设定**：`<meta charset="utf-8">`；

**常用新标签**：

​	`header`，一般作为网页的**头部**使用，可以多个；

​	`footer`，底部，**不一定是文档最底部**，可以多个；

​	 `aside`，**侧边**栏；

​	 `nav`，**导航**栏；

​	`article`，独立内容区域，与session类似，**用于文章blog、帖子、短文或者回复、评论**等；

​	`section`，代表某一个区域/分区/页面/文档的**一部分区域**，有独立的内容，但结构相近，就可以用section，范围比div大，语义比div更强，可以包含header、`h1-h6`……凸显语义的标签；

​	`datalist `，**标签定义选项列表**，请与 input 元素配合使用该元素；

```html
<input type="text" value="输入" list="TFboys"/> <!--  input里面用list -->
<datalist id="TFboys">   <!-- datalist里面用id -->  
        <option>易烊千玺</option>
            <option>王俊凯</option>
        <option>王源</option>
</datalist>
```

​	`fieldset`，可**将表单内的相关元素分组**，打包legend（为`fieldset`元素定义标题）使用；

```html
	<fieldset>
	<legend>用户登录</legend>
    	用户名: <input type="text"><br />
		密　码: <input type="password">
    </fieldset>
```

​	 `address`，**标签定义文档或文章的作者/拥有者的联系信息**，字体样式默认倾斜；
​    ​`time`，时间标签，主要用于搜索引擎和其它一些内容引擎特殊的解析和展示；
​    `hgroup`，专门用来包含标题**h标签的分组**；

​	`detail`，*细节、详情* ，open属性：默认展开，summary相当于详情的标题；



​	**新增了许多input type属性**：`email`、`tel`、`url`、`number`、`search搜索框，加强语义`、`range自由拖动滑块`、`time`、`date日期`、`datetime时间`、`month`、`week`
​    

​	**新增了许多input的属性**：`placeholder占位符，默认文字`、`autofocus页面加载时自动获得焦点`、`multiple多文件上传`、`autocomplete`、`required必填项`、`accesskey规定激活元素的快捷键`
​    

​	**多媒体标签**：`embed定义嵌入的内容`、`audio播放音频`、`video播放视频`；

​	`src导入`，`autoplay自动播放`、`controls是否默认显示播放件`、`loop循环播放`

​	......

​    原因：1.默认样式不一样 ；2.有SEO优化作用；
​    

### 3.为什么要清除浮动？怎么清除浮动？

**产生原因**：子盒子浮动导致的父盒子内高度为 0 ，父级盒子不能被撑开，发生**高度塌陷**的情况。



**带来的负作用**：

1. **背景**不能显示
2. **边框**不能撑开
3. **margin和padding值**不能正确显示



**清除浮动的方法**：

1. 给**父盒子**设置合适的**高度**；
2. 给**父盒子添加样式 `overflow:hidden/auto;`**（这个属性相当于触发BFC，让父级紧贴内容，包括使用了浮动的盒子）（为了去除兼容性问题，会添加`zoom:1;`）
3. 在父盒子里面的子盒子后面**添加一个子盒子**，如div，**添加样式 `.clear{ clear:both; }`；**
4. 采用**伪元素，给父元素追加`:after`**，给父元素添加一个类`.clearfix{content:"";clear:both;}`



**BFC块级格式化上下文的特征**：

- 内部的Box会在**垂直方向**，从顶部开始**一个接一个**地放置；

- Box垂直方向的距离由margin决定。属于同一个BFC的两个**相邻Box的margin会发生叠加**。

- 每个元素的margin box的左边， **与包含块**border box的**左边相接触**，即使存在浮动也是如此。

- BFC的区域不会与float box叠加。

- BFC就是页面上的一个**隔离的独立容器**，容器里面的子元素**不会影响到外面的元素**，反之亦然。

- 计算BFC的高度时，**浮动元素也参与计算**。

  

**创建块级格式化上下文**：

- **浮动** (元素的 float不为 none）

- **绝对定位元素** (元素的 position为 absolute 或 fixed)

- **行内块** inline-blocks (元素的 display: inline-block)

- **表格单元格** (元素的 display: table-cell，HTML表格单元格默认属性)

- **表格标题** (元素的 display: table-caption，HTML表格标题默认属性)

- **overflow的值不为 visible的元素**(元素的 overflow: hidden，overflow: auto)

- **弹性盒**子 flex boxes (元素的 display: flex 或 inline-flex)

  

### 4.行内元素、块元素有哪些？它们有什么不同？

行内元素：b、span、a、u、em、i、img、input、select、label、textarea、button

块级元素：div、h、ol、ul、dl、li、table、td、th、tr、dd、dt、p、caption

- 行内元素的特点：

  1、行内元素**只能容纳文本或者其他行内元素**。

  2、**宽度只与内容有关**。

  3、和其他元素都**在一行上**。

  4、高，行高及外边距和内边距**部分可改变**。

- 块级元素的特点：

  1、高度，行高以及外边距和内边距**都可控制**。

  2、总是在新行上开始，**占据一整行**。

  3、它可以**容纳内联元素和其他块元素**。

  4、**宽度**始终是与浏览器宽度一样，**与内容无关**。

- 区别：

  1、**行内元素**会在**一条直线上分列**，都是统一行的，程度偏向分列。

  ​	  **块级元素各盘踞一行**，垂直偏向分列；块级元素重新行开端停止接着一个断行。

  2、**行内元素**不可以包括块级元素，只能包容文本或许其余行内元素。

  ​	  **块级元素**能够包括行内元素和块级元素，还能够包容内联元素和其余元素；。

  3、行内元素与块级元素属性的分歧，主要在盒模子属性上。

  **行内元素**设置width无效，height无效（**能够设置line-height**），margin、padding设置上下有效。

  

### 5. 有哪几种存储方式？有什么不同？

`cookie`、`localStorage`、`sessionStorage`；

相同点：都保存在浏览器端；

不同点：

**①传递方式不同**

​	`cookie`数据始终在**同源的http请求中携带**（即使不需要），即`cookie`在浏览器和服务器间来回传递。

​	`sessionStorage`和`localStorage`不会自动把数据发给服务器，**仅在本地保存**。

**②数据大小不同**

​	（`cookie`数据还有路径（path）的概念，可以限制cookie只属于某个路径下。）
​	存储大小限制也不同，cookie数据**不能超过4k**，同时因为每次http请求都会携带`cookie`，所以cookie只适合保存很小的数据，如会话标识。

​	`sessionStorage`和`localStorage` 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

**③数据有效期不同**

​	`sessionStorage`：仅在当前**浏览器窗口关闭前有效**，自然也就不可能持久保持；

​	`localStorage`：**始终有效**，窗口或浏览器关闭也一直保存，因此用作持久数据；

​	`cookie`只在设置的**cookie过期时间之前**一直有效，即使窗口或浏览器关闭。

**④作用域不同**

​	`sessionStorage`**不在不同的浏览器窗口中共享**，即使是同一个页面；

​	`localStorage `在所有**同源窗口中都是共享**的；

​	`cookie`也是在所有**同源窗口中都是共享**的。



### 6. setTimeout输出值的时候，如何实现i按序输出？

```javascript
for(var i=0;i<10;i++){
    setTimeout(function ten(){
            console.log(i);
        },10);
}//输出结果是10个10
```

问：为什么输出的是10个10？

答：JS是一个单线程的解释器，setTimeout本质是间隔一定时间将任务添加到任务队列中。输出的时候for循环作为主线程已经执行完毕，此时作用域中的`i=5`；按序执行10次输出`i`，就会输出10个10；

问：如何输出成按序输出？

答：方法一：

生成一个**立即执行的函数**，将`i`作为参数输入（闭包）

```javascript
for(var i=0;i<10;i++){
    (function(i){
    	setTimeout(function ten(){
            console.log(i);
        },10);
    })(i)
}
```

方法二：用es6中的let来声明变量，相当于**let在每个块级作用域里面都声明了一个变量`i`**

```javascript
for(let i=0;i<10;i++){
    setTimeout(function ten(){
            console.log(i);
        },10);
}
```

方法三：使用`setTimeout`的**第三个参数**

```javascript
for(var i=0;i<10;i++){
    setTimeout(function ten(){
            console.log(i);
        },10,i);
}
```



### 7. vue实现双向绑定的原理？

​        VUE实现双向数据绑定的原理就是利用了 **`Object.defineProperty() `方法重新定义了对象获取属性值get和设置属性值set的操作**来实现的；

​        `Object.defineProperty() `三个参数：要操作的对象，要定义或修改的对象属性名，属性描述符；

​        其中，属性描述符是一个对象，主要有两种形式（任选其一）：数据描述符和存取描述符（get、set）。

```javascript
var obj = { };
var name;
//第一个参数：定义属性的对象;第二个参数：要定义或修改的属性的名称;第三个参数：将被定义或修改的属性描述符。
Object.defineProperty(obj, "data", {
    //获取值
    get:function () {
        return name;
    },
    //设置值
    set:function (val) {
        name = val;
        console.log(val);
    }
})
    //赋值调用set
	obj.data = 'aaa';
    //取值调用get
	console.log(obj.data);
```

​        这里着重理解**data更新，view视图层是怎么更新的**：（view更新，要data改变只要进行事件监听即可）利用`Object.defineProperty() `对属性设置的set函数，**改变了data数据就会触发set函数**，在这个函数里面添加更新view视图层的方法即可。



### 8. vue组件之间的传值？

1. 父传子：

   先在**父组件中绑定变量`<child :msg="parent"></child>`**，parent是定义在父组件中的变量/值；

   再在**子组件中添加props属性接收**父组件传递过来的变量`props:['msg']`；

   最后就可以在子组件中使用`{{msg}}`来表示父组件中parent变量中的值了。

2. 子传父：

   先在子组件中**绑定事件`@change="sendChild"`**，触发的时候在`setChild`事件中**用`$emit()`触发父组件中的函数**，并将子组件中的变量作为参数传递；

```javascript
   methods：{
       sendChild:function(){
           this.$emit('transparent',this.msg)
       }
   }
```

   在父组件中绑定事件`<child @transparent="getChild"></child>`，当子组件触发这个事件的时候，就可以**调用`getChild`方法获取到传递过来的参数**；

```javascript
   methods:{
       getChild(msg){
           this.user=msg;
       }
   }
```

3. 兄弟组件互相传值，**通过Vuex状态管理传值**：

先通过npm加载vuex，创建store.js文件

```javascript
   //store.js
   import Vue from 'vue'
   import Vuex from 'vuex'
   Vue.use(Vuex);
   const state={name:'Alice'};
   const mutations={
       newName(state,message){
           state.name=message
       }
   }
   export default new Vuex.Store({state,mutations})
```

4. 兄弟组件互相传值，**引入bus.js文件**，发布者订阅者模式：
```javascript
import Bus from './bus.js'
```
```javascript
   //一个子组件触发
   methods:{
       Bus.$emit('触发的方法名'，需要传递的值);
   }
```

```javascript
   //一个子组件监听
   mounted:{
       bus.$on("方法名",(传递的值)=>{ })
   }
```

5. 兄弟组件互相传值`$root`

```javascript
//一个子组件触发
this.$root.$emit('触发的方法名'，需要传递的值);
```

```javascript
//一个子组件监听
this.$root.$off("方法名");//每次进入先关闭一下
this.$root.$on("方法名",(传递的值)=>{ })
```



### 9.点击按钮进行数据请求，怎么实现按序执行请求？

问：点击页面上一个按钮发送两个ajax请求，其中一个请求会不会等待另一个请求执行完毕之后再执行？

答：不会，这两个异步请求会同时发送，执行的快与慢是看响应的数据量的大小及后台逻辑的复杂程度。

问：怎么让它们按序执行？

答：两种方案：

1. Ajax2()方法的执行放到Ajax1()的success**回调函数**的最后一行。

2. Ajax1()的异步请求方法中，增加一个回调函数 ：**complete : Ajax2**

   



### 10.怎么让文本不自动换行？怎么让超过文本部分变成省略号？

```css
white-space:nowrap;
overflow:hidden;
text-overflow:ellipsis;
```



### 11.vue的生命周期有哪些？它们有什么不同？

| 生命周期钩子  | 组件状态                                                     | 最佳实践                                                     |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| beforeCreate  | 实例初始化之后，this指向创建的实例，不能访问到data、computed、watch、methods上的方法和数据 | 常用于初始化非响应式变量                                     |
| created       | 实例创建完成，可访问data、computed、watch、methods上的方法和数据，还未挂载到DOM，不能访问到$el属性，$ref属性内容为空数组 | 常用于简单的ajax请求，页面的初始化                           |
| beforeMount   | 在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数 | \-                                                           |
| mounted       | 实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问 | 常用于获取信息和操作，**ajax请求**                           |
| beforeUpdate  | 响应式数据更新时调用，发生在虚拟DOM打补丁之前                | 适合在**更新之前访问**现有的DOM，比如手动移除已添加的事件监听器 |
| updated       | 虚拟DOM重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作 | 避免在这个钩子函数中操作数据，可能**陷入死循环**             |
| beforeDestroy | 实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例 | **常用于销毁**定时器、解绑全局事件、销毁插件对象等操作       |
| destroyed     | 实例销毁后调用，调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 | -                                                            |

注：

1. 其中created和mounted中ajax请求的区别：created的时候视图未出现，请求较多的情况下，会出现**白屏**；
2. 初始化组件的时候，仅执行beforeCreated/created/beforeMount/mounted四个钩子函数；
3. 当改变data中定义的**响应式变量**时，会执行beforeUpadate/updated；
4. 初始化和销毁时的钩子函数只会执行一次，beforeUpadate/updated**可执行多次**；
5. 挂载的时候，子组件完成挂载后，父组件才会挂载；
6. 当子组件完成挂载后，父组件会**主动执行一次**beforeUpdate/updated钩子函数（仅首次）；
7. 销毁父组件时，先将子组件销毁后，才会销毁父组件；







# 面试题整理（华为）

详解：

### 12. vuex的功能？能否进行兄弟组件之间的传值？

vuex专为 Vue.js 应用程序开发的**状态管理模式**。主要用于管理vue中的数据，可以兄弟组件互相传值；

![](/../../../../%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3/Documents/GitHub/CodingWithAlice.github.io/img/assets_2019/vuex.png)

state：管理项目的数据（进行数据初始化）；

mutations：主要用于操作state中的数据`store.commit('increment')`；

action：通过提交 mutation 的方式，而非直接改变 `store.state.count`，是因为我们想要更明确地追踪到状态的变化；

getter：就像计算属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算；getter 接受 state 作为其第一个参数；

```html
<div id="app1">
    {{count}}
</div>
```

```javascript
//store.js
import Vue from 'vue';
import Vuex from 'vuex';

Vue.use(Vuex);

const store = new Vuex.Store({
    state:{
        count:0
    }
});

new Vue({
    el:'#app1',
    store,
    computed:{
        count(){
            return this.$store.state.count
        }
    }
})
```



### 13. Axios调取数据？

[页面直接引用 `<script src="https://unpkg.com/axios/dist/axios.min.js"></script>`]

#### axios的特性

1.可以从浏览器中创建XHR对象
2、可以从nodeJS中创建HTTP请求
3、支持Promise
4、可以拦截请求和响应
5、可以转换请求数据和响应数据
6、可以取消请求
7、可以自动转换JSON数据
8、客户端支持防御XSRF



**axios get 方法**：仅仅请求后台数据

```javascript
axios.get('index.php')
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
```

**aixos post方法**：post请求更多的是要提交数据，params属性里的数据会出现在请求主体中。

```javascript
axios.post('/user', {
    firstName: 'Fred',
    lastName: 'Flintstone'
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
```

**多并发请求,一次性发几个请求**

```javascript
function getUserAccount() {
  return axios.get('/user/12345');
}

function getUserPermissions() {
  return axios.get('/user/12345/permissions');
}

axios.all([getUserAccount(), getUserPermissions()])
  .then(axios.spread(function (acct, perms) {
    // acct为第一个请求的结果，perms为第二个请求的结果
  }));
```



**设置拦截器**：

```javascript
//请求拦截器
		axios.interceptors.request.use(  
        config => {
            btn.innerHTML='请求数据中';
            return config;
        },
        // 错误时发生的事情
        err => {
            console.log(err)
        });
```

```javascript
 // 响应应拦截器
        axios.interceptors.response.use(
        config => {
            btn.innerHTML='请求数据成功';
            return config;
        },
        // 错误时发生的事情
        err => {
            console.log(err)
        });
```



**设置自定义请求头**：

先安装Axios：`npm install axios --save`

再在main.js中引入Axios：

```javascript
import axios from 'axios'
Vue.prototype.$http = axios;
```

即可在组件中调用Axios：

```javascript
this.$axios.get('index.php/url')
  .then(response => {
    console.log(response)
  }).catch(error => {
    console.log(error)
  });
```

然后设置自定义的头请求：

`axios.defaults.timeout = 5000;//请求超时的时间设定`

`axios.defaults.headers.post['Content-Type'] = 'application/json'; //axios默认的请求方式`

`axios.defaults.baseURL = 'http://localhost:8008';//axios默认的请求地址 `

`axios.defaults.headers.common["token"] = "noname";//有些接口必须登录才可以调用，而登陆注册并未写好，后台给了一个故固定的token，写在了头里面`



### 14. 继承prototype大概是怎么实现的？

实例对象per的构造器constructor是指构造函数Person；

```javascript
console.log(per.constructor==Person);//true
```

实例对象的`_proto_`和构造函数中的**prototype**相等；

```javascript
console.log(per._proto_.constructor==Person.prototype.constructor);//true
```



**原型链**：实例对象使用的属性或者方法，先在实例中查找，找到了则直接使用，找不到则去实例对象的`__proto__`指向的原型对象prototype中找，找到了则使用,找不到则报错。



**实例对象**中有**`_proto_`**这个属性，叫原型，也是一个对象，这个属性是给**浏览器**使用，

不是标准的属性----->**__proto__**----->**可以叫**原型对象；

**构造函数**中有**prototype**这个属性，叫原型，也是一个对象，这个属性是给**程序员**使用，

是标准的属性------>**prototype**--->**可以叫**原型对象；



1. **原型继承**核心就是让自定义的构造器的prototype对象**指向**父类构造器生成的对象：

```javascript
//Person是个构造函数，Per是自定义的构造器
function Per(){}
Per.prototype = new Person('Alice');
const person = new Per()//继承父类实例定义的所有属性以及父类构造器原型上的属性
```

2. **借用函数继承**：通过函数对象本身的 `call` 和 `apply` 来显示的指定函数调用时必备的参数；

```javascript
function Per(name){
    Person.call(this,name)//当成了普通函数来使用
}
const person = new Per('Alice')
//只能调用Person中定义的属性和函数，无法调用Person定义在prototype上的属性和方法
```

3. **组合继承（原型链+借用函数）**：[为了解决借用函数无法使用函数原型上的属性和方法]

```javascript
function Per(name){
    Person.call(this,name)//当成了普通函数来使用
}
Per.prototype = new Person('Alice')//这样写，会造成Animal实例化两次，没有自己的原型
//或者
Per.prototype = Person.prototype//这样写，就不会造成多次实例化

const person = new Per('Alice')
```

4. **原型式继承**：提供一个被继承的对象，把这个对象挂在到某个构造函数的**prototype**上，再利用new；

```javascript
function inherit (object) {
  function fn () {} 		// 提供一个函数
  fn.prototype = object ;	// 设置函数的prototype
  return new fn() 			// 返回这个函数实例化出来的对象
}
const person = Person('Alice');
const me=inherit(person);//可以继承peroson对象上所有的方法和属性
```

5. **寄生式继承**

6. **寄生组合式继承**：利用 `Object.create()` 方法

   

### 15. es6中和原型一样用来继承的class和继承是怎么实现的？

贴上

[阮一峰大神的ES6讲解]: http://es6.ruanyifeng.com/#docs/class

```javascript
class Point {
  // ...
}
typeof Point // "function"，类的数据类型就是函数
Point === Point.prototype.constructor // true，类本身就指向构造函数
```

使用的时候，也是直接对类使用`new`命令，跟构造函数的用法完全一致，不使用new会报错。

类的所有方法都定义在类的`prototype`属性上面。

```javascript
class Point {
  constructor() {
    // ...
  }

  toString() {
    // ...
  }

  toValue() {
    // ...
  }
}

// 等同于

Point.prototype = {
  constructor() {},
  toString() {},
  toValue() {},
};

//Object.assign方法可以很方便地一次向类添加多个方法

Object.assign(Point.prototype, {
  toString(){},
  toValue(){}
});
```

类不存在变量提升（hoist），这一点与 ES5 完全不同。



Class 可以通过`extends`关键字实现继承。

```javascript
class ColorPoint extends Point {}//ColorPoint继承了Point类所有的属性和方法
```

`super`关键字，表示父类的构造函数，用来新建父类的`this`对象。

子类必须在`constructor`方法中调用`super`方法，否则新建实例时会报错，只有调用`super`之后，才可以使用`this`关键字。



**区别：**

ES5 的继承，实质是**先创造子类的实例对象`this`**，然后再将父类的方法**添加到`this`上面**（`Parent.apply(this)`）。

ES6 的继承机制完全不同，实质是**先将父类实例对象的属性和方法，加到`this`上面**（所以必须先调用`super`方法），然后再用子类的构造函数**修改`this`。**



Class 作为构造函数的语法糖，同时有`prototype`属性和`__proto__`属性，因此同时存在两条继承链。

（1）子类的`_proto_`属性，表示构造函数的继承，总是指向父类。

（2）子类`prototype`属性的`_proto_`属性，表示方法的继承，总是指向父类的`prototype`属性。

子类实例的`__proto__`属性的`__proto__`属性，指向父类实例的`__proto__`属性。也就是说，子类的原型的原型，是父类的原型。



`Object.getPrototypeOf`方法判断，一个类是否继承了另一个类。



### 16. jQuery和Vue使用起来有什么区别？

​        从jquery到vue或者说是到mvvm的转变则是一个思想想的转变，是将原有的直接操作dom的思想转变到操作数据上去。

​        从技术角度讲，Vue.js 专注于 MVVM 模型的 ViewModel 层。它通过双向数据绑定把 View 层和 Model 层连接了起来，通过对数据的操作就可以完成对页面视图的渲染。



​        jQuery是使用选择器（$）**选取DOM对象**，对其进行赋值、取值、事件绑定等操作，和原生的区别只在于可以更方便的选取和操作DOM对象，其数据和界面是在一起的。

​        Vue则是通过Vue对象将数据和View层分离开来。**对数据进行操作**不再需要引用相应的DOM对象，通过Vue对象这个vm实现相互的绑定。



​        vue**适用的场景**：复杂数据操作的后台页面，表单填写页面；vue侧重数据绑定；

　　jquery**适用的场景**：比如说一些html5的动画页面，一些需要js来操作页面样式的页面；jquery侧重样式操作，动画效果等；



### 17. vue父子组件传值怎么实现的？

参考第8题

### 18. 兄弟组件传值怎么实现的？

参考第8题

### 19. 怎么调程序中出现的代码？

```javascript
alert('方法一')
console.log('方法二') 
Chrome中的开发者工具：断点设置、调试功能
```



### 20. js的垃圾回收机制？（摘自红宝书）

1. 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除；

2. **“ 标记清除 ”** 是目前最主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存（当变量进入环境时，将变量标记为“进入环境”。当变量离开环境时，将其标记为“离开环境”，标记“离开环境”的就回收内存）；

3. 另一种垃圾收集算法是 **“ 引用计数 ”** ，这种算法的思想是跟踪记录所有值被引用的次数。`JavaScript`引擎目前都不再使用这种算法；但在 IE 中访问非原生`JavaScript`对象（如`DOM`元素）时，这种算法仍然可能会导致问题；

4. 当代码中存在循环引用现象时，" 引用计数 "算法就会导致问题；

5. 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效的回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。

   

### 21. es6中const、let、var之间的区别？

1. var定义的变量，**作用域**是整个封闭函数，是全域的；

   let定义的变量，作用域是在块级或者字块中；

2. **变量提升**：不论通过var声明的变量处于当前作用于的第几行，都会提升到作用域的最顶部。

   而let声明的变量不会在顶部初始化，凡是在let声明之前使用该变量都会报错（引用错误ReferenceError）；

3. 只要块级作用域内存在`let`，它所声明的变量就会**绑定在这个区域**；

4. **let不允许**在相同作用域内**重复声明**（报错同时使用var和let，两个let）

   

const用来专门声明一个常量，它跟let一样作用于块级作用域，没有变量提升，重复声明会报错，不同的是**const声明的常量不可改变，声明时必须初始化（赋值）**，const定义的对象可变。



const使用场景很广，包括常量、配置项以及引用的组件、定义的 “大部分” 中间变量等，都应该以cosnt做定义。反之就 let 而言，他的使用场景应该是**相对较少**的，我们只会在 loop(for，while 循环)及少量必须重定义的变量上用到他。



### 22. 闭包是什么？用let怎么实现闭包？

闭包是指有权访问另一个函数作用域中的变量的函数。

一个闭包就是**一个没有释放资源的栈区**，栈区内的变量处于激活状态。

在ES6中let实际是为js新增了块级作用域。

let声明的变量可以绑定在作用域中。



# 面试题整理（海康）

详解：

## 23. 闭包是什么？有什么优点和缺点？

闭包定义：参考第22题

**优点**：① 能够读取函数内部的变量；②让这些变量一直存在于内存中，不会在调用结束后被垃圾回收机制回收；

**缺点**：由于闭包会使用函数中的变量存在在内存中，内存消耗很大，所以不能滥用闭包；解决的办法是退出函数之前，将不使用的局部变量删除；



## 24. css中怎么使盒子上下居中（面试官说水平居中太简单了）？

解答：方法一：

​	设置垂直居中的时候要注意，先**给祖先元素`html`和`body`的高度设置为100%**（默认是0）；并且**清除默认样式**（`margin`和`padding`都设置为0，否则浏览器就会出现滚动条），然后**给子盒子相对定位和位移**`position：relative;top:50%;`，然后**减去本身宽度的一半**即可（`margin-top：负自身高度的一半` // `transform：translateY(-50%)`向上偏移自身高度的一半；

​	注意：top、bottom、left、right的百分比值都是相对于包含块的高度、宽度的；

方法二：

​	**弹性盒子**。给**父元素设置`display:flex; align-items:center;`**设置body里的元素垂直居中；（`justify-content:center;`定义body里的元素水平居中）



## 25. js中本地存储有哪些？有什么不同？

参考第5题

## 26.cookie中的session了解吗？

`cookie`和`sessiom`是两种**保持会话**状态的方法。

​	cookie就是指客户端在向服务端发起请求的时候，服务端会在进行response的时候给当前客户端的一小段文本信息，并保存在当前的客户端的浏览器中，这一小段cookie文本信息也就是这个客户端去访问服务端的通行证，有了这个通行证，以后当这个客户端再去访问服务端的时候，服务端便知道是谁拿着通行证去进行访问了。

​	session和cookie的功能类似，也是一种保持会话状态的方式，在用户使用浏览器发起会话时，服务器会为每一个用户浏览器提供一个单独的session对象来保存用户的数据，并将它保存在服务端，而当用户访问其他web资源的时候，则可以从保存用户数据的session对象中把用户数据抽取出来并进行访问。

区别：

1. cookie的用户数据是保存在**用户浏览器**的cookie中的；

session的用户数据是保存在**服务器为用户浏览器单独创建的session对象**中的。

2. 数据的读取和调用，cookie可以采用request.getCookies这种方法；

   session则可以用request.Session的方法。

3. 安全性，cookie是存储在**用户浏览器**中的；

   而session是**存储在服务器**上的，所以session比cookoe要相对安全；



## 27. 跨域了解吗？

参考第1题

## 28.this的指向问题？

this的最终指向的是那个调用它的对象。

改变this指向的方法：

1. 使用**箭头函数**；
2. 在函数内部使用`_this=this;`
3. 使用**apply、call、bind**
4. new**实例化一个对象**；



## 29. vue使用的UI框架？

**animate.css**是一款前端动画库，相似的有velocity-animate；

​	（element ui框架的按钮组件；

​	iView 是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品

​	Vuetify.js根据材料设计规格提供 UI 布局；

​	基于 Vue.js 的 Bootstrap 组件；

​	cube-ui 是滴滴团队开发的基于 Vue.js 实现的精致移动端组件库；

​	vue-beauty 是一套基于 vue.js 和 ant-design样式 的PC端 UI 组件库；

​	AT-UI 是一个模块化的前端 UI 框架，基于Vue.js 的快速和强大的 Web 界面；专门为桌面应用程序构建；

​	Vue-Blu是基于Vue.js和Bulma开发的开源UI组件库。旨在为PC端的前端开发(特别是中后台产品)提供一个快速且灵活的解决方案。）

**使用步骤：**

1. **首先`npm install animate.css --save`；**
2. 然后在vue文件的script中**引入`import animate from 'animate.css'`；**
3. 最后**绑定元素使用**，如下：

```vue
<template>
    <div class="song">
        <p id="f" @click='fade'>hello</p>
    </div>
</template>
```

```javascript
methods:{
    fade:function(){
        $('#f').addClass('animated bounceOutLeft')
    }
}
```

部分api常见：

```javascript
	fade: {
        title: '淡入淡出',
        fadeIn: '淡入',
        fadeInDown: '向下淡入',
        fadeInDownBig: '向下快速淡入',
        fadeInLeft: '向右淡入',
        fadeInLeftBig: '向右快速淡入',
        fadeInRight: '向左淡入',
        fadeInRightBig: '向左快速淡入',
        fadeInUp: '向上淡入',
        fadeInUpBig: '向上快速淡入',
        fadeOut: '淡出',
        fadeOutDown: '向下淡出',
        fadeOutDownBig: '向下快速淡出',
        fadeOutLeft: '向左淡出',
        fadeOutLeftBig: '向左快速淡出',
        adeOutRight: '向右淡出',
        fadeOutRightBig: '向右快速淡出',
        fadeOutUp: '向上淡出',
        fadeOutUpBig: '向上快速淡出'
      },
      bounce: {
        title: '弹跳类',
        bounceIn: '弹跳进入',
        bounceInDown: '向下弹跳进入',
        bounceInLeft: '向右弹跳进入',
        bounceInRight: '向左弹跳进入',
        bounceInUp: '向上弹跳进入',
        bounceOut: '弹跳退出',
        bounceOutDown: '向下弹跳退出',
        bounceOutLeft: '向左弹跳退出',
        bounceOutRight: '向右弹跳退出',
        bounceOutUp: '向上弹跳退出'
      },
      zoom: {
        title: '缩放类',
        zoomIn: '放大进入',
        zoomInDown: '向下放大进入',
        zoomInLeft: '向右放大进入',
        zoomInRight: '向左放大进入',
        zoomInUp: '向上放大进入',
        zoomOut: '缩小退出',
        zoomOutDown: '向下缩小退出',
        zoomOutLeft: '向左缩小退出',
        zoomOutRight: '向右缩小退出',
        zoomOutUp: '向上缩小退出'
      },
      rotate: {
        title: '旋转类',
        rotateIn: '顺时针旋转进入',
        rotateInDownLeft: '从左往下旋入',
        rotateInDownRight: '从右往下旋入',
        rotateInUpLeft: '从左往上旋入',
        rotateInUpRight: '从右往上旋入',
        rotateOut: '顺时针旋转退出',
        rotateOutDownLeft: '向左下旋出',
        rotateOutDownRight: '向右下旋出',
        rotateOutUpLeft: '向左上旋出',
        rotateOutUpRight: '向右上旋出'
      },
      flip: {
        title: '翻转类',
        flipInX: '水平翻转进入',
        flipInY: '垂直翻转进入',
        flipOutX: '水平翻转退出',
        flipOutY: '垂直翻转退出'
      },
      strong: {
        title: '强调类',
        bounce: '弹跳',
        flash: '闪烁',
        pulse: '脉冲',
        rubberBand: '橡皮筋',
        shake: '左右弱晃动',
        swing: '上下摆动',
        tada: '缩放摆动',
        wobble: '左右强晃动',
        jello: '拉伸抖动'
      }
```



## 30. npm中的工具了解过吗？（yarn）

**npm就是JavaScript的包管理工具。**npm主要用来下载，安装，管理第三方模块。

创建一个包描述文件：`npm init [-y]`

查看包的信息 `npm info <package-name>`

查看包的版本信息 `npm info <package-name> versions`

安装指定的包：`npm install <package-name>`
 默认会安装在当前目录下的 node_modules 目录下，如果 node_modules 不存在，则会自动创建。
本地安装包，如果包里有可执行文件，则npm会把可执行文件安装到 node_modules/.bin 目录下。

安装指定版本的包：`npm install <package-name>@<version>`

安装包并记录依赖，会在 package.json 中 dependencies 属性记录依赖`npm install <package-name> --save`

卸载包：`npm uninstall <package-name>`

更新包：`npm update <package-name>`

全局安装包，把包安装在全局目录，供所有项目使用:`npm install <package-name> -g`
全局安装包，如果包里有可执行文件，则npm会把可执行文件安装到 node_modules 上一级目录中。

查看全局目录：`npm root -g`

修改全局目录的路径：`npm config set prefix ``"新路径"`
默认情况下全局安装的包不能直接在项目中加载，如果要直接加载，需要在系统环境变量中添加一个名为 NODE_PATH 的变量，值为全局安装目录下 node_modules 位置。

查看npm配置 `npm config list`



## 31. Node.js了解吗？

​		根据官方文档可以知道，node就是一个给予谷歌v8引擎的一个javascript的运行时，可以理解为**运行js的一个虚拟机**。他使用的是一个事件驱动，非阻塞I/O模型 ，他是**将js的运行环境搬到了服务器端**，和客户端没有一点关系。是一个纯服务端的东西，node只是**为js提供了一个平台**。

　　node里面其实还分了两块，一是封装了v8引擎，目的是为了执行es（如定义变量，定义函数等），另外一个提供了大量的工具库，是帮助node实现各种功能的，提供了一些以前js的环境办不到的事情，比如文件操作，网络操作，操作系统的操作。

​	既然node是一个平台（所谓的平台就是用来运行特定语言的），也就意味着node是用来运行语言的，那么java也是语言，node能运行java吗？据nodejs创始人Ryan Dahl回忆，他最初是选择了Ruby这门语言，但是Ruby这门语言的虚拟机效率不怎么样最终放弃了，按照这种思路，貌似node将java的虚拟机集成进来应该可以运行java，但node作者最终选择了javascript。

　　这样js就实现了在服务端运行的可能，js运行在node平台上（分为v8部分，用来执行es，和大量的工具库组件（API）称之为libuv，提供了以前js的环境办不到的事，如文件操作，网络操作等等）。

用途：

​		（1）node可以**接受客户端用户的所有请求**，并且能够快速的给出响应，因此node可以用来做网站。

　　（2）node可以作为一个**中间层来来分发调用数据接口**，比如有一个网站数据是有java提供的，我们可以让node作为一个中间层，来接受用户的请求，然后**通过node来调用java数据接口**，获取到数据后直接在node层面做html的封装，然后将渲染好的页面直接给用户。为什么要这样做，直接请求java接口不行吗，这是因为node被称之为**高性能的web服务器**，在**并发和抗压**方面都比传统的平台要好很多，因此这样一包装可以极大的减轻服务器的开发。

　　通过上面的两点，可以总结出，node在web中要么从前端页面到后端服务全包了，一个是只做其中的一点。

　　**一言以蔽之，node就是一个javascript的运行环境（平台），他不是一门语言，也不是javascript的框架。可以用来开发服务端应用程序，web系统。其特点是体积小，快速，高性能。**



# 面试题整理（网易）



1. js中的闭包是什么？
2. v-if和v-show之间的区别？
3. v-for中key值的作用？
4. vue中插槽的作用？
5. js的执行机制

详解：

### 33. js中的闭包是什么？

​	参考第22题

### 34.v-if和v-show之间的区别？

​	相同点：v-if与v-show都可以动态控制dom元素显示隐藏

​	不同点：

实现**本质方法**区别

- vue-show本质就是标签`display:为none;`，控制隐藏，DOM结构是一直存在的
- vue-if是动态的向DOM树内**添加或者删除DOM元素**

编译的区别

- v-show其实就是在**控制css**
- v-if切换有一个局部编译/卸载的过程，切换过程中合适地**销毁和重建内部的事件监听和子组件**

编译的条件

- v-show**都会编译**，初始值为false，只是将display设为none，但它也编译了
- v-if初始值为false，就不会编译了

性能

- v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故**v-show性能更好一点**。

### 35.v-for中key值的作用？

​	key的作用主要是为了**高效的更新虚拟DOM**。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以**区分它们**，否则vue只会替换其内部属性而不会触发过渡效果。

​	在用v-for更新已渲染的元素列表的时候，会使用就地复用的策略；这就是说列表数据修改的时候，他会根据key值去判断某个值是否修改，如果修改了就重新渲染，不然就复用之前的元素。

### 36.vue中插槽的作用？

​	插槽就是Vue实现的一套内容分发的API，将`<slot></slot>`元素作为承载分发内容的出口，没有插槽的情况下在组件标签内些一些内容是不起任何作用的。

​	插槽内可以是任意内容。在`<child-component>你好</child-component>`内放置一些内容，输出内容还是在组件中的内容，直接在父组件的` <child-component>`标签中定义的内容不会被渲染。**在子组件template中加入`<slot>`元素占位，便能渲染父组件`<child>`标签下的内容**。

​	**具名插槽**，当需要多个插槽时，可以使用`<slot>`的特性：name。这个特性可以用来定义额外的插槽。

```html
	<div id="root">
        <child>
            <header slot="header">header</header>
            <footer slot="footer">footer</footer>
        </child>
    </div>
```

```javascript
       Vue.component('child',{
            template:`<div>
                            <slot name="header">default header</slot>
                            <div>content</div>
                            <slot name="footer">default footer</slot>
                        </div>`
            }
        )
        var vm=new Vue({
            el:'#root'
        })
 //输出结果是 header   content   footer
```



​	**插槽默认内容** ，插槽可以提供一个默认内容，如果如果父组件没有为这个插槽提供了内容，会显示默认的内容。如果父组件为这个插槽提供了内容，则默认的内容会被替换掉。

​	**作用域插槽**，作用域插槽就是父组件在**调用子组件的时候给子组件传了一个插槽**，这个插槽为作用域插槽，该插槽必须放在template标签里面，同时声明从子组件接收的数据放在一个自定义属性内，并定义该数据的渲染方式。（解决的问题：调用了两次child组件，因为调用的是同一个子组件，所以显示的内容完全一样。如何在每次调用时能有各自的渲染效果？）

```html
	<div id="root">
        <child>
            <template slot-scope="props"><!--该插槽必须放在template标签内-->
                <li>{{props.value}}</li> <!--定义渲染方式-->
            </template>
        </child>
        <child>
            <template slot-scope="props">
                <h1>{{props.value}}</h1><!--定义渲染方式-->
            </template>
        </child>
    </div>
```

```javascript
Vue.component('child',{
            data: function(){
                return {
                    list:[1,2,3,4]
                }
            },
            template: `<div>
                            <ul>
                                <slot v-for="value in list" :value=value>//使用slot占位
                                </slot>
                            </ul>
                        </div>`
        })
        var vm=new Vue({
            el: '#root'
        })
```



### 37.js的执行机制：Event loop

![](/../../../../%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3/Documents/GitHub/CodingWithAlice.github.io/img/assets_2019/%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.png)

- 同步和异步任务**分别进入不同的执行"场所"**，同步的进入主线程，异步的进入Event Table并注册函数。
- 当指定的事情完成时，Event Table会将这个函数移入Event Queue。
- 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。
- 上述过程会不断重复，也就是常说的Event Loop(事件循环)。

​        `setTimeout`这个函数，是经过指定时间后，**把要执行的任务加入到Event Queue中**，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于设置的时间长度。

​       `setInterval`会每隔**指定的时间将注册的函数置入Event Queue**，如果前面的任务耗时太久，那么同样需要等待。唯一需要注意的一点是，对于`setInterval(fn,ms)`来说，我们已经知道不是每过`ms`秒会执行一次`fn`，而是每过`ms`秒，会有`fn`进入Event Queue。一旦**setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了**。



除了广义的同步任务和异步任务，我们对任务有更精细的定义：

- macro-task(宏任务)：包括整体代码script，setTimeout，setInterval
- micro-task(微任务)：Promise，process.nextTick

不同类型的任务会进入对应的Event Queue，比如`setTimeout`和`setInterval`会进入相同的Event Queue。

![](/../../../../%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3/Documents/GitHub/CodingWithAlice.github.io/img/assets_2019/%E5%AE%8F%E4%BB%BB%E5%8A%A1.png)



进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。

