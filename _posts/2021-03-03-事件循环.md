---
layout:     post
title:     js相关 面试问题
subtitle:  
date:       2021-03-03
author:     
header-img: 
catalog: true
tags:
    - < 面试题整理 >
typora-root-url: ..
---



# Event loop - js运行机制

Event Loop即事件循环，是指浏览器或Node的一种**解决javaScript单线程运行时不会阻塞**的一种机制，也就是我们经常使用**异步**的原理。

一、浏览器事件环

1、JS的**主线程**是【单线程】的，但是 `ajax`和 `setTimeout`就会在浏览器中多开一条线程；

JS有一个**主线程**和**调用栈**(执行栈)，所有的任务都会被放到调用栈等待主线程执行；

**JS调用栈**采用的是**后进先出**的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空；

任务队列采用的是先进先出的一种数据结构；

2、同步和异步

![](/img/assets_2019/%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.png)

- 同步和异步任务**分别进入不同的执行"场所"**，同步的进入主线程，异步的进入Event Table并注册函数
  - 同步任务会在调用栈中按照顺序等待主线程依次执行
- 异步任务会在异步任务有了结果后，Event Table会将回调函数移入Event Queue
- 主线程内的任务执行完毕（调用栈被清空），会去Event Queue读取对应的函数，进入主线程执行。
- 上述过程会不断重复，也就是常说的Event Loop(事件循环)。

​        `setTimeout`这个函数，是经过指定时间后，**把要执行的任务加入到Event Queue中**，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于设置的时间长度。

​       `setInterval`会每隔**指定的时间将注册的函数置入Event Queue**，如果前面的任务耗时太久，那么同样需要等待。唯一需要注意的一点是，对于`setInterval(fn,ms)`来说，我们已经知道不是每过`ms`秒会执行一次`fn`，而是每过`ms`秒，会有`fn`进入Event Queue。一旦**setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了**。

3、宏任务和微任务

除了广义的同步任务和异步任务，我们对任务有更精细的定义：

- **macro-task(宏任务)**：包括整体代码script，setTimeout，setInterval，setImmediate（ie下生效）  MessageChannel（消息通道），I/O，UI Rendering
- **micro-task(微任务)**：Promise.then，Process.nextTick（node的文法，比Promise.then执行的快），MutationObserver（监听dom节点更新完毕)

不同类型的任务会进入对应的Event Queue，比如`setTimeout`和`setInterval`会进入相同的Event Queue。

![](/img/assets_2019/%E5%AE%8F%E4%BB%BB%E5%8A%A1.png)

进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。

二、node事件环

node的事件环和我们浏览器的不太一样，它给每一个任务都配了一个队列，如下图

![image-20210304094614352](/img/assets_2019/image-20210304094614352.png)

- **timers**： 定时器setTimeout和seInterval的执行，将callback加入队列中。

- **pending callbacks**： 一些I/O的callback，推迟到下一次循环中执行。

- **idle, prepare**： 内部的一些事件。

- **poll**： 轮循，i/o，回调，fs.readFile()。

- **check**： setImmediate的callback执行。

- **close callbacks**： 一些关闭的回调函数，如socket。

需要关心的就是**timers、poll、check**这三个阶段，执行顺序默认，会从上到下依次执行，

1、如果代码执行到poll后，发现check阶段没有，那就在poll在等待，等待times时间到达后，再清空代码

2、队列发生切换时，就会执行微任务

3、poll的下一个阶段就是check，如果check队列中有东西的，会先执行check

```
setTimeout(()={
    console.log("time1");
    process.nextTick(()=>{
        console.log("nextTick2");
    });
});
console.log("start")
process.nextTick(()=>{
    console.log("nextTick1");
    setTimeout(()={
        console.log("time2");
    });
});
// node12/10环境 + 浏览器： start nextTick1 time1 nextTick2 time2
```

![image-20210304101006158](/img/assets_2019/image-20210304101006158.png)