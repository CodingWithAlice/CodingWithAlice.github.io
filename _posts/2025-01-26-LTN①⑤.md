---
layout:     post
title:      面试题整理
subtitle:  
date:       2019-07-08
author:     
header-img: 
catalog: true
tags:
    - < 面试题整理 >
typora-root-url: ..
---



# LTN做题

> ①⑤ 错题重做

❌作业6：new操作符实例化一个对象的过程
❌作业66：React如何处理错误
❌作业3：迭代器原理
❌2021.06 子盒子在父盒子中水平垂直居中有几种方法？
❌作业72：react 的 声明周期有哪些，在不同生命周期中做什么事情？
❌作业87：Nextjs 中预渲染是什么？有哪些模式？写一个动态路由的page
❌作业88：mysql2 和 Sequelize 的使用场景？有哪些差异？简单写一个连接
❌2021.07 数组扁平化（一层、全部展开、指定深度）
❌作业25：简单写下 请求创建过程
❌作业74：起舞弄清影 是那首诗？谁写的？下一句是什么？
❌作业55：flex 常见缩写
❌作业59：什么是高阶函数?什么是高阶组件？什么是副作用？简单举例
❌作业61：常见的数据结构有哪些
❌作业73：react 的 setState 是同步还是异步？为什么React有时候有两次 setState，却只执行一次？
❌作业76：显卡的作用？
❌作业90：金玉满堂是什么意思？在花卉中的说法是什么？
❌作业91：三次握手的过程和具体包的作用
❌作业92：前端中的序列化是什么？常见序列化方法
❌作业93：闭包的作用和原理
❌2021.07 事件流 + 事件模型
❌2021.06 链表 141. 环形链表
❌2021.09 get和post有什么区别
❌作业24：写出事件循环系统的流程图，常见宏任务、微任务有哪些。并写出几个常见题目的输出结果

```js
Promise.resolve().then(() => {
    console.log(1);
    Promise.resolve().then(() => {
        console.log(2);
    }).then(() => {
        console.log(3);
    }).then(() => {
        console.log(4);
    })
}).then(() => {
    console.log(5);
}).then(() => {
    console.log(6);

})
------

async1 = async () => {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
function async2(){
    console.log('async2');
}
console.log('script start');
setTimeout(() => {
    console.log('setTimeout');
})
async1();
new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(() => {
    console.log('promise2');
    return new Promise(function(resolve) {
        resolve();
    })
}).then(() => {
    console.log('promise3');
})
console.log('script end');
```





> ①⑤ 74题 2025.1.27  - 2.4 开始

2.8 - LTN2
✅2021.05 29 WebSocket
✅2021.05 XSS跨域脚本攻击 和 CSRF跨站请求伪造攻击
✅2019.07 深拷贝和浅拷贝的区别？怎么实现深拷贝？
✅2020.03 模块化
✅2021.06 跨页面通信
✅2019.07 数组去重（算法整理）
✅2021.07 柯里化函数实现

2.8 - LTN1
✅作业16（2）：arguments 对象对待命名参数和设置了默认值的命名参数有什么不同？数组作为参数传入函数得到的arguments 是什么？怎么实现arguments是数组？怎么收集独立参数？在对象字面量和数组字面量中，扩展运算符有什么不同的表现？
✅作业 89：mysql 中类型的区别：varchar 和 char，date datetime
❌作业90：金玉满堂是什么意思？在花卉中的说法是什么？
❌作业91：三次握手的过程和具体包的作用
❌作业92：前端中的序列化是什么？常见序列化方法
❌作业93：闭包的作用和原理
❌2021.07 事件流 + 事件模型
❌2021.06 链表 141. 环形链表
❌2021.09 get和post有什么区别

```js
// 2021.09 get和post有什么区别
❌ // 1、从四个方面描述：数据参数 + 参数长度 + 回退安全性 + 缓存
get：
	请求参数在链接上； ⭐️ // 也就是请求行
	参数大小限制；❌ // 2、参数长度：get - 大小限制2kb
    ❌ // 4、回退安全性：get - 回退无害，参数被保留在浏览器历史记录
    ❌ // 6、缓存：get - 请求会被浏览器主动 cache
post：
	请求参数在请求体；
    数据大小限制很大 2kb；❌ // 3、参数长度：post - 没有限制
    ❌ // 5、回退安全性：post - 回退时，post请求会被再次提交，参数不会被保留
    ❌ // 7、缓存：post - 不会缓存，除非手动设置
```

```js
// 2021.06 链表 141. 环形链表
function circle(head) {
    try{
        JOSN.stringify(head);
        return false;
    } catch(e){
        return true;
    }
}
function circle2(head) {
    while(head.next) { ❌ // 1、 while(head) 即可
        if(head.circle) {
            return true
        }
        head.circle = true;
        head = head.next;
    }
    return false
}
```

```js
/
/ 2021.07 事件流 + 事件模型
- 第一遍 2025.2.8 -
先捕获，再冒泡
❌ /** 缺少详细描述
	捕获：从 window->document->html->body 传递到最具体的节点
	冒泡：从具体节点逐渐向上传播到DOM最高层父节点
	现代事件模型：事件委托-利用事件冒泡，将事件处理程序添加到父元素
	DOM2级事件模型：捕获+处理+冒泡
*/
```

```js
// 作业93：闭包的作用和原理
- 第一遍 2025.2.8 -
外部函数执行完毕后，会清理执行栈和内存将变量清理；但是如果内部函数引用了变量，变量将不被清理，以 closure 存储在内存 ⭐️ // 活动对象没有被销毁，词法作用域
用于保存变量持续的值 ❌ // 保存状态 + 数据封装/私有变量 + 函数工厂 + 回调函数
```

```js
// 作业92：前端中的序列化是什么？常见序列化方法
- 第一遍 2025.2.8 -
将不同的数据结构转换为 JSON
❌ // 1、序列化是将数据结构/对象转换为可以存储/传输的格式的过程
JSON.stringify ⭐️ // 特殊点：无法处理 Function 和 互相引用，循环引用时会报错
❌ // 2、少写了 new FormData(form) 收集表单数据并序列化，转换成键值对的格式
```

```js
// 作业91：三次握手的过程和具体包的作用
- 第一遍 2025.2.8 -
客户端：SYN
服务端：SYN + ACK
客户端：ACK
SYN - ...不记得了 ❌ // 1、SYN是同步序列编号包
ACK - 确认信息，有序列号 ❌ // 2、ACK确认包
```

```js
// 作业90：金玉满堂是什么意思？在花卉中的说法是什么？
- 第一遍 2025.2.8 -
金玉满堂：很多内涵，夸奖 ⭐️ // 形容财富很多、比喻学识丰富
海棠、(其他的不记得了)
❌ // 1、花卉中的说法 玉堂春富贵 - 玉兰(玉)、海棠(堂)、迎春(春)、牡丹(富)、桂花(贵)
```

```js
// 作业 89：mysql 中类型的区别：varchar 和 char，date datetime
- 第一遍 2025.2.8 -
varchar 按照内容长度存储
char 需要指定固定存储长度，不论存储什么都是这么大内存占用 ⭐️ // 内容长度不够时，使用空格填充到指定长度
date YYYY-MM-DD ⭐️ // 3字节
datetime YYYY-MM-DD HH:MM:SS ⭐️ // 8字节
```

```js
// 作业16（2）：arguments 对象对待命名参数和设置了默认值的命名参数有什么不同？数组作为参数传入函数得到的arguments 是什么？怎么实现arguments是数组？怎么收集独立参数？在对象字面量和数组字面量中，扩展运算符有什么不同的表现？
- 第三遍 2025.2.8 -
arguments 默认会同步命名参数，修改 aguments[1] 就会就该对应的命名参数
但是不会同步 设置了默认值的命名参数
数组直接传入：arguements=[[1,2,3]] ->(...arr)
(first, ...rest)
[...arr] => 扩展运算符，一一传入可迭代对象的值 
{...obj} => 扩展运算符，复制可枚举属性
- 第一遍 -
❌ // 1、数组直接传入的 arguments 错了，应该是 [[1,2,3]]
❌ // 2、{...obj} 作用描述有问题，复制的是 可枚举属性
```

```js
// 2021.07 柯里化函数实现
- 第二遍 2025.2.8 -
function curry(fn, ...args1){
	if(fn.length <= args1.length) {
        fn(...args)
    } else {
        return (...args2) => curry(fn, ...args1, ...args2)
    }
}
```

```js
// 2019.07 数组去重（算法整理）
- 第三遍 2025.2.8 -
1、[...new Set(arr)] Array.from(new Set(arr)) 
2、arr.filter((it, index) => it === arr[index]) ⭐️ // 判断条件 index === arr.indexOf(it)
3、
function unique(arr){
    const hash = {};
	return arr.filter(it => hash[it] ? false : hash[it] = true)
}
- 第一遍 -
❌ // 1、Set 不是数组类型，需要再次转换成数组 [...new Set(arr)] Array.from(new Set(arr))
```

```js
// 2021.06 跨页面通信
- 第三遍 2025.2.8 -
同源页面：①localStorage setItem+window.onstorage=()=>{}，只能处理非当前页面
②new BroadCastChannel('b') 两个页面实例化相同广播，b.postMessage('xxx')+b.onmessage=()=>{}
非同源页面：
③postMessage（H5 API：使用 const win = window.open(url); win.postMessage('xxx'); + window.onMessage=()=>{}
④iframe 使用 origin 配置成同源
- 第一遍 -
❌ // 1、构造函数的名称记错：BroadCastChannel
```

```js
// 2020.03 模块化
- 第三遍 2025.2.8 -
CommonJS：同步，适合服务端，运行时，输出值的拷贝，require+exports
AMD：异步，依赖前置，并行加载多个依赖，按照加载先后顺序执行，无法控制执行时机，define(['a.js'], function(a){ a.call(); }) ⭐️ // 加载完了立即执行调用，无法按序执行
CMD：异步，依赖就近，并行加载多个依赖，按照书写顺序执行，define(function(require, exports, model) { 
	let a = require('./a.js'); ⭐️ // 加载后按序执行
    a.call();
})
ES6：异步，服务端+客户端通用解决方案，编译时，输出值的引用，export default import as from 
- 第一遍 -
❌ // 1、少写了 AMD - 加载模块后直接执行，无法保证执行顺序；CMD - 加载后，直调调用才按序执行
```

```js
// 2019.07 深拷贝和浅拷贝的区别？怎么实现深拷贝？
- 第三遍 2025.2.8 -
基础类型：深、浅拷贝都是拷贝一个副本
引用类型：浅拷贝拷贝的是引用地址，修改新值会影响原值；深拷贝-引用地址指向的数据，修改新值不会影响原值
浅：[...arr]/Array.from(arr)/arr.concat()/arr.slice()/Object.assign({}, obj)/{...obj}
深：JSON.parse(JSON.stringify(target))/
function isObj(t) {
    const type = typeof t;
    return t !== null && (type === 'function' || type === 'object');
}
function handleSpecial(t, type) {
    switch(type) {
		case '[object Date]':
            return new Date(t.getTime());
            break;
		case '[object RegExp]':
            return new RegExp(t.source, t.flags);
            break;
		case '[object Symbol]':
            return Symbol.for(t.description);
            break;
        default:
            const ctor = t.constructor;
            return new ctor(t); 
    }
}
function clone(target, m = new weakMap()) {
    if(!isObject(target)) {
        return target
    }
    const detailType = Object.prototype.toString.call(target);
    const specialType = ['Map', 'Set', 'Array', 'Object'].map(it => `[object ${it}]`);
    if(!specialType.includes(detailType)) {
        return handleSpecial(target, detailType);
    }
    
    const ctor = target.constructor;
	let res = new ctor();
    if(m.has(target)) {
        return target;
    }
    m.set(target, res);
    if(detailType === '[object Map]') {
		target.forEach((value, key) => {
            res.set(key, clone(value, m))
        })
    } else if (detailType === '[object Set]') {
        target.forEach(it => {
            res.add(clone(it, m))
        })
    } else if(Array.isArray(target)) {
        target.forEach((it, index) => {
            res[index] = clone(it, m);
        })
    } else {
        for(let i in target) {
            res[i] = clone(target[i], m);
        }
    }
    return res
}
- 第一遍 -
❌ // 1、属性名写错了：正则类型的 t.flags
❌ // 2、 方法错了：object 不是可迭代对象，不能使用 for...of，这里应该改为 for...in
```

```js
// 2021.05 XSS跨域脚本攻击 和 CSRF跨站请求伪造攻击
- 第三遍 2025.2.8 -
脚本攻击的原因：浏览器给同源协议开了两个后门：①可以引入第三方数据 ②通过CORS可以请求第三方资源
XSS跨域脚本攻击：
定义-前端页面注入代码，修改服务端数据
解决：①禁止渲染时 DOM 执行 js 代码，例如 img、script
②服务端对用户输入等数据过滤、转义
③HttpOnly 禁止js访问cookie，js引擎会禁用 document.cookie 等
④CSP 内容安全策略 Content-Security-Policy 客户端信任的引入资源域名 meta+响应头 ⭐️ // script-src 'self'
CSRF跨站请求伪造攻击：
定义-冒用用户信息获取服务端信任，修改服务端数据
①cookie Samesite
②验证码+CSRF token
③请求头 referer
- 第二遍 -
⭐️ // CSP - 从客户端角度讲的，哪些域名的资源可以被信任；CORS - 从服务端角度讲的，哪些域名可以访问这个资源
- 第一遍 -
❌ // 1、少写了：XSS的解决方案中，在「渲染时」禁止标签执行 js 代码
```

```js
// 2021.05 29 WebSocket
- 第三遍 2025.2.8 -
全双工双向实时通讯协议
由于 HTTP 的请求-应答模型，无法实现实时通讯
1、使用新的协议 ws:80 wss:443
2、使用新的发现服务方式 URI，而不是ip+端口
3、不受同源协议限制、使用二进制帧，双向通讯 ⭐️ // 在语义语法上完全不兼容
4、基于 HTTP 进行连接，GET 请求头中 Connection: update，如果响应头中 Update: websocket，切换协议
- 第二遍 -
❌ // 1、少写了：修改了协议名 ws:80 wss:443
- 第一遍 -
⭐️ // 2、少写了全名：全双工 - 双向通信协议
```

2.2 - LTN2
❌作业25：简单写下 请求创建过程
✅作业49：牛顿三大定律、热力学两大定律
✅作业54：举杯邀明月，对影成三人。的上一句
❌作业74：起舞弄清影 是那首诗？谁写的？下一句是什么？
❌作业55：flex 常见缩写
❌作业59：什么是高阶函数?什么是高阶组件？什么是副作用？简单举例
❌作业61：常见的数据结构有哪些
❌作业73：react 的 setState 是同步还是异步？为什么React有时候有两次 setState，却只执行一次？
❌作业76：显卡的作用？
✅作业77：重绘和重排是什么？有什么区别？
✅作业79：地球四季的成因是什么？
✅2019.07 显示省略号
✅2021.04 25 HTTP/2 特性

```js
// 2021.04 25 HTTP/2 特性
- 第三遍 2025.2.2 -
语义上完全兼容 HTTP/1.1，语法上完全不一样
1、压缩头部字段，HPACK字典表算法
2、使用二进制帧，双向传输数据流-模拟虚拟的流，多路复用-多个请求响应复用一个连接，多个请求响应之间没有了顺序关系，解决了队头堵塞问题
3、服务器推送
4、使用HTTPS
5、设置优先级
- 第一遍 -
❌ // 1、少写一个特性：服务器推送
```

```js
// 2019.07 显示省略号
- 第三遍 2025.2.2 -
.line {
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
}
.lines {
    display: -webkit-box-;
    overflow: hidden;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 3;
    ⭐️ // line-height: 10px; height: 30-padding;
}
- 第一遍 -
❌ // 1、css 属性名错误：-webkit-box-orient: vertical;
```

```js
// 作业79：地球四季的成因是什么？
- 第二遍 2025.2.2 -
和太阳旋转的椭圆形无关
和太阳直射夹角 + 穿过大气层厚度有关（强度
⭐️ // 直射点的移动 + 太阳照射时长 - 夹角和地面角度的改变，改变了太阳辐射面积和经过大气层的路程衰减的辐射能量强度
```

```js
// 作业77：重绘和重排是什么？有什么区别？
- 第二遍 2025.2.2 -
解析DOM树 - 样式计算 css - 布局树 - 分层树 - 绘制
重绘只需要修改分层+合成
⭐️ // 触发方式主要是 字体、背景、边框颜色
重排需要布局+分层+合成，性能消耗大
⭐️ // 字体大小、padding/margin、激活伪类、style样式的修改、resize、页面初始渲染、DOM增删、位置内容的修改、DOM布局查询
```

```js
// 作业76：显卡的作用？
- 第二遍 2025.2.2 -
用于绘制帧
在后区渲染好之后，直接替换前区帧
⭐️ // 合成新的图像，并将图形保存到后缓存区
```

```js
// 作业73：react 的 setState 是同步还是异步？为什么React有时候有两次 setState，却只执行一次？
- 第三遍 2025.2.2 -
React 合成事件 - 异步；原生事件 - 同步
❌ // 1、除了合成事件，还有「生命周期函数」中都是异步
React 在处理 setState 的时候，在执行回调函数时，会创建一个队列存储，执行完回调函数，统一处理队列中的 setState ，有个合并处理机制 ⭐️ // 批量处理机制 + 更新一次 state ，触发一次重新渲染
在原生事件中不受 React 管控，直接执行 ⭐️ // setState 一次，就会触发一次渲染
- 第一遍 -
❌ // 1、除了合成事件，还有生命周期函数
```

```js
// 作业61：常见的数据结构有哪些
- 第三遍 2025.2.2 -
结构化数据：队列、栈、链表 ❌ // 1、少写了一个类型：数组
非结构化数据：树、图
```

```js
// 作业59：什么是高阶函数?什么是高阶组件？什么是副作用？简单举例
- 第四遍 2025.2.2 -
高阶函数：输入/输出是函数的函数，例如 map
高阶组件：输入是组件
副作用：在函数内部会修改外部参数、全局参数、IO ⭐️ // 除了返回值
function fun(Child){
    return class extends React.Component {
        constructor(props) {
            super(props);
        }
        render() {
            return Child
            ❌ // 1、<Child {...this.props} />
        }
    }
}
```

```js
// 作业55：flex 常见缩写
- 第四遍 2025.2.2 -
flex: none; // 0 0 auto
flex: 1; // 1 1 0
flex: auto; // 1 1 auto
❌ // 1、少写了一个 flex: initial; // 0 1 auto
- 第二遍 -
❌ // 1、把 0 0 auto 的缩写写错，应该是 flex: none;
- 第一遍 -
❌ // 1、把 0 0 auto 的缩写写错，应该是 flex: none;
```

```js
// 作业74：起舞弄清影 是那首诗？谁写的？下一句是什么？
- 第二遍 2025.2.2 -
宋 苏轼/苏东坡  ❌ // 1、题目记不起来：《水调歌头 明月几时有》
我欲乘风归去，又恐琼楼玉宇，高处不胜寒
不知天上宫阙，今夕是何年，何似在人间 ❌ // 2、乱序：起舞弄清影，何似在人间
/**
	明月几时有？把酒问青天。不知天上宫阙，今夕是何年。
	我欲乘风归去，又恐琼楼玉宇，高处不胜寒。
	起舞弄清影，何似在人间。
	转朱阁，低绮户，照无眠。
	不应有恨，何事长向别时圆。
	人有悲欢离合，月有阴晴圆缺，此事古难全。
	但愿人长久，千里共婵娟。
*/
```

```js
// 作业54：举杯邀明月，对影成三人。的上一句
- 第三遍 2025.2.2 -
花间一壶酒，独酌无相亲
```

```js
// 作业49：牛顿三大定律、热力学两大定律
- 第三遍 2025.2.2 -
牛顿三大定律：加速度定律 a=F/m、惯性定律、作用力和反作用力
热力学两大定律：能量守恒定律、熵增定律（在自然条件下，变得混乱是趋势
- 第一遍 -
❌ // 1、少写了惯性定律 - 公交车记忆：刹车-加速度、乘客-惯性、地上痕迹-摩擦
```

```js
// 作业25：简单写下 请求创建过程
- 第四遍 2025.2.2 -
function request(url) {
    let xhr = new XMLHttpRequest();
    xhr.onerror = () => {}
    xhr.ontimeout = () => {}
    xhr.onreadystate = function (res) {  ❌ // 1、函数名称错误：onreadystatechange
        switch(this.readyState) { ❌ // 2、属性不在 this 上，在 res 上：res.readyState
            case 0:// 还未开始请求
                ❌ // 3、请求还没开始，要使用 break 跳出循环
            case:4
                if(this.status === 200 || this.status === 304) {
                    console.log(this.responseText)
                }
        }
    }
    xhr.open('GET', url, true); // 允许异步
    xhr.timeout = 3000;
    xhr.responseType = 'text';
    xhr.setRequestHeader(key, value);
    xhr.send();
}
- 第二遍 -
❌ // 1、属性名称记错 ：res.readyState
- 第一遍 -
❌ // 1、open 的参数顺序记错了：xhr.open('GET', url, true)
```

1.31 - LTN1 - 8题

✅作业70：Vue 和 React 的 Diff 算法比较
❌作业72：react 的 声明周期有哪些，在不同生命周期中做什么事情？
✅作业80：对DOM 树的理解 - 定义和作用
✅作业86：Nextjs 中 Link 的变更是哪个版本开始的，有什么变更？从这个版本开始对路由有什么变更？
❌作业87：Nextjs 中预渲染是什么？有哪些模式？写一个动态路由的page
❌作业88：mysql2 和 Sequelize 的使用场景？有哪些差异？简单写一个连接
❌2021.07 数组扁平化（一层、全部展开、指定深度）
✅2021.07 bind、apply/call三者异同+apply/call实现bind

```js
// 2021.07 bind、apply/call三者异同+apply/call实现bind
- 第五遍 2025.1.31 -
同：改变函数的 this 指向 + 不传第一个参数时，函数的 this 指向 window
异：bind 返回函数副本；apply/call 立即执行函数
   apply 的第二个参数是类数组或者数组；call 接收多个参数
Function.protytype.fakeBind = function(thisArg, ...args1) {
    let func = this;
    return function F(...args2) {
        if(func instanceof F) {
            return new func(...args1, ...args2)
        }
        func.call(thisArg, ...args1, ...args2)
    }
}
- 第四遍 2025.1.25 -
- 第三遍 2025.1.24 -
❌ // 1、bind 实现应该绑定在原型对象上实现，这样才能 this 指向调用函数
- 第二遍 2025.1.19 -
❌ // 1、bind 函数接收多个参数 - 第一个是 this 指向；后面接收多个参数
```

```js
// 2021.07 数组扁平化（一层、全部展开、指定深度）
- 第五遍 2025.1.31 -
一层：arr.flat()、[].concat(...arr)、[].concat.call([], ...arr)、[].concat.apply([], arr)
全部展开：arr.flat(Infinity)、arr.toString().split(',')、JSON.parse(JSON.stringify(arr))
❌ //  JSON.parse(JSON.stringify(arr)) 是用于深拷贝的，不能展开
function expense(arr, deep = 1) {
    return arr.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) && deep > 1 ? expense(cur, deep - 1) : cur)
    })
}
- 第四遍 2025.1.25 -
- 第三遍 2025.1.24 -
❌ // 1、少写了 arr.flat(Infinity)
❌ // 2、JSON.stringify 不会展开数组
❌ // 3、全部展开递归函数中，pre 的值不要使用 push 来更新 - concat 既能处理数组，也能处理非数组
- 第二遍 2025.1.19 -
❌ // 1、deep 传递的时候要减一
```

```js
// 作业88：mysql2 和 Sequelize 的使用场景？有哪些差异？简单写一个连接
- 第三遍 2025.1.31 -
mysql2 是适用于node场景的 mysql 驱动，可以直连数据库，但是需要写很多 SQL
⭐️ // 提供了 mysql2/promise 模块，允许 async/await 、管理多个数据库连接；没有内置的对象关系映射ORM
import { createPool } from 'mysql2' ❌ // 1、依赖包错了 mysql2/promise
const pool = createPool({host, user, password}); ❌ // 2、少写了 database
const connection = await pool.getConnection(); ❌ // 3、获取连接的函数错了 await pool.getConnect()
const data = connection.execute('SELECT * FROM table') ❌ // 4、需要使用 await：const [rows] = await connection.execute('SELECT * FROM table')
--
Sequelize 数据库模块，ORM 把整个数据库表对象化，可以通过函数式编程直接调用使用，执行事务
⭐️ // ORM 把数据库的表和行映射为对象模型
import { sequelize, Datatypes, Modal } from 'sequelize'
const se = new sequelize(database, user, password, {
    host: 'localhost',
    dialect: 'mysql2'
})
创建连接后，会一直保持连接状态，直到调用 se.close() 关闭连接
class se extends Modal {}
se.define('table', {
    id: Datatypes.number
}, {
    underScore: false;
})
❌ // 5、有两种模型定义方法：一种是 define，另一种 extends Modal + init
/**
const User = se.define('table', {
    id: Datatypes.number
}, {
    underScore: false;
})
--
class User extends Modal {}
User.init({
	id: Datatypes.number
}, {
	sequelize: se, // 传递连接实例
	modalName: 'User' // 模型名称
})
最后调用： User.findAll({ attribute: ['id', 'name'] })
*/

- 第二遍 2025.1.26 -
❌ // 1、mysql2 的依赖包是 mysql2/promise
❌ // 2、mysql2 创建连接池不需要 await:const pool = createPool({host, user, password, database})
❌ // 3、mysql2 获取连接时需要 await:const connection = await pool.getConnect()
❌ // 4、mysql2 查询数据时需要 await:const [rows] = await connectiom.execute('SQL')
❌ // 5、sequelize 实例化创建连接 const s = new sequelize(database, user, password, { host, dialect })
❌ // 6、sequelize 模型定义的底层 - 先扩展，再init定义

- 第一遍 2025.1.22 -
❌ // 1、mysql2 提供的连接的两个特点： mysql2/promise 支持 async/await + 管理多个数据库连接池
❌ // 2、sequelize 将数据库的表和行映射为对象模型，直接通过 js 操作
```

```js
// 作业87：Nextjs 中预渲染是什么？有哪些模式？写一个动态路由的page
- 第三遍 2025.1.31 -
预渲染：包含服务端渲染 SSR、静态生成SSG、ISR 增量静态生成
SSR:getServerSideProps 客户端每次请求，都在服务端构建 HTML，动态引入 data 数据，返回给客户端直接渲染，而不是交给客户端js
SSG+ISR:getDerivedStateParams + revalidate 在构建时，直接生成 HTML，超过更新时间后，后台直接重新构建
❌ // 1、记错函数名称，13.x 之前是 getStaticProps，现在已经改为 generateStaticParams，用于生成动态路由的参数列表
SSR
import { getServerSideProps } from 'next/server'
function Blog({ data }) { return <div>{data}</div> }
async function getServerSideProps() {
    const data = await fetch('xxxx');
    return { props: { data: data.json() } }
    ❌ // 2、data.json() 是异步的，异步解析数据，处理 json 数据转换为 js 对象 - const res = await data.json;
}
export default Blog;             
SSG
function Blog({ data }) { return <div>{data}</div> }
async function getDerivedStateParams() {
    const data = await fetch('xxxx');
    return { props: { data: data.json() } }
    ❌ // 3、return 的应该是个路由列表 例如 return [{slug: 'first'}, {slug: 'second'}]
}
const revalidate = 60; // 秒
❌ // 4、export const revalidate = 60; // 页面重新验证时间
export default Blog;
                         
- 第二遍 2025.1.26 -
❌ // 1、SSR getServerSideProps: fetch 数据需要 await: const data = await fetch('xxx')
❌ // 1、SSR getServerSideProps: 异步解析数据需要 await: const res = await data.json()
- 第一遍 2025.1.22 -
❌ // 1、SSG generateStaticParams 用于生成动态路由的参数列表
❌ // 2、SSG revalidate 用于定义页面重新验证时间 - 页面将重新生成，运行时生成/更新静态页面以增量更新
```

```js
// 作业86：Nextjs 中 Link 的变更是哪个版本开始的，有什么变更？从这个版本开始对路由有什么变更？
- 第二遍 2025.1.31 -
13.x 开始 Link 中不再写 a 标签用于跳转 - 因为 Link 会被解析为 a 标签
文件路由系统 - 从 pages 改为 src/app/page.tsx，Layout.tsx global.css 可以直接修改全局布局，方便布局
后端路由系统 - src/app/api/route.tsx
- 第一遍 2025.1.22 -
❌ // 1、少写了后端路由系统
```

```js
// 作业80：对DOM 树的理解 - 定义和作用
- 第三遍 2025.1.31 -
DOM 树是 HTML 的树形对象结构，属性对应于 DOM 节点的各种特性 ⭐️ // 「对象化表示」，是按照 HTML 结构转换的树形结构的对象模型
js - DOM 树提供了 JS 访问、修改 HTML 的交互接口
浏览器 - 浏览器渲染依赖于 DOM 结构 ⭐️ // 浏览器根据 DOM 结构构建页面布局
框架 - 框架利用 VDOM 比较得到最小更新 UI 量，再改动真实 DOM，提高了 Diff 性能 ⭐️ // 提高页面更新性能
- 第二遍 2025.1.25 -
- 第一遍 2025.1.24 -
❌ // 1、除了js，少写了浏览器 - 渲染页面的依据和框架视角 - VDOM Diff 计算提高更新性能
```

```js
// 作业72：react 的 声明周期有哪些，在不同生命周期中做什么事情？
- 第六遍 2025.1.31 -
类组件
挂载阶段
getDerivedStateFromProps
componentDidMount - 首次渲染执行
render
❌ // 1、少写了 constructor - 初始化 state 和绑定事件处理函数的 this
更新阶段
getDerivedStateFromProps
componentDidUpdate - 更新后执行
shouldComponentUpdate(nextProps, nextState) - 返回布尔值判断是否需要重新渲染
render
卸载阶段
componentWillUnMount - 卸载前执行

函数组件
useEffect 模拟 componentDidMount回调函数执行一次 ⭐️ // 内部函数
		  模拟 componentDidUpdate 依赖更新，再次执行回调函数
          模拟 componentWillUnMount 返回一个清理函数，在组件卸载前执行
useLayoutEffect 在 commit 阶段后，同步执行函数，阻塞重绘
- 第五遍 2025.1.25 -
- 第四遍 2025.1.24 -
❌ // 1、shouldComponentUpdate 写错在挂载阶段，实际应该归属于更新阶段
❌ // 2、阶段划分是：挂载-更新-卸载，其中更新阶段记错了 - 应该是当组件的 state/props 变化，进入更新阶段，重新执行 render 函数来更新 DOM
- 第三遍 2025.1.19 -
❌ // 1、挂载阶段：少写了 constructor - 初始化 state 和绑定时间处理函数的 this
❌ // 2、除了类组件函数的生命周期，还要意识到函数组件也通过 hooks 模拟生命周期
```

```js
// 作业70：Vue 和 React 的 Diff 算法比较
- 第六遍 2025.1.31 -
Vue 双端指针指针算法 + 静态节点跳过 + 找不到匹配节点，先判断同类型+同 key 的节点是否同索引，索引相同则复用 + 列表组件，同类型同key 的节点复用
React：分层比较 + 同层级同类型节点优先比较 - 不同节点类型，直接重新渲染；同类型同key 移动复用；同类型 修改属性
⭐️ // React 是精确到节点属性级别的 Diff 计算，适合大型动态复杂场景；Vue 基于组件级别的 Diff 计算
- 第五遍 2025.1.25 -
❌ // 1、Vue 少写了静态节点跳过 + 基于组件级别的更新算法
❌ // 2、React 是基于单个节点属性级别，适合大型冬天复杂场景
- 第四遍 2025.1.24 -
❌ // 1、Vue - 找不到匹配的节点后，先找同类型+同key的节点进行索引比较，一致则复用，不一致则移动到新位置修改复用
- 第三遍 2025.1.18 -
❌ // 1、Vue - 双端指针算法比较后，是找同类型和同key的节点比较
❌ // 2、Vue - 少写了：静态节点跳过比较
- 第二遍 2025.1.13 -
```




1.30 - LTN1 - 2题

✅作业82：写一个复杂的 SQL： ①只返回某列不同的值，相同的忽略 ②拼接A列和B列为字符串后输出 ③将某一列转换为大写输出 ④计算某列行数，一个包含null的个数，一个不包含null个数 ⑤求和、求最大、求最小、求平均某列的值 ⑥给表起别名 ⑦查询条件涵盖 id为1,同时price大于10，或者是NULL，或者是 5-10之间，或者是 1或2，或者年份为2025 ⑧按照某列分组 ⑨按照某列排序(降序)
✅2023.07 clickhouse、mysql、mongodb异同

LTN3
❌作业3：迭代器原理
✅作业41：TED 如何解决焦虑

LTN4
✅作业4：什么是生成器？有什么作用？
✅作业18：多进程浏览器会开启几个进程（5个点）？相同站点的页面，可以复用么？
✅作业19：发起请求后，得到 301，有效信息是哪些？
✅作业21：下面这段代码输出结果是什么？为什么 

```js
console.log(11, fun1);
function fun1(n1, n2) { arguments[1] = 10; return n1 + n2; }
var fun1 = 1;
console.log(22, fun1)
```

✅作业22：分别输出什么？

 ```js
function foo(){
    var a=1;
    let b=2;
    {
        let b=3;
        var c=4;
        let d=5;
        console.log(a);
        console.log(b);
    }
    console.log(b);
    console.log(c);
    console.log(d);
}
foo();
 ```

❌作业24：写出事件循环系统的流程图，常见宏任务、微任务有哪些。并写出几个常见题目的输出结果

 ```js
Promise.resolve().then(() => {
    console.log(1);
    Promise.resolve().then(() => {
        console.log(2);
    }).then(() => {
        console.log(3);
    }).then(() => {
        console.log(4);
    })
}).then(() => {
    console.log(5);
}).then(() => {
    console.log(6);

})
------

async1 = async () => {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
function async2(){
    console.log('async2');
}
console.log('script start');
setTimeout(() => {
    console.log('setTimeout');
})
async1();
new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(() => {
    console.log('promise2');
    return new Promise(function(resolve) {
        resolve();
    })
}).then(() => {
    console.log('promise3');
})
console.log('script end');
 ```

✅作业27：写一个 sleep 函数
✅作业28：写出 js 按什么顺序执行

```html
<script src='./a.js' defer></script>
<script src='./b.js'></script>
<script>
    console.log('event start');
    document.addEventListener('DOMContentLoaded', () => {
        console.log('DOMContentLoaded finish');
    })
    window.addEventListener('load', () => {
        console.log('onload finish');
    })
</script>
<body>
    <div>
        <script>
            let i = 0;
            while(i<1000) {
                i++;
            }
            console.log('compute finished');
        </script>
    </div>
</body>
```

✅作业35：写出HTPPS和HTTP的差异？对称加密和非对称加密有什么异同？混合加密是怎么做的？
✅2019.07 css中的动画特性可以用js实现，那为什么还要用css来实现？
❌2021.06 子盒子在父盒子中水平垂直居中有几种方法？
✅2024.10 第十一章 期约与异步函数 小结
✅2019.06 随机给一个盒子添加一个十六进制的颜色

```js
// 2019.06 随机给一个盒子添加一个十六进制的颜色
function addColor() {
    let res = '#';
    const arr = ['0', ...,'9','a', ... 'f'];
    Array(6).forEach(it => {
        const index = Math.floor(Math.random() * 16);
        res += arr[index];
    })
    return res;
}
```

```js
// 2021.06 子盒子在父盒子中水平垂直居中有几种方法？
- 第一遍 2025.1.30 -
①flex .father { display: flex; justify-content: center; align-items: center; }
② .son { position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto;  }
③ .son { position: absolute; transform: translate(-50%, -50%); left: 50%; top: 50%; }
④ .son { display: table-cell; text-align: center; vertial-align: middle; } ❌ // 1、不是给子元素 添加 table-cell，这个方法的核心是把 父盒子 设置为 table-cell，使得另外两个属性生效 - 而子盒子作为行内块类型，垂直、居中 .father { display: table-cell; text-align: center; vertical-align: middle; } .son { display: inline-block; }
```

```js
// 2019.07 css中的动画特性可以用js实现，那为什么还要用css来实现？
- 第一遍 2025.1.30 -
js 实现动画： 占用主线程执行；低版本浏览器可能需要写兼容性代码；
css 实现动画： 有些 transform、opacity 只需要合成线程，并且可以开启 GPU 加速；加载完 css 就可以开始渲染动画，不用等 js 执行；优雅降级
⭐️ // 避免回流重绘 + 自然降级 + 硬件GPU加速 + 预扫描加载快
```

```js
// 作业35：写出HTPPS和HTTP的差异？对称加密和非对称加密有什么异同？混合加密是怎么做的？
- 第一遍 2025.1.30 -
HTTPS = HTTP + SSL/TLS，把 TCP 层改为 SSL/TLS 层
对称加密 - 只有一个密钥用于加密、解密
非对称加密 - 公钥可以发放，客户端加密使用公钥，私钥用于解密，只有服务端独有
混合加密 - 使用非对称加密商讨出对称加密使用的密钥 ⭐️ // 协商
```

```js
// 作业28：写出 js 按什么顺序执行
- 第一遍 2025.1.30 -
b.js - event start - compute finished - a.js - DOMContentLoaded finish - onload finish
```

```js
// 作业27：写一个 sleep 函数
- 第一遍 2025.1.30 -
async function sleep(delay){
    return new Promise((resolve) => setTimeout(() => resolve(), delay));
    ⭐️ // 不用写 async + setTimeout 可以简写成 setTimout(resolve, delay)
}
await sleep(100);
```

```js
// 作业24：写出事件循环系统的流程图，常见宏任务、微任务有哪些。并写出几个常见题目的输出结果
- 第一遍 2025.1.30 -
时间循环系统
事件：同步类型 - 主线程执行 - 执行完成，清理执行栈之前，从事件队列中获取事件执行 - 所有微任务执行完毕后，进入下一个事件循环
	 异步类型 - Event Table - 将回调函数投入事件队列 ⭐️ // Event Queue
⭐️ // 等异步任务有了结果，将回调函数投入事件队列
宏任务 ： UI渲染、IO下载、js代码、setTimeout/setTimeInterval ⭐️ // IO表示下载和交互
微任务： MutationObserver、Promise.then、async/await
1 5 2 6 3 4 ❌ // 125364 
script start - async1 start - async2 - promise1 - script end
- async1 end - promise2 - promise3 - setTimeout
```

```js
// 作业22：分别输出什么？
- 第一遍 2025.1.30 -
1 3 2 4 error
```

```js
// 作业21：下面这段代码输出结果是什么？为什么 
- 第一遍 2025.1.30 -
11 function
22 1
执行上下文中，函数内先创建 auguments、再函数提升、最后变量提升
```

```js
// 作业19：发起请求后，得到 301，有效信息是哪些？
- 第一遍 2025.1.30 -
Location 重新导航
```

```js
// 作业18：多进程浏览器会开启几个进程（5个点）？相同站点的页面，可以复用么？
- 第一遍 2025.1.30 -
浏览器进程、渲染进程*n、插件进程*n、网络进程、GPU进程
同协议、同域名、同端口 可以复用当前渲染进程
```

```js
// 作业4：什么是生成器？有什么作用？
- 第一遍 2025.1.30 -
生成器：暂停、恢复代码执行，* 声明，yield next 
自定义可迭代对象、模拟协程
```

```js
// 2023.07 clickhouse、mysql、mongodb异同
- 第二遍 2025.1.30 -
clickhouse: 列式数据库，支持异步操作，读写性能都好，适合大型动态场景 ⭐️ // 高吞吐、低延迟
mysql：关联型数据库，支持事务操作，读写性能好，在并发操作时，会出现数据一致性问题
mongodb：文档型数据库，存储半结构化/非结构化数据，读的性能好，写的性能弱，在异步操作时，有数据一致性问题 ⭐️ // 分布式场景下一致性问题
- 第一遍 2025.1.22 -
```

```js
// 作业82：写一个复杂的 SQL： ①只返回某列不同的值，相同的忽略 ②拼接A列和B列为字符串后输出 ③将某一列转换为大写输出 ④计算某列行数，一个包含null的个数，一个不包含null个数 ⑤求和、求最大、求最小、求平均某列的值 ⑥给表起别名 ⑦查询条件涵盖 id为1,同时price大于10，或者是NULL，或者是 5-10之间，或者是 1或2，或者年份为2025 ⑧按照某列分组 ⑨按照某列排序(降序)
- 第二遍 2025.1.30 -
SELECT DISTINCT t.name, 
    CONCAT('(', t.interval, ')') AS interval, 
    UPPER(t.type) AS type,
    COUNT(*) AS with_null,
	COUNT(t.name) AS without_null,
    AVG(t.gap) AS avg // -- MAX MIN SUM
FROM Times as t, Issues as i
WHERE t.id = 1 AND
	(t.price > 10
    OR it.price IS NULL
    OR it.price BETWEEN 5 AND 10,
    OR it.price in (1,2),
    OR YEAR(it.date) = 2025)
GROUP BY t.date
SORT BY t.date
- 第一遍 2025.1.23 -
```

```js
// 作业3：迭代器原理
- 第二遍 2025.1.30 -
提供暂停和恢复代码执行能力，[Symbol.iterater] 默认迭代器
yield 暂停，next 恢复执行 {done, value}
❌ // 迭代器使用 next 方法在可迭代对象中遍历数据
- 第一遍 2024.12.25 -
```

```js
// 作业41：TED 如何解决焦虑
- 第二遍 2025.1.30 -
1、列出所有可以解决问题的方案，去做 do it badly ⭐️ // anything worth doing worth doing badly the first time
2、给自己一些同情 ⭐️ // 我们不会和天天批评自己的人交朋友，我们也不要做自己这样的朋友 
3、找到意义 ⭐️ // 即使别人不知道，自己一定要认可自己的行为
- 第一遍 2024.12.25 -
```

1.29 - LTN1 - 4题

❌作业66：React如何处理错误
✅作业81：Redux 核心是什么？reducer、action、dispatch、store、RTK 怎么理解？简单写一个 redux 使用
✅作业83：INNER JOIN、LEFT OUTER JOIN、RIGHT OUTER JOIN 有什么区别?UNION作用是什么？怎么封装一个 SQL 查询
✅作业84：path.join()和path.resolve()的区别？process.cwd()和__dirname的区别？

```js
// 作业84：path.join()和path.resolve()的区别？process.cwd()和__dirname的区别？
- 第二遍 2025.1.29 -
path.join() 纯拼接
path.resolve() 拼接绝对路径 / ⭐️ // 绝对路径解析
process.cwd() 获取 node 执行环境的当前目录
__dirname 当前文件的所处目录
- 第一遍 2025.1.22 -
```

```js
// 作业83：INNER JOIN、LEFT OUTER JOIN、RIGHT OUTER JOIN 有什么区别?UNION作用是什么？怎么封装一个 SQL 查询
- 第二遍 2025.1.29 -
INNER JOIN 内联查询 取AB表都满足条件的行，即交集 ⭐️ // 内连接 
LEFT OUTER JOIN 左表查询 取左表满足条件的行及右表补充的行
RIGHT OUTER JOIN 右表查询 取右表满足条件的行及左表补充的行
UNION 连接两次查询 ⭐️ // 拼接
封装 CREATE VIEW mySearch AS SELECT ...
下次使用的时候直接 FROM mySearch
- 第一遍 2025.1.22 -
```

```js
// 作业81：Redux 核心是什么？reducer、action、dispatch、store、RTK 怎么理解？简单写一个 redux 使用
- 第二遍 2025.1.29 -
Redux 将全局状态保存在 store 对象树中，通过 action 才能 dispatch 改变 store ⭐️ // 改变 state
RTK - Redux tollkit 官方推荐依赖
reducer: 使用 旧的state 和 action 计算得到 新的state
import { crateStore } from 'redux';
const reducer = (oldState = { value: 1 }, action) => { 
    if(action.type === 'add') { return { value: oldState.value + 1 } } 
}
const store = createStore(reducer);
store.dispatch({ type: 'add' });
store.subscribe(() => { console.log(store.getState()) })
- 第一遍 2025.1.22 -
```

```js
// 作业66：React如何处理错误
- 第六遍 2025.1.29 -
React 提供两个函数处理错误 static getStateFromError()、componentDidCatch，用于捕获 
❌ // 1、静态函数名称错了 getDerivedStateFromError
render+commit 阶段的错误，阻止错误蔓延到整个应用影响 UI 展示
几个情况不会捕获：异步、回调、ssr、错误边界内部
class Boundaries extends React.Component{
    constructor() {
        super(props);
        this.state = { hasError: false }
    }
    static getStateFromError() { ❌ // 2、getDerivedStateFromError
        return { hasError: true }
    }
    componentDidCatch(e, info) {
        console.log(e)
    }
    render() {
        if(this.state.hasError) {
            return <p> There are errs. </p>
        } else {
            return this.props.children;
        }
    }
}
- 第五遍 2025.1.22 -
- 第四遍 2025.1.18 -
```

1.28 - LTN1 - 2题

✅作业20：浏览器打开一个 URL 发生了什么
✅2021.09 Object属性排序、与Map的区别

```js
// 作业20：浏览器打开一个 URL 发生了什么
- 第三遍 1.28 -
1、浏览器进程 UI线程：将用户输入内容或者链接转换成 URL
2、通过 IPC 协议传递给网络进程
网络进程：① 查询本地缓存，有缓存且有效则 强缓存生效
	②无缓存/有缓存但已过期，DNS 解析得到 IP
    ③TCP 队列排队，三次握手，进行连接
    ④组装请求：请求头、cookie 等信息
    ⑤发起请求
响应 状态码：301、302 重定向，获取响应头中的 Location 进行重新跳转
		   304 Not Modified，使用缓存，并刷新本地缓存时间
           200 响应类型是 os-stream 下载类型，直接触发下载，停止导航
           	   响应类型是 html，和浏览器进程建立管道，边下载边解析
3、渲染进程
①分为主线程、合成线程、预解析线程，解析 html 时，开启预扫描线程扫描 js、css，提前下载
②管道传输完毕后，通知浏览器进程，更新 页面、前进后退、url、安全锁
③下载完成，解析完成之前 - 解析白屏
主线程：解析DOM（DOM树） - 计算样式表 - 布局树 - 分层树 - 绘制（指令列表
合成线程： - 栅格化（图块合成位图）[会开启 GPU 加速]
浏览器进程 UI线程：- 合成（帧
- 第二遍 1.20 -
❌ // 1、IPC 协议名错了 2、有缓存但缓存失效也继续请求 3、请求的响应，应该先判断状态码再判断类型
```

```js
// 2021.09 Object属性排序、与Map的区别
- 第三遍 1.28 -
正整数 > 字符串 > 负数 > 浮点数 > Symbol
区别：有序；属性可以是任意类型；m.size()；大数据，占用内存小，增删快；可迭代对象
- 第二遍 1.21 -
```



1.27 - LTN1 - 8题

✅作业2：支持迭代器的原生语言特性有哪些？
✅作业43：TED 怎么提升自信
✅作业42：TED 如何和大脑正确交流沟通
✅作业39：shim 和 polyfill 区别
❌作业6：new操作符实例化一个对象的过程
✅2019.07 为什么要清除浮动？怎么清除浮动？
✅2021.06 CSS 选择器 - 权重/匹配方式

```js
// 2021.06 CSS 选择器 - 权重/匹配方式
- 第二遍 1.28 -
!important > 行内 > 内联、外联（只和加载顺序有关
#id > .red a[href] :hover LVHA > div ::after > *
- 第一遍 1.20 -
```

```js
// 2019.07 为什么要清除浮动？怎么清除浮动？
- 第二遍 1.28 -
对于浮动元素，块级元素把它当做不存在；行内块元素，环绕布局
父组件中的子组件浮动时，会造成高度塌陷，父级元素的背景无法撑开，padding和border展示异常
清除浮动：①给父级元素添加高度 ②父盒子里最后添加一个盒子 .box {clear:both} ③父盒子添加伪元素 .father::before{ content:''; display: block; clear: both; } ④BFC .father{ overflow: hidden } - BFC 的盒子计算高度时包含浮动元素
- 第一遍 1.20 -
❌ // 1、写错了：是给父元素添加BFC + 父盒子设置高度（宽度不行
```

```js
// 作业6：new操作符实例化一个对象的过程
- 第二遍 1.28 -
function newFun () {
    let obj = new Object();
    const ctor = [].shift.call(arguments);
    obj.__proto__ = ctor; ❌ // 1、不是构造函数，是构造函数的原型对象 obj.__proto__ = ctor.prototype;
    const res = ctor.apply(obj, arguments);
	return typeof res === 'object' ? res : obj;
}
- 第一遍 1.20 -
❌ // 1、不是调整 constructor 的指向
```

```js
// 作业39：shim 和 polyfill 区别
- 第二遍 1.28 -
shim：垫片，提供新API，使用原生功能实现，处理兼容问题 ⭐️ // 优雅降级
polyfill：补丁，实现浏览器原生功能，不提供新的API ⭐️ // 实现原生 API 中缺少的功能
- 第一遍 1.20 -
```

```js
// 作业42：TED 如何和大脑正确交流沟通
- 第二遍 1.28 -
1、I like it, I want it, I've chosen it!
2、Make it familiar!
大脑只会响应我们给它的语言 + 图像（具体的）；大脑天然追寻快乐，所以把想做的事情绑定到巨大的快乐中，不想做的事情、停留在原地，绑定痛苦；大脑喜欢熟悉的东西，做得越多越能够坚持
- 第一遍 1.20 -
```

```js
// 作业43：TED 怎么提升自信
- 第二遍 1.28 -
1、repetition！repetition！repetition！
2、不要批评自己，鼓励、表扬做得好的地方 - 引导自己
3、用自己的语言解释世界
- 第一遍 1.20 -
```

```js
// 作业2：支持迭代器的原生语言特性有哪些？
- 第三遍 1.28 -
Array.from  ...扩展运算符  数组解构  for...of  new Set  new Map  yield *  Promise.all/race
- 第二遍 1.25 -
- 第一遍 1.20 -
❌ // 1、少写了：yield * 操作符 - 只能在生成器中使用；不是对象解构，是「数组解构」
```

