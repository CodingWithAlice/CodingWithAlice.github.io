---
layout:     post
title:     LTN②〇
subtitle:  
date:       2025-3-18
author:     
header-img: 
catalog: true
tags:
    - < LTN >
typora-root-url: ..
---



### LTN②〇

❌2023-09 二叉树：前中后序、层序遍历-递归/非递归版本、层序遍历、路径和
2021-07 给DOM元素绑定事件
❌2021.07 柯里化函数 / 反柯里化函数实现
❌2025-3 NextJS 全局中间件-校验权限
❌2025-3 NestJS 守卫-校验权限
❌2025-03 p-limit 使用+源码 、100个请求并发请求、分时操作
❌2021.07 数组扁平化（一层、全部展开、指定深度）



简历优化：思考每个项目的目标、需求、遇到的问题以及你是如何使用技术来解决这些问题的
- 开发时，如何设计组件架构、管理状态、处理数据交互
- 优化时，采取了哪些具体的措施，如代码压缩、图片优化、缓存策略等【是否引入了新技术提高开发效率、优化用户体验】【是否解决了项目中的关键问题，如性能瓶颈、兼容性问题等。通过具体的案例展示你的实际项目能力和思考】
- 当被问到项目中使用的技术栈时，不要只是简单地列出技术名称，而是要阐述选择这些技术的原因【如何根据项目的需求、团队的技术背景、市场趋势等因素进行综合考虑的。例如，为什么选择 React 而不是 Vue，为什么使用 Nextjs 而不是传统的 React 项目架构】【在项目中解决问题的能力和过程】
- 从业务角度分析项目需求【理解项目的目标用户、业务流程和功能需求，思考如何通过技术来实现业务价值】【当遇到技术难题或业务需求变更时，你是如何分析问题、寻找解决方案并实施的。可以分享一些具体的问题案例，以及你采取的解决措施和最终的效果】



> 工具推荐周期：3.17-3.28 96题 10天 LTN1-39题，LTN2-21题，LTN3-19题，LTN4-11题，LTN5-0题

LTN1 【推荐做题时间 03-17 - 10题 实际做题时间： 3.17】
✅作业36：多分支项目的大致情况
✅作业37：大盘的大致情况
✅2021-04 01 浏览器进程组成 + 复用渲染进程 + 进程/线程
✅作业38：部署两个项目的大致情况
❌2025.02 TS - dayjs 引入但失效问题
❌2025.02 docker-compose 的配置管理 context 
❌2022-10 TS 泛型函数/泛型接口/泛型约束、特性、type/keyof/enum/as/Partial
❌2025-03 浏览器前端性能优化RAIL
❌2025-03 js执行优先级 + 测试题
❌2025-03 TCP 滑动窗口 VS TCP 排队

LTN1 【推荐做题时间 03-19 - 10题 实际做题时间： 3.18 + 3.19】
✅作业20：浏览器打开一个 URL 发生了什么
✅2021.09 Object属性排序、与Map的区别
✅2021.07 防抖节流
✅作业80：对DOM 树的理解 - 定义和作用
❌作业82：写一个复杂的 SQL： ①只返回某列不同的值，相同的忽略 ②拼接A列和B列为字符串后输出 ③将某一列转换为大写输出 ④计算某列行数，一个包含null的个数，一个不包含null个数 ⑤求和、求最大、求最小、求平均某列的值 ⑥给表起别名 ⑦查询条件涵盖 id为1,同时price大于10，或者是NULL，或者是 5-10之间，或者是 1或2，或者年份为2025 ⑧按照某列分组 ⑨按照某列排序(降序)
✅作业84：path.join()和path.resolve()的区别？process.cwd()和__dirname的区别？
❌作业86：Nextjs 中 Link 的变更是哪个版本开始的，有什么变更？从这个版本开始对路由有什么变更？
-✅2021.06 flex布局
❌2025-03 服务器 不明文密码处理
❌2023-09 二叉树：前中后序、层序遍历-递归/非递归版本、层序遍历、路径和

LTN2 【推荐做题时间 03-19 - 3题 实际做题时间： 3.19】
✅2021.07 babel  作用+原理+补丁
✅2021.05 27 HTTP/3 改进的点
❌2021.04 12 垃圾回收机制

LTN4 【推荐做题时间 03-19 - 3题 实际做题时间： 3.19 + 3.20】
✅2021-06 CSS性能优化
-✅2019-06 第一章-第三章 简介、基本概念 小结
-✅2024-11 第十八章 动画与Canvas图形

LTN1 【推荐做题时间 03-20 - 6题 实际做题时间： 3.20】
✅作业23：写出js 代码的执行顺序。词法作用域的特点是什么？ 

```js
function bar(){
    console.log(myName);
}
function foo(){
    var myName = 'hi 坑';
    bar();
}
var myName = 'bye 坑';
foo();

var name = "global name";
var obj = {
    name: 'Alice',
    getName: function() { console.log(this.name) }
}
var getName = obj.getName;
getName();


(function(){
    try{
        console.log(1, a);
        var a="a";
        console.log(a);
        b();
        c();
        function b(){
            console.log("b");
        }
        var c=function(){
            console.log("c");
        }
        console.log("d") // 没有被执行
    }catch(e){
        console.log('err')
    }
})()
```

✅作业63：React渲染怎么实现的？涉及到哪些生命周期/hooks？以 const [count, setCount]=useState(0)具体说明
-✅2024.12 模拟实现promise
-✅2025.02 nextTick 原理，在Vue2、Vue3中分别是什么步骤实现的，简单模拟实现流程
-✅2025-02 KOA2 中间件机制实现、路由处理、错误处理、模版引擎、源码
❌2025.02 Express VS KOA2

LTN4 【推荐做题时间 03-20 - 3题 实际做题时间： 3.20】
❌2021-07 给DOM元素绑定事件
✅2021-04 实现给定时间切换状态
❌2024-11 数组乱序 洗牌算法 从最后一个元素开始，从数组中随机选出一个位置，交换，直到第一个元素。

LTN1 【推荐做题时间 03-21 - 3题 实际做题时间： 3.21】
❌2025-3 NextJS 全局中间件-校验权限
❌2025-3 NestJS 守卫-校验权限
-❌2025-03 p-limit 使用+源码 、100个请求并发请求、分时操作

LTN3 【推荐做题时间 03-21 - 1题 实际做题时间： 3.21】
❌2021.07 数组扁平化（一层、全部展开、指定深度）

LTN1 【推荐做题时间 03-22 - 2题 实际做题时间： 3.22】
-✅作业87：Nextjs 中预渲染是什么？有哪些模式？写一个动态路由的page
✅作业92：前端中的序列化是什么？常见序列化方法。反序列化是什么？有哪些方法。写个POST调用流程

LTN3 【推荐做题时间 03-22 - 6题 实际做题时间： 3.22】
✅作业6：new操作符实例化一个对象的过程
✅作业25：简单写下 请求创建过程
❌作业74：起舞弄清影 是那首诗？谁写的？下一句是什么？
✅作业55：flex 常见缩写
-✅作业59：什么是高阶函数?什么是高阶组件？什么是副作用？简单举例
✅作业73：react 的 setState 是同步还是异步？为什么React有时候有两次 setState，却只执行一次？
✅作业76：显卡的作用？

LTN1 【推荐做题时间 03-23 - 8题 实际做题时间： ？】
作业17：对斐波那切数列进行尾调用优化
作业70：Vue 和 React 的 Diff 算法比较
2024.10 怎么实现跨域
2019.10 两栏，左边固定，右边自适应的布局
作业48： input 和 textarea 对比（宽度设置，初始值设置）；option 标签的初始值设置
作业51： 如何停止过度思考？如何停止焦虑
作业97：Sequelize 中查找某条数据，如果存在就更新；不存在就创建一条
69 x 的平方根

LTN4 【推荐做题时间 03-23 - 5题 实际做题时间： ？】
作业49：牛顿三大定律、热力学两大定律
作业54：举杯邀明月，对影成三人。的上一句
作业77：重绘和重排是什么？有什么区别？
作业79：地球四季的成因是什么？
2021.04 25 HTTP/2 特性

LTN2 【推荐做题时间 03-24 - 10题 实际做题时间： ？】
作业72：react 的 声明周期有哪些，在不同生命周期中做什么事情？
作业88：mysql2 和 Sequelize 的使用场景？有哪些差异？简单写一个连接
作业61：常见的数据结构有哪些
2019.07 深拷贝和浅拷贝的区别？怎么实现深拷贝？
作业93：闭包的作用和原理
2021-07 前端路由的两种模式
作业98：sequelize 怎么写关联表的查询，指定关联的 column 是date
2025.02 Mysql 8.0 以上，Sequel报插件错
2025.02 Nextjs 获取链接中的参数
2025.02 sequelize 在 Nestjs 中的 env 配置

LTN2 【推荐做题时间 03-26 - 4题 实际做题时间： ？】
作业66：React如何处理错误
2021.06 跨页面通信
2019.07 数组去重（算法整理）
2021.07 柯里化函数 / 反柯里化函数实现

LTN3 【推荐做题时间 03-26 - 6题 实际做题时间： ？】
作业58：React和Vue是怎么描述UI的
作业90：金玉满堂是什么意思？在花卉中的说法是什么？
作业91：三次握手的过程和具体包的作用
2021.07 事件流 + 事件模型
2021.06 链表 141. 环形链表
2021.09 get和post有什么区别

LTN2 【推荐做题时间 03-27 - 4题 实际做题时间： ？】
作业64：Vue渲染怎么实现的？
2019.07 css中的动画特性可以用js实现，那为什么还要用css来实现？
2024.10 第九章 代理与反射 小结
2024-12 Nestjs 核心特性、基本概念、生命周期、获取请求和响应、不同组件的实现和执行顺序

LTN3 【推荐做题时间 03-27 - 6题 实际做题时间： ？】
作业62：fiber架构是什么？优点和实现方式？
作业67：React 怎么做的性能优化？
作业68：React hooks 的原理是什么？useEffect useState模拟实现
2020.07 对象分类、Promise按序执行、实现map
2024.11 第十七章 事件
2021-07 常见Webpack问题

LTN5 【推荐做题时间 03-27 - 6题 实际做题时间： ？】
作业16（1）：箭头函数和普通函数的区别是什么？（3点）
2019.07 盒模型有哪些？有什么区别？
作业14：Proxy 的原型是什么？怎么撤销代理关联？是否可逆？写几个常见的代理模式对应的捕获器
作业31：什么是长连接？长连接的属性怎么写？哪个版本开始启用长连接？
作业33：Cookie 怎么设置有效期？有优先级吗？HttpOnly 是什么含义？
2019.07 隐式转换:{}+{}=?

---

做题记录

```js
// 作业76：显卡的作用？
- 第六遍 2025.3.22 -
将位图合成图像，渲染帧存储入后缓存区 ⭐️ // 后缓冲区
⭐️ // 一旦合成的图像写到后缓冲区，系统就会让前后缓冲区互换
- 第五遍 2025.3.1 -
- 第四遍 2025.2.15 -
- 第三遍 2025.2.10 -
- 第二遍 2025.2.2 -
```

```js
// 作业73：react 的 setState 是同步还是异步？为什么React有时候有两次 setState，却只执行一次？
- 第七遍 2025.3.22 -
在合成事件+生命周期函数中，setState 有 批量更新机制，是异步的 - 在事件处理函数中，遇到 setState 时，收集到一个队列，在执行完事件处理函数的逻辑后，批量执行 setState ，然后触发一次更新渲染
在原生事件/setTimeout等函数中 setState 是同步的，调用一次，执行一次，触发一次更新渲染
- 第六遍 2025.3.1 -
- 第五遍 2025.2.15 -
- 第四遍 2025.2.10 -
- 第三遍 2025.2.2 -
❌ // 1、除了合成事件，还有「生命周期函数」中都是异步
```

```js
// 作业59：什么是高阶函数?什么是高阶组件？什么是副作用？简单举例
- 第八遍 2025.3.22 -
高阶函数：参数或者返回值是函数的函数 map sort
高阶组件：参数是组件的组件
副作用：函数式编程的说法，除了返回值，还会影响其他值，例如修改全局变量、参数、IO下载交互等
const a = function(MyC){
    return class extends React.Component{
        constructor(props) {
            super(props);
        }
        render() {
            return <MyC {...this.props} />
        }
    }
}
- 第七遍 2025.3.1 -
- 第六遍 2025.2.15 -
- 第五遍 2025.2.9 -
- 第四遍 2025.2.2 -
⭐️ // 副作用，少写了：除了返回值
```

```js
// 作业55：flex 常见缩写
- 第八遍 2025.3.22 -
flex: none; 0 0 auto
flex: auto; 1 1 auto
flex: initial; 0 1 auto
flex: 1; 1 1 0 
- 第七遍 2025.3.1 -
- 第六遍 2025.2.15 -
- 第五遍 2025.2.9 -
❌ // 1、把 0 0 auto 的缩写写错，应该是 flex: none;
- 第四遍 2025.2.2 -
❌ // 1、少写了一个 flex: initial; // 0 1 auto
```

```js
// 作业74：起舞弄清影 是那首诗？谁写的？下一句是什么？
- 第六遍 2025.3.22 -
苏轼 《水调歌头 明月几时有》
明月几时有，把酒问青天，不知天上宫阙，今夕是何年。
我欲乘风归去，又恐琼楼玉宇，高处不胜寒。
转朱阁，低绮户，照无眠。// ❌ 1、顺序反了，先起舞，后转朱阁
起舞弄清影，何似在人间。
不应有恨，此时长向别时圆。
⭐️ // 少写了：人有悲欢离合，月有阴晴圆缺，此事古难全。
但愿人长久，千里共婵娟。
- 第五遍 2025.3.1 -
// ⭐️ 顺序反了，先不应有很，何事长向别时圆？再人有
// ⭐️ 少写了 但愿人长久，千里共婵娟
- 第四遍 2025.2.15 -
- 第三遍 2025.2.9 -
- 第二遍 2025.2.2 -
```

```js
// 作业25：简单写下 请求创建过程
- 第八遍 2025.3.22 -
function XMLRequest(url){
    const xhr = new XMLHttpRequest();
    xhr.ontimeout = ()=>{};
    xhr.onerror = ()=>{};
    xhr.onreadystatechange = (res) => {
        switch(res.readyState) {
            case 0:
                break;
            case 4:
                if(this.status === 200 || this.status === 304) {
                    return console.log(this.responseText);
                }
        }
    }
    xhr.open('GET', url, true);
    xhr.timeout = 3000;
    xhr.responseType = 'text';
    xhr.setRequestHeader(key, value);
    xhr.send();
}
- 第七遍 2025.3.1 -
- 第六遍 2025.2.15 -
- 第五遍 2025.2.9 -
⭐️ // status 在 this 上
- 第四遍 2025.2.2 -
❌ // 1、函数名称错误：onreadystatechange
❌ // 2、readyState 状态属性不在 this 上，在 res 上：res.readyState
❌ // 3、switch 中 0 表示请求还没开始，要使用 break 跳出循环
❌ // 4、open 的参数顺序记错了：xhr.open('GET', url, true)
```

```js
// 作业6：new操作符实例化一个对象的过程
- 第七遍 2025.3.22 -
function fakeNew() {
    const ctor = [].shift.call(arguments);
	const obj = new Object();
    obj.__proto__ = ctor.prototype;
    const res = ctor.apply(obj, arguments);
    return typeof res === 'object' ? res : obj;
}
- 第六遍 2025.3.16 -
- 第五遍 2025.2.24 -
- 第四遍 2025.2.10 -
- 第三遍 2025.2.9 -
- 第二遍 2025.1.28 -
❌ // 1、实例的 __proto__ 指向的不是构造函数，是构造函数的原型对象 ctor.prototype;
- 第一遍 2025.1.20 -
❌ // 1、不是调整 constructor 的指向，是设置实例的原型 __proto__
```

```js
// 作业92：前端中的序列化是什么？常见序列化方法。反序列化是什么？有哪些方法。写个POST调用流程
- 第七遍 2025.3.22 -
序列化：将对象结构转换成方便存储、传输的格式
	JSON.stringify(data) 转换成 json 格式 ⭐️ // 无法处理 function 和 循环引用
	new FormData(form) 转换成键值对组成的 json
反序列化：响应返回的都是 json 格式，需要转换成 js 格式
JSON.parse(data) response.json()
const options = {
    methods: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(data)/new FormData(form)
}
const data = await fetch('xx', options);
data.then(res => res.json()).then(res => res);
- 第六遍 2025.3.15 -
❌ // 1、POST 的数据在 body 中
❌ // 2、少写了 headers: { 'Content-Type': 'application/json' }
- 第五遍 2025.2.28 -
- 第四遍 2025.2.26 -
- 第三遍 2025.2.19 -
❌ // 1、将「数据结构、对象」转换为可以「存储、传输」的格式的过程
- 第二遍 2025.2.10 -
❌ // 1、new FormData 收集表单数据并序列化，转换成键值对格式
- 第一遍 2025.2.8 -
```

```js
// 作业87：Nextjs 中预渲染是什么？有哪些模式？写一个动态路由的page
- 第十一遍 2025.3.22 -
预渲染：主要由 SSR 服务端渲染 getServerSideProps + SSG 静态生成 generateStaticParams + ISR 增量
⭐️ // NextJS 中所有组件默认为服务端组件，默认实现服务端渲染
静态生成 revalidate
服务端渲染 - 在客户端发起请求时，服务端将 data 获取后，生成 HTML，客户端直接渲染，客户端js 不需要执行
增量静态生成 - 在运行时，根据 revalidate 定时在服务端更新 HTML，方便客户端直接调用 ⭐️ // 增量更新
SSR
import getServerSideProps from 'next/server';
export async function getServerSideProps(){
    const res = await fetch('xxx', options);
    const data = await res.json();
    return {props: {data}}
}
export function Blog({data}){return <div>{data.text}</div>}
SSG
export async function generateStaticParams() {
    return [{slug: 'first'}, {slug: 'second'}]
}
export const revalidate = 60;
export function Blog({slug}){return <div>{slug}</div>}
- 第十遍 2025.3.15 -
❌ // 1、SSG 少写了 generateStaticParams
❌ // 2、SSR 依赖包错了 next/server
❌ // 3、response.json 少写了 await
- 第九遍 2025.3.1 -
- 第八遍 2025.2.26 -
- 第七遍 2025.2.21 -
- 第六遍 2025.2.17 -
- 第五遍 2025.2.12 -
❌ // 1、SSG + SSR：函数 都少写了 async
- 第四遍 2025.2.9 -
❌ // 1、名称错误：服务端渲染SSR、静态生成SSG、增量静态生成ISR + 客户端、服务端生成的结果都是 HTML
- 第三遍 2025.1.31 -       
- 第二遍 2025.1.26 -
- 第一遍 2025.1.22 -
```

```js
// 2021.07 数组扁平化（一层、全部展开、指定深度）
- 第九遍 2025.3.21 -
一层 arr.flat()  [].cancat(...arr) [].cancat.apply([], arr) [].concat.call([], ...arr)
全部展开 arr.toString().split(',') // ❌ 1、少写了 arr.flat(Infinity)
指定深度
function deepArr(arr, deep = 1){
    return arr.reduce(it => it.concat(Array.isArray(it) && deep > 1 ? deepArr(it) : it ))
    // ❌ 2、reduce 的使用方法错了 return arr.reduce((pre, cur) => pre.concat(Array.isArray(cur) && deep > 1 ? deepArr(cur, deep - 1) : cur ), [])
}
- 第八遍 2025.2.28 -
- 第七遍 2025.2.12 -
- 第六遍 2025.2.9 -
- 第五遍 2025.1.31 -
❌ // 1、JSON.parse(JSON.stringify(arr)) 是用于深拷贝的，不能展开
- 第四遍 2025.1.25 -
- 第三遍 2025.1.24 -
❌ // 1、少写了 arr.flat(Infinity)
❌ // 2、全部展开递归函数中，pre 的值不要使用 push 来更新 - concat 既能处理数组，也能处理非数组
- 第二遍 2025.1.19 -
❌ // 1、deep 传递的时候要减一
```

```js
// 2025-03 p-limit 使用+源码 、100个请求并发请求
- 第二遍 2025.3.21 -
import pLimit, { limitFunction } from 'p-limit';
// 方法1
const limit = new pLimit(4);  // ❌ 1、创建限制器不需要 new：limit = pLimit(6)
const arr1 = Array.from({ length: 30 }, (it, index) =>
	limit(() => new Promise((resolve) => setTimeout(resolve, index * 88, index)))
)
Promise.all(arr).then(res => console.log(res))
// 方法2
const arr2 = Array.from({ length: 30 }, (it, index) =>
	limitFunction(() => new Promise((resolve) => setTimeout(resolve, index * 88, index)),
	{ concurrency: 4 })
)
//  源码
function validate(limit) {
    if (!Number.isInteger(limit) || limit < 0) {
        throw new Error('concurrency 无效') ⭐️ // TypeError
    }
}
function pLimit(concurrency) {
    validate(concurrency);
    const queue = [];
    let running = 0;
    const next = () => {
        running--;
        if (queue.length) { ⭐️ // queue.length > 0
            queue.pop()();
        }
    }
    const run = async (resolve, fn, arg) => {
        running++;
        resolve(fn(...arg));
        ❌ /** 2、直接执行不对，需要 await + 应该使用 try-catch
        try{ 
        	const result = await fn(...arg);
        	resolve(result);
        }catch(e){
        	resolve(Promise.reject(e))
        }
        */
        next()
    }
    return (fn, ...arg) => {
        return new Promise((resole) => {
            if (running < concurrency) {
                run(resolve, fn, arg)
            } else {
                queue.push(() => run(resolve, fn, arg))
                ⭐️ // 更优的写法：queue.push(run.bind(null, resolve, fn, arg))
            }
        })
    }
}
function limitFunction(fn, options) {
    const limit = new pLimit(options.concurrency);
    return limit(() => fn)
    ❌ // 3、return 的应该是函数 return (...arg) => limit(() => fn(...arg))
}
// 100个并发请求
const arr = Array.from({ length: 100 }, (it, index) => {
    return () => new Promise((resolve) => setTimeout(resolve, index * 99, index))
    ❌ // 4、return 的不应该是函数，而是直接的 promise
})
async function Co(arr, concurrency) {
    const indexedArr = arr.map((it, index) => ({
        index,
        promise: () => Promise.resolve(it).then(value => ({ key: index, value })) ❌ // 5、不应该是函数，应该是 promise
    }))
    const result = [];
    const queue = indexedArr.splice(0, concurrency);
    while (queue.length) { ❌ // 6、queue.length > 0
        const { key, value } = await Promise.race(queue.map(it => it.promise))
        result[key] = value;
		❌ // 7、解决的 promise 在 queue 里面的 index 需要重新查找：const resolvedIndex = queue.findIndex(it => it.index === key)
        queue.splice(key, 1); ❌ // 8、queue.splice(resolvedIndex, 1)
        queue.push(indexedArr.pop()) ❌ // 9、需要判断 indexedArr 是否还有待处理函数 if(indexedArr.length > 0){ queue.push(indexedArr.pop()) }
    }
    return result
}
- 第一遍 2025.3.14 -
❌ // 1、p-limit 还可以导出一个函数 { limitFunction } 处理
❌ // 2、创建限制器不需要 new：limit = pLimit(6)
❌ /** p-limit 函数实现，而不是类
需要校验传入的 concurrency 是否为正整数
next 执行队列中下一个任务 count-- 一个任务完成则减一
run  执行任务封装 count++ 表示有个新任务开始开始执行*/
```

```js
// 2025-3 NestJS 守卫-校验权限 + 2025-3 NextJS 全局中间件-校验权限
- 第一遍 2025.3.20 -
权限校验
Nest - 守卫
function MyAuth(ctx) { ❌ // 1、不拆分处理 且 不等于的时候需要 throw new UnauthorizedException
    const header = ctx.request.header;
    const auth = header.get('auth')
    if(auth !== 'xxx'){
        return false;
    }
    return true;
}
@Injectable() ❌ // 2、少写了()：装饰器需要执行
export class MyAuth implements CanActivate { ❌ // 3、少写了 class 声明
    canactivate(config){ ❌ // 4、canactivate 的参数是 ctx；config 这边应该是 Nest 中间件 - 配置时，控制器中 ...implements NestModule{ configure(consumer){consumer.apply().forRoutes()} }
        config.apply(类/实例).forRoutes('cats') ;
		❌ // 5、从 context 中获取 request：const request = ctx.switchToHttp().getRequest()
        ❌ // 6、再从 request 中获取 headers：const headers = request.headers;
        ❌ // 7、if(headers.auth !== 'xxx'){ throw new UnauthorizedException('x') }
    }
}
使用 @useGuard(MyAuth) ❌ // 8、useGuards 少了个 s

Next - 全局中间件 ❌ // 1、middleware.ts 放在 app 同层级下面，src/middleware.ts
❌ // 2、路由配置器 export const config = { matcher: '/api/:path*' }
export function MyAuth(request: NextRequest, next) { ❌ // 3、少写了 export 且参数没有 next
    const header = request.switchHttp().getRequest().header;
    const auth = header.get('auth');
	❌ // 4、headers 获取的方式：NextRequest 已经封装好了 const headers = request.headers
    ❌ // 5、变量的获取方式 const auth = headers.get('Auth')
    if(auth !== 'xxx'){
        return NextResponse.josn({status: 500, error: 'wrong auth'}); ⭐️ // 401
    }
    next(); ❌ // 6、next 调用 NextResponse.next()
}
```

```js
// 2024-11 数组乱序 洗牌算法 从最后一个元素开始，从数组中随机选出一个位置，交换，直到第一个元素。
- 第三遍 2025.3.20 -
function shuffle(arr) {
    let lastIndex = arr.length - 1;
    while(lastIndex >= 0) {
        const random = Math.random() * arr.length; ❌ // 1、少处理成整数 Math.floor
        [arr[random], arr[lastIndex]] = [arr[lastIndex], arr[random]];
        lastIndex--;
    }
    return arr
}
- 第二遍 2025.2.20 -
- 第一遍 2024.12.25 -
```

```js
// 2021-04 实现给定时间切换状态
- 第二遍 2025.3.20 -
async function time(promise, delay) {
    return await Promise.race([promise, 
                               new Promise((resolve, reject) => setTimeout(reject, dealy, new Error('超时')))])
}
- 第一遍 2025.2.20 -
```

```js
// 2021-07 给DOM元素绑定事件
- 第二遍 2025.3.20 - 
HTML 标签 onlick ❌ // 1、少写了 onclick 属性值为可执行代码而不是函数 onlick='init()'
事件委托 dom.addEventlistener('click', (e) => {console.log(e)})
❌ // 2、少写了两者差异：事件委托可以给同一个元素添加多个事件；onclick 一个元素只能添加一个事件
- 第一遍 2025.2.20 -
```

```js
// 2025.02 Express VS KOA2
- 第三遍 2025.3.20 -
Express 
	设计理念：主要是回调函数实现异步，后已支持异步promise async/await；框架功能完整，开箱即用
    中间件：线性模型，通过 next 线性执行中间件
    错误处理：res.json()/res.send()
    app.use((err, req, res, next)=>{ 
    	res.end({status: 500, message: err})
        ❌ // 1、res.status(500).send(err)
    })
    上下文：req res ❌ // 2、res.json/res.send 都是基于底层的 Node 的 Response.end 封装的
KOA2
	设计理念：基于 async/await 实现，适合复杂异步场景；代码简单、灵活、性能好
    中间件：洋葱模型，先入栈依次执行，再出栈依次执行
    错误处理：app.use(async(ctx, next) => { 
    	try{await next()}catch(e){ ctx.status = 500; ctx.body = {message: e} }
    })
    上下文：context 封装了 req res ❌ // 3、ctx.body 来设置响应体
- 第二遍 2025.3.13 -
❌ // 1、错误处理方式: Express - app.use((err,req,res,next)=>{res.status(500).send('err')})
	  // 错误处理方式: KOA2 try-catch 结合中间件实现
❌ // 2、上下文：Express res.send()/res.json() 都是基于 Node 底层 Response 的 res.end 的封装
- 第一遍 2025.3.5 -
```

```js
// 2025-02 KOA2 中间件机制实现、路由处理、错误处理、模版引擎、源码
- 第三遍 2025.3.20 -
中间件机制实现：洋葱模型，先入栈-执行最里层的中间件-再依次出栈
function compose2(middlewares) {
    return (ctx, next) => {
        let index = -1;
        return dispatch(0);
        function dispatch(i) {
            if (i <= index) { return Promise.reject('multiple times') }
            ⭐️ // 少写了 index = i
            let fn = middlewares[i];
            if (!fn) { return Promise.resolve() }
            if (i === middlewares.length) { fn = next }
            try {
                const nextFunc = () => dispatch(i + 1);
                return Promise.resolve(fn(ctx, nextFunc))
            } catch (e) { Promise.reject(e) }
        }
    }
}
路由处理: KOA2 没有内置路由模块，使用 koa-router 实现 router.get('/cat', async (ctx) => {})
错误处理: app.use(async(ctx, next) => { 
    try{ await next() } catch(e) { ctx.status = 500; ctx.body = { message: 'err' } }
})
模版引擎:
ejs模版引擎 {{}} <% for %>，适合复杂模版，性能没那么好，需要编译再执行 js
art-template模版引擎 {}，代码简洁，有预编译，性能好，可以直接执行 js
源码
import http from 'http'
class KOA2 {
    constructor() {
        this.middlewares = [];
    }
    listen(...arg) {
        const server = http.createServer(this.callback());
        return server.listen(...arg)
    }
    use(fn) { this.middlewares.push(fn) } ⭐️ // 少写了 return this
    callback() {
        const fnCompose = compose(this.middlewares);
        return (req, res) => {
            const context = createContext(req, res); ⭐️ // 应该是 this.createContext 调用
            return fnCompose(context).then(() => response(context)).catch(e => ctx.onerror(e))
        }
    }
    createContext(req, res) {
        const ctx = Object.create(this.context);
        ctx.request = Object.create(this.request);
        ctx.response = Object.create(this.response);
        ctx.req = ctx.request.req = req;
        ctx.res = ctx.response.res = res;
        return ctx
    }
}
function response(ctx) {
    ctx.res.statusCode = ctx.status;
    ctx.res.end(ctx.body)
}
- 第二遍 2025.3.13 -
❌ // 1、index 初始值设置为 -1，否则 0 就相等抛出重复错误了
❌ // 2、执行中间件时，ctx 和 nextFunc 作为参数传入
❌ // 3、处理错误时，改变 ctx.status 和 ctx.body
❌ // 4、callback 执行中 少写了 return + catch 错误处理使用 ctx.onerror
❌ // 5、statusCode 是在原生 Reponse 上 ctx.res.statusCode
- 第一遍 2025.3.5 -
❌ // 1、KOA2 是基于 NodeJS 的 HTTP 中间件框架
❌ // 2、中间件写法：应该是 async 函数，async (ctx, next)=>{ await next() }
❌ // 3、如果重复执行，直接返回 Promise.reject(new Error('dup'))
❌ // 4、少写了 fn 不存在时，return Promise.resolve()
❌ // 5、KOA2 路由参数 ctx.params + 链接参数 ctx.query
```

```js
// 2025.02 nextTick 原理，在Vue2、Vue3中分别是什么步骤实现的，简单模拟实现流程
- 第五遍 2025.3.20 -
原理：vue的数据更新后，DOM 是异步更新的，nextTick 提供了更新真实 DOM 后的执行时机 ⭐️ // 在下一个事件循环时，批量更新 DOM
Vue2 收集回调函数 - 根据环境模拟实现异步 - 执行；没有传入回调时，默认返回一个 resolve 状态 promise
vue3 收集 - 使用 queueMicrotask 模拟实现 - 执行；始终返回 promise
const callbacks2 = [];
let pending22 = false;
function flushJobs() {
    pending22 = true;
    const copy = [...callbacks2];
    copy.forEach(it => it());
    callbacks2.length = 0;
    pending22 = false
}
let timeFunc22;
if (typeof Promise !== 'undefined') {
    timeFunc22 = () => Promise.resolve().then(flushJobs)
} else if (typeof MutationObserver !== 'undefined') {
    const ob = new MutationObserver(flushJobs);
    const dom = document.createTextNode('1');
    ob.observe(dom, { characterData: true });
    timeFunc22 = () => dom.data = '2';
} else if (typeof setImmediate !== 'undefined') {
    timeFunc22 = () => setImmediate(flushJobs);
} else {
    timeFunc22 = () => setTimeout(flushJobs, 0)
}

function vue2NextTick(cb, thisArg) {
    if (!cb) { return Promise.resolve() }
    callbacks2.push(() => {
        try { cb.apply(thisArg) } catch (e) { console.log(e) }
    })
    if (!pending) { timeFunc22() }
}
new Vue({
    data() { return { msg: '1' } },
    mounted() { this.$Vue2nextTick(() => { }) }
})

function flushJobs3() {
    pending22 = true;
    let job;
    while ((job = callbacks2.shift())) {
        job();
    }
    pending22 = false;
}
const timeFunc3 = () => { queueMicrotask(flushJobs3) }
function vue3NextTick(cb) {
    return new Promise((resolve, reject) => {
        if (!cb) { resolve() }
        callbacks2.push(() => {
            try {
                cb();
                resolve()
            } catch (e) { reject(e) } ⭐️ // 不返回 reject，nextTick 返回 promise 是为了递归
        })
        if (!pending22) { timeFunc3() }
    })
}
import { nextTick, createApp } from 'vue';
const app3 = createApp({
    data() { return { msg: '1' } },
    mounted() { nextTick(() => { }) }
})
app3.mount('#root') ⭐️ // #app
- 第四遍 2025.3.13 -
❌ // 1、Vue3：nextTick 返回 resolved 状态的 Promise
❌ // 2、Vue3：有 err 时，console 处理；resolve 放在 try-catch 外面 - 只要 cb 执行了，就 resolve
- 第三遍 2025.3.3 -
❌ // 1、vue2 timeFunc 应该包裹成回调函数，否则赋值时就直接执行了 timeFunc = ()=>p.then(..)
❌ // 2、vue2 节点创建函数错误 createTextNode + characterData +  .data='2'
❌ // 3、vue2 nextTick 有第二个参数 ctx -> 指定 cb 的上下文 
❌ // 5、vue3 中，回调函数需要把当前的 Promise 状态切换为 resolved
- 第二遍 2025.2.27 -
❌ // 1、vue2 执行所有回调函数中少写了：清空原数组，避免重复执行回调 callbacks.length=0
❌ // 2、vue2 根据环境判断，有 Promise 时 Promise.resolve().then 少写了执行()
❌ // 3、收集回调函数时，需要处理报错的情况 try-catch
- 第一遍 2025.2.24 -
❌ // 1、Vue3：和Vue差异是，使用 queueMicrotask 统一处理微任务
```

```js
// 2024.12 模拟实现promise
- 第八遍 2025.3.20 -
const S7 = {
    pending: 'pending',
    resolved: 'fulfilled',
    rejected: 'rejected'
}
function MyPromise7(executor) {
    this.status = S7.pending;
    this.value = null;
    this.reason = null;
    this.resolvedCbs = [];
    this.rejectedCbs = [];
    const resolve = (value) => {
        if (this.status === S7.pending) {
            this.status = S7.resolved;
            this.value = value;
            this.resolvedCbs.forEach(it => it(value))
        }
    }
    const reject = (reason) => {
        if (this.status === S7.pending) {
            this.status = S7.rejected;
            this.reason = reason;
            this.rejectedCbs.forEach(it => it(reason))
        }
    }
    try {
        executor(resolve, reject);
    } catch (e) {
        reject(e);
    }
}
MyPromise7.prototype.then = function (onResolved, onRejected) {
    ⭐️ // 少写了对 onResolved, onRejected 校验为函数类型
    return new MyPromise7((resolve, reject) => {
        const resolveFunc = () => {
            setTimeout(() => {
                try {
                    const res = onResolved(this.value);
                    resolve(res)
                } catch (e) { reject(e) }
            }, 0);
        }
        const rejectFunc = () => {
            setTimeout(() => {
                try {
                    const res = onRejected(this.reason);
                    resolve(res)
                } catch (e) { reject(e) }
            }, 0);
        }
        switch (this.status) {
            case S7.pending:
                this.resolvedCbs.push(resolveFunc);
                this.rejectedCbs.push(rejectFunc);
                break;
            case S7.resolved:
                this.resolvedCbs.push(resolveFunc());
                break;
            case S7.rejected:
                this.rejectedCbs.push(rejectFunc());
                break;
        }
    })
}
MyPromise7.prototype.catch = function (onRejected) {
    return this.then(null, onRejected);
}
MyPromise7.prototype.finally = function (cb) {
    return this.then(v => { cb(); return v }, r => { cb(); throw r })
}
MyPromise7.resolve = function (value) {
    return new MyPromise((resolve, reject) => {
        if (value instanceof MyPromise7) {
            return value.then(resolve, reject)
        }
        resolve(value);
    })
}
MyPromise7.reject = function (reason) {
    return new MyPromise7((resolve, reject) => reject(reason))
}
MyPromise7.all = function (arr) {
    return new MyPromise7((resolve, reject) => {
        if (!arr.length) { resolve([]); return }
        let count = 0;
        const result = [];
        arr.forEach((it, index) => {
            MyPromise7.resolve(it).then(res => {
                count++;
                result[index] = res;
                if (count === arr.length) {
                    resolve(result)
                }
            }).catch(reject);
        })
    })
}
MyPromise7.race = function (arr) {
    return new MyPromise7((resolve, reject) => {
        arr.forEach(it => it(resolve, reject))
        ⭐️ // 更好的写法 it => MyPromise7.resolve(it).then(resolve).catch(reject);
    })
}
MyPromise7.allSettled = function (arr) {
    return new MyPromise7((resolve) => {
        if (!arr.length) { resolve([]); return; }
        const result = [];
        let count = 0;
        arr.forEach((it, index) => {
            MyPromise7.resolve(it).then(value => {
                result[index] = { status: S7.resolved, value }
            }).catch(reason => {
                result[index] = { status: S7.rejected, reason }
            }).finally(() => {
                count++;
                if (count === arr.length) { resolve(result) }
            })
        })
    })
}
const getErr = info => new AggregateError(info, 'all rejected')
MyPromise7.any = function (arr) {
    return new MyPromise7((resolve, reject) => {
        if (!arr.length) { reject(getErr([])); return; }
        const result = [];
        let count = 0;
        arr.forEach((it, index) => {
            MyPromise7.resolve(it).then(resolve).catch(reason => {
                count++;
                result[index] = reason;
                if (count === arr.length) { reject(getErr(results)) }
            })
        })
    })
}
- 第七遍 2025.3.13 -
// 全部返回，reduce 处理的是同步任务，异步会出现异常
❌ // 1、all 中：arr 为空数组时，forEach 不会执行 if(arr.length===0){resolve([]);return;}
❌ // 2、all 中：不知道是不是所有的 peomise 都返回了，需要一个计数器
- 第六遍 2025.3.5 -
❌ // 1、race 中 it 需要包裹一层 MyPromise.resolve(it).then(resolve, reject)
- 第五遍 2025.2.11 -
- 第四遍 2025.1.20 -
- 第三遍 2025.1.19 -
❌ // 1、模拟 Promise 的时候，一般都是用函数
❌ // 2、onRejected 返回的依旧是 resolve 的 promise
❌ // 3、then：try-catch不能写成 catch(reject)，catch接收的参数是error - catch(e){ reject(e) }
```

```js
// 作业63：React渲染怎么实现的？涉及到哪些生命周期/hooks？以 const [count, setCount]=useState(0)具体说明
- 第九遍 2025.3.20 -
React 运行时编译 JIT 将 JSX 先编译成 AST，再转换成 React.createElement
渲染前： shouldComponentUpdate(nextProps,nextState) / getDerivedStateFromProps
render：
	1 生成 fiberNode tree：创建 FiberRootNode = WIP.current，创建 fiberNode 作为 HostRootFiber ，开始 DFS 深度遍历 React.createElement 生成的 React Element 树，执行 beginwork 根据 wip.tag 对应处理，执行到叶子节点 completeWork ⭐️ // 不是 WIP.current，FiberRootNode 作为根节点，HostRootFiber = FiberRootNode.current
    2 存储所有 hooks 链表 ⭐️ // memorizedState
    3 标记、收集副作用链表 side-effect-list ⭐️ // updateQueue
	4 Diff 增量式计算最小更新 UI
commit：
	将 Diff 计算出的更新应用到真实 DOM + 所有生命周期和副作用链表（componentDidMount componentDidUpdate componentWillUnMount + useLayoutEffect/ref

count 更新时，更新对应 hooks 中的节点值，触发组件更新
- 遍历执行整个 hooks，如果是 useEffect 依赖的一员，收集副作用链表 
- 生成新的 VDOM 之后和真实 DOM 对应的 VDOM 进行计算得到最小更新 UI
- 应用到真实 DOM，再执行生命周期函数和副作用链表
- 第八遍 2025.3.13 -
❌ // 1、少写了第一步：动态编译 JIT - 将 JSX 描述编译为 React createElement 方法
❌ // 2、构建新的 Fiber 树 WIP Tree 过程需要了解
❌ // 3、初次渲染时，存储 hooks、标记收集副作用链表
- 第七遍 2025.3.5 -
❌ // 1、shouldComponentUpdate 在 render 之前被调用，不在 commit 阶段
- 第六遍 2025.2.11 -
- 第五遍 2025.1.23 -
- 第四遍 2025.1.18 -
❌ // 1、遍历执行 hooks 时，如果遇到有副作用的节点，除了被副作用链表收集，react 也会在节点 Node 上标记 fiberNode.subtreeFlags
❌ // 2、count 这里应该将「如果有副作用」改写为「要注意是否有 useEffect 的作用：根据依赖数组是否变化确定是否要更新」
```

```js
// 作业23：写出js 代码的执行顺序。词法作用域的特点是什么？ 
- 第四遍 2025.3.20 -
- 可执行代码 AST
- 执行上下文 - this
		   - 变量环境 var - 函数作用域：先创建arguments，再函数声明提升，再变量声明提升
		   - 词法环境 let/const 只和代码所在位置有关
作用域链：由多个执行上下文的变量环境组成 ⭐️ // 链表
'bye 坑'
"global name"
undefined 'a' 'b' 'err'
- 第三遍 2025.3.13 -
❌ // 1、js 分为【可执行代码】和【执行上下文】，执行上下文分为三个：词法环境、变量环境、this
❌ // 2、变量环境 先创建arguments再函数声明提升最后变量声明提升
- 第二遍 2025.2.24 -
- 第一遍 2025.1.20 -
```

```js
// 2021-06 CSS性能优化
- 第二遍 2025.3.19 -
代码：1 从右向左解析，减少层级
2 使用 link 预解析线程来触发提前下载
3 动画使用合成层tansform opacity、GPU 加速、避免回流重绘、减少高消耗的属性使用 ⭐️ // 减少使用昂贵属性
⭐️ // 减少重排的方式：少改变/访问大小、少增删DOM、少增删样式表、少伪类激活、少style属性
4 code splitting，懒加载，模块化，只加载当前必要代码，减小代码体积
- 第一遍 2025.2.19 -
```

```js
// 2021.04 12 垃圾回收机制
- 第四遍 2025.3.19 -
❌ // 1、少写了栈的清空方式：移动指针，将不需要的数据所在的内存，在后续使用中覆盖
// ⭐️ 堆
v8引擎 根据代际假说，分为新生代和老生代
新生代 - 存活生命周期短，占用内存空间小，清理频繁 - 副垃圾回收机制
	分成两块，活动区和副区，在活动区存储快满时，将仍旧有效的变量依次排序复制到副区，复制完后交换两个区（不产生内存碎片）// ⭐️ 对象区域、空闲区域
    如果清理两次还存活，则升级为老生代
老生代 - 占用空间大，主垃圾回收机制
	标记-清除，产生内存碎片，清理过程最后还要向左移动所有变量来处理
- 第三遍 2025.3.5 -
- 第二遍 2025.2.27 -
❌ // 1、新生代 清理过程：先标记，再有序地复制到空闲区 - 复制完后翻转两个区域
- 第一遍 2025.2.24 -
❌ // 2、少写了：v8 引擎 基于代际假说
❌ // 3、少写了老生代：标记-清理，产生大量不连续的内存碎片
```

```js
// 2021.05 27 HTTP/3 改进的点
- 第四遍 2025.3.19 -
HTTP/3 使用 QUIC 协议，将 TCP 改用为 UDP，彻底解决 TCP 在传输层因为丢包重传机制导致的队头阻塞
// ⭐️ UDP 无连接，TCP三次握手四次挥手，节省时间
- 第三遍 2025.3.3 -
- 第二遍 2025.2.27 -
❌ /** 1、详细比较对比
HTTP/3（应用层）			 HTTP/1.1 或 HTTP/2.0（应用层）  		 HTTP（应用层）
|						|									|
QUIC（传输层，基于 UDP）   									   TLS（安全层）
|						|									|
UDP（传输层）			 TCP（传输层）						  TCP（传输层）
|						|									|
IP（网络层）				 IP（网络层）						  IP（网络层）
|						|									|
数据链路层				 数据链路层							  数据链路层
|						|									|
物理层					  物理层								 物理层
**/
- 第一遍 2025.2.24 -
❌ // 1、少写了 HTTP/2.0 存在的问题：HTTP/2.0 并没有完全解决队头阻塞，传输层的 TCP 有丢包重传机制 - TCP 为了保证可靠的传输，丢包必须等待重新传输确认，其他的包即使收到了也只能放在缓冲区，上层应用拿不出来，被丢的包不回来，大家都取不出来
❌ // 2、少写了：HTTP/3.0 UDP 无连接，HTTP/2.0 TCP 三次握手、四次挥手
```

```js
// 2021.07 babel  作用+原理+补丁
- 第四遍 2025.3.19 -
babel 将 ES6 代码转译为 ES5 代码，方便浏览器 js 引擎执行使用 // ⭐️ 使开发者便捷开发
原理：@babel/parse 将 ES6 代码处理为 ES6 的 AST // ⭐️ 词法分析 语法分析 parser
	 @babel/tranverse 将 ES6 AST 处理为 ES5 AST
	 @babel/generate 将  ES5 AST 处理为 ES5 js 代码 // ⭐️ generateor
补丁：babal 只能处理原始 ES6 语法，例如箭头函数，特殊语法都要补丁实现转换 Promise async/await Iterator Symbol // ⭐️ Generator Set Map Proxy Reflect Object.assign
- 第三遍 2025.3.3 -
- 第二遍 2025.2.27 -
// ⭐️ Set Map Proxy Reflect Object.assign - @babel/polyfill
- 第一遍 2025.2.24 -
❌ // 1、原理：少写了解析过程：解析Parsing[词法分析+语法分析得到AST]-转换Transformation[遍历AST转换 ES6的AST转换成ES5的AST]-生成Code Generation[根据转换后的AST转换成ES5 js代码]
❌ // 2、不能转换的ES6语法：Iterator Generator Set Map Proxy Reflect Symbol 等全局对象 + Object.assign 全局对象上的方法；@babel/polyfill
```

```js
// 2023-09 二叉树：前中后序、层序遍历-递归/非递归版本、层序遍历、路径和
- 第一遍 2025.3.19 -
递归版本 - 前序遍历，遍历顺序:中-左-右
function preC(head){ 
    ❌ // 1、缺少退出条件 if(!root){ return [] }
    return [head.value, ...preC(head.left), ...preC(head.right)] 
}
递归版本 - 中序遍历，遍历顺序:左-中-右
function inC(head) { 
    ❌ // 2、缺少退出条件 if(!root){ return [] }
    return [...preC(head.left), head.value, ...preC(head.right)] 
}
递归版本 - 后序遍历，遍历顺序:左-右-中
function post(head){
    ❌ // 3、缺少退出条件 if(!root){ return [] }
    return [...preC(head.left), ...preC(head.right), head.value] 
}
非递归版本 - 前序遍历
function preC(head){
    ❌ // 4、缺少边界条件 if(!root){ return [] }
    const stack = [head];
    const result = [];
    while(stack.length){
        const current = stack.pop();
        result.push(current.value);
        if(current.right){ stack.push(current.right); }
        if(current.left) { stack.push(current.left);  }
    }
    return result;
}
非递归版本 - 中序遍历
function inC(head) {
    const stack = [head]; // ❌ 逻辑问题 1：stack 应该初始为 []，配合 current，在循环里面添加首项
    const result = [];
    const current = head; // ❌ 应该是用 let 而不是 const
    while(stack.length){ // ❌ 逻辑问题 2：current 存储根节点/右节点，stack 可能会空 - 条件改为：stack.length || current
        while(current) {
            // ❌ 逻辑问题 3：在循环里面 push current，所以不需要判断 current.left 是否存在
            if(current.left) {
                stack.push(current.left); // ❌ 改为 push current
                current = current.left;
            }
        }
        current = stack.pop();
        result.push(current.value);
        if(current.right){ stack.push(current.right); } // ❌ current = current.right
        // ❌ 逻辑问题 4：使用 current 来存储下一个要推入 stack 的右节点，而不是直接推入
    }
    return result;
}
非递归版本 - 后序遍历
function postC(head){
    ❌ // 5、缺少边界条件 if(!root){ return [] }
    const stack = [head];
    const result = [];
    while(stack.length){
        const current = stack.pop();
        result.push(current.value);
        if(current.left) { stack.push(current.left);  }
        if(current.right){ stack.push(current.right); }
    }
    return result.reverse();
    // ⭐️ 可以优化为在 result 存储值时使用 unshift 添加 + 返回 result 即可
}
层序遍历
1 从上至下，从左到右
2 左视图
1 从上至下，从左到右 - 递归版本
function list(head, layer = 0, res = []) {
    if(!head) { return [] }
    if(!res[layer]) {
        res[layer] = [];
    }
    res[layer].push(head)
    
    layer++;
    [...list(head.left, layer, res), ...list(head.right, layer, res)];
    ❌ // 1、这里的写法很怪异，目的是触发 list 调用即可，合并为： list(head.left, layer + 1, res); list(head.right, layer + 1, res)
    return res
}
/** ⭐️  
function levelOrder(head) {
	const result = [];
	if(root) { FindLayer(root, result, 0) }
	return result;
	
	function FindLayer(node, layer, res) {
		if(!Array.isArray(res[layer])) {
			res[layer] = [];
		}
		res[layer].push(node.value);
		layer++;
		if(node.left) { FindLayer(node.left,  layer, res) }
		if(node.right){ FindLayer(node.right, layer, res) }
	}
}
*/
1 从上至下，从左到右 - 非递归版本 - BFS 广度优先 队列实现
❌ // 1、想不出来
function list(head) {
    if(!head) { return [] }
    const queue = [head];
    const result = [];
    while(queue.length) { // 队列长度
        const size = queue.length;
        const current = [];
        for(let i = 0; i < size; i++) { // 队列长度限制
            const node = queue.shift();
            current.push(node.value);
            if(node.left) { queue.push(node.left) }
            if(node.right){ queue.push(node.right) }
        }
        result.push(current)
    }
    return result
}
2 左视图
function leftView(head) {
    if(!head) { return [] }
    const queue = [head];
    const result = [];
    while(queue.length) {
        const size = queue.length;
        const current = [];
        for(let i = 0; i < size; i++) {
            const node = queue.shift();
            current.push(node.value);
            ⭐️ // 1、在 for 循环中 current.push(node.value) + 在完成一个循环后，投入返回结果中 result.push(current[0]) -> 可以简单改写为 if(i===0){ result.push(node.value) }
            if(node.left) { queue.push(node.left)}
            if(node.right) {queue.push(node.right)}
        }
        result.push(current[0])
    }
    return result
}
路径和
function findPath(head, target){
    const result = [];
	const queue = [head];
    let rest = target;
    while(queue.length){
        const current = [];
        const size = queue.length;
        for(let i = 0; i < size; i++) {
            const node = queue.shift();
            current.push(node.value);
            rest = rest - node.value;
        }
        
    }
}
function findPath(head, target) {
    const result = [];
    function backTrack(node, target, path) {
        if(!node) return;
        path.push(node.value);
        if(!node.left && !node.right && target === node.value) {
            result.push([...path])
        }
        backTrack(node.left, target - node.value, path);
        backTrack(node.left, target - node.value, path);
        path.pop();
    }
    backTrack(head, target, []);
    return result;
}
```

```js
// 2025-03 服务器 不明文密码处理
- 第二遍 2025.3.19 -
在服务器中配置文件 config.env
在项目中通过插件访问到该配置文件 - 由于当前项目在 docker 容器中启动
npm i dotenv
// ⭐️ dotenv 是零依赖的 Node 模块，主要作用是将环境变量从 .env 加载到 process.env 中
import dotenv from 'dotenv'
dotenv.config(path.resolve(_dirname, './config')) ❌ // 1、config 配置的参数接收 path 属性 dotenv.config({ path: path.resolve(_dirname, './config') })
const KEY = process.env.KEY;
在 docker-compose.yml 中将外部文件引入容器
volumns:
	- ../config.env:/app/config.env
- 第一遍 2025.3.11 -
❌ // 1、yml 配置的路径应该是 ../config.env 从项目外引入挂载到指定路径 + 文件名是 docker-compose.yml + volumes 卷，单词错了
❌ // 2、dotenv 配置时，传入具体的地址 path.resolve(__dirname, '../config.env')
```

```js
// 2021.06 flex布局
- 第五遍 2025.3.19 -
1 便捷布局 flex-direction:column/row/column-reverse/row-reverse
主轴默认可缩小，不可放大 justify-content:space-around[-a--b--c-] space-between[a--b--c]
交叉轴默认可放大拉伸 align-iterms: stretch
2 flex: flex-grow正整数是对flex-basis的倍数 flex-shrink flex-basis
3 flex 会让 float clear vertical 失效
4 独立容器 从上到下，垂直排列 不和外部浮动元素重叠 计算高度时包含浮动元素
5 order align-self可以覆盖排列方式 // ⭐️ 允许单个项目与其他不一样的对齐方式
- 第四遍 2025.3.11 -
❌ // 1、少写了 flex flex-grow（基于basis的整数倍） flex-shrink flex-basis
- 第三遍 2025.3.2 -
// ❌ 1、flex-direction 中的值 row/column 没有 s
// ❌ 2、主轴默认不拉伸，但默认缩小
- 第二遍 2025.2.27 -
❌ // 1、少写了 flex 导致 float clear vertical-align 失效
- 第一遍 2025.2.23 -
```

```js
// 作业86：Nextjs 中 Link 的变更是哪个版本开始的，有什么变更？从这个版本开始对路由有什么变更？
- 第六遍 2025.3.18 -
13.x Link 之前内部写 a 标签，之后 Nextjs 直接解析为 a 标签，所以直接写 href 属性
路由文件系统 从 pages/index.js 改为 src/app/page.tsx + layout.ts + global.css ❌ // 1、公共布局文件的路径记错了 src/app/layout.ts + src/app/global.css
和 src/app/api 作为后端路由
- 第五遍 2025.3.13 -
❌ // 1、少写了：由之前的 pages/index.js 改为 src/app/page.tsx ，并支持共享布局 layout.tsx；从 pages/api 改为 src/app/api 
- 第四遍 2025.2.16 -
- 第三遍 2025.1.31 -
- 第二遍 2025.1.26 -
- 第一遍 2025.1.22 -
❌ // 1、只写了「文件路由系统」的变更，还少写了「后端路由系统」的变更 从 pages/api 变更为 src/app/api
```

```js
// 作业84：path.join()和path.resolve()的区别？process.cwd()和__dirname的区别？
- 第六遍 2025.3.18 -
path.join() 拼接两个路径
path.resolve() 解析为绝对路径，/ 为根目录
process.cwd() node 执行环境的当前上下文
__dirname 文件所在的目录路径 // ⭐️ 每个模块的内部变量
- 第五遍 2025.3.13 -
❌ // 1、path.resolve 解析得到绝对路径，把 / 当做根目录
❌ // 2、__dirname 当前模块的目录名
- 第四遍 2025.2.16 -
- 第二遍 2025.1.29 -
- 第二遍 1.26 -
- 第一遍 2025.1.22 -
❌ // 2、process.cwd()：node 执行时所在目录
```

```js
// 作业82：写一个复杂的 SQL： ①只返回某列不同的值，相同的忽略 ②拼接A列和B列为字符串后输出 ③将某一列转换为大写输出 ④计算某列行数，一个包含null的个数，一个不包含null个数 ⑤求和、求最大、求最小、求平均某列的值 ⑥给表起别名 ⑦查询条件涵盖 id为1,同时price大于10，或者是NULL，或者是 5-10之间，或者是 1或2，或者年份为2025 ⑧按照某列分组 ⑨按照某列排序(降序)
- 第六遍 2025.3.18 -
SELECT DISTINCT t.num,
    CONCAT('()', t.name, t.age, ')') as name,
	UPPER(t.age) as age,
    COUNT(t.sex) as without_null,
    COUNT(*) as with_null,
	MAX(t.age) as max,
    MIN(t.age) as age,
    SUM(t.age) as sum,
    AVG(t.age) as avg,
FROM routine as r, time as t
WHERE t.id = 1 OR ❌ // 1、没有使用 AND 和 ()
    t.price > 10 OR
    t.price IS NULL OR
    t.price BETWEEN 5 AND 10 OR
    t.price IN (1,2) OR
    YEAR(t.age) = 2025
GROUP BY t.name
SORT BY t.age DESC ❌ // 2、不是 sort 是 ORDER BY ..
- 第五遍 2025.3.11 -
❌ // 1、IN 后面要接小括号 (1, 2)
- 第四遍 2025.2.16 -
- 第三遍 2025.1.30 -
- 第二遍 2025.1.26 -
- 第一遍 2025.1.23 -
```

```js
// 作业80：对DOM 树的理解 - 定义和作用
- 第六遍 2025.3.18 -
DOM 树是 HTML 的映射，表示 HTMl 的结构 // ⭐️ 对象化表示，是树形结构的对象模型
浏览器 DOM树是浏览器渲染页面结构的基础 // ⭐️ 构建页面布局
js 中 DOM 树 是 js 可以操作、访问 HTML 的接口 ⭐️ // 编程接口
框架 VDOM 可以计算最小更新 UI 量，提高 Diff 增量式效率
- 第五遍 2025.3.11 -
❌ // 1、少写了：DOM 是树形结构的对象模型
❌ // 2、少写了：按照 DOM 结构构建「页面布局」
❌ // 3、是更新而不是渲染：提高页面更新性能
- 第四遍 2025.2.16 -
- 第三遍 2025.1.31 -
❌ // 1、少写了浏览器视角-渲染页面的依据 和 框架视角-VDOM Diff 计算提高更新性能
- 第二遍 2025.1.25 -
- 第一遍 2025.1.24 -
```

```js
// 2021.07 防抖节流
- 第七遍 2025.3.18 -
function debounce(fn, delay) {
    let timeId;
    return (...arg) => {
        if(timeId) {
            clearTimeout(timeId)
        }
        timeId = setTimeout(() => {
            fn(...arg)
        }, delay)
    }
}
function throttle(fn, delay) {
    let flag = false;
    return (...arg) => {
        if(flag) {
            return
        }
        flag = true;
        fn(...arg);
        setTimeout(() => { flag = false }, delay)
    }
}
- 第六遍 2025.3.11 -
❌ // 1、防抖：timeId 已存在，则清理定时器，保证不停读条，覆盖上一次 clearTimeout(time)
❌ // 2、正在触发时，不执行 if(flag)
- 第五遍 2025.2.23 -
- 第四遍 2025.2.18 -
- 第三遍 2025.2.16 -
❌ // 1、debounce 遗漏赋值：timeId = setTimeout()
❌ // 2、throttle：判断条件应该是 if(flag)：flag 为 true 时，证明这段时间内已经执行了
- 第二遍 2025.1.21 -
```

```js
// 2021.09 Object属性排序、与Map的区别
- 第七遍 2025.3.18 -
排序: 正整数>字符串>负数>浮点数>Symbol
区别：有序存储；键可以是任意值；可迭代对象；map.size()；大量数据时map空间小， 增删快
- 第六遍 2025.3.11 -
❌ // 1、浮点数和负数顺序反了：浮点数在后
❌ // 2、少写了键：Map 的键可以是任意值，Object 只有字符串和Symbol
- 第五遍 2025.2.16 -
- 第四遍 2025.1.28 -
- 第三遍 2025.1.25 -
- 第二遍 2025.1.21 -
❌ // 1、少写了浮点数
```

```js
// 作业20：浏览器打开一个 URL 发生了什么
- 第七遍 2025.3.18 -
1 浏览器进程 UI线程 - 将用户输入转换成 查询链接/完整url
2 通过 IPC机制 传递给网络进程 查询本地缓存 - 有缓存且有效，强制缓存生效
3 无缓存，有缓存但失效 ① 解析 DNS 得到 ip
② TCP 排队，三次握手，建立连接
③ 组装请求头、cookie 信息 // ⭐️ 组装HTTP请求
④ 发起请求 301/302-重定向，Location 304-协商缓存生效，使用本地缓存并刷新有效时间
		  200 stream流 下载，停止导航；html 类型 通过管道连接 渲染进程
4 通过管道连接渲染进程，变下载边解析
传输完成后，触发浏览器的 前进/后退、url、页面、安全锁
下载完成，解析还没完成时，触发解析白屏
渲染进程-主线程、合成线程、预解析线程，在预解析线程中提前下载 js css 等资源
主线程：解析DOM(DOM树)-样式计算(CSSOM)-布局(布局树)-分层(分层树)-绘制(指令列表)-
合成线程：-栅格化(图块转换成位图) GPU进程加速-
浏览器 UI线程： 合成(帧)
- 第六遍 2025.3.11 -
❌ // 1、先 TCP 排队，再组装 HTTP 请求
❌ // 2、传输完成后触发更新页面，而不是下载后
❌ // 3、渲染流程中，布局阶段后，不是合成阶段，是分层 得到分层树
- 第五遍 2025.2.16 -
- 第四遍 2025.1.28 -
- 第三遍 2025.1.25 -
- 第二遍 2025.1.20 -
❌ // 1、协议名错了：IPC - 进程通信协议
❌ // 2、少写了：有缓存但缓存失效
❌ // 3、应该是先判断状态码，200的状态码下再判断类型
❌ // 4、少写了 304，使用本地缓存，并刷新缓存有效时间
```

```js
// 2025-03 TCP 滑动窗口 VS TCP 排队
- 第一遍 2025.3.17 -
TCP 滑动窗口: 
	传输层，只影响单个 TCP 的发送速率
    根据接收方的窗口大小，动态调整发送方的请求发送速率
    保证最大程度使用接收方的处理能力，但不会因为请求量过大导致影响处理 ❌ // 1、少写了：实现流量控制
TCP 排队:
	影响应用层，是浏览器限制同个域名并发请求的数量
    优化 HTTP/1.1 请求应答模式导致的队头阻塞
    保护服务端能够安全处理请求响应，避免请求量过大服务器处理不了
```

```js
// 2025-03 js执行优先级 + 测试题
- 第一遍 2025.3.17 -
js执行优先级：()小括号>new Foo()>.属性名调用>()函数执行
❌ // 1、排序 ()小括号>.属性名调用>new Foo无参数>函数执行()>new Foo()有参数
var a = new Foo.getName();  
顺序：new (Foo.getName)() - new 函数() - 打印3，a = {}
var b = new Foo().getName(); 
顺序：(new Foo()).getName() - (实例.getName)() - 打印2，只是执行函数，b = undefined
var c = new new Foo().getName(); 
顺序：new (new Foo()).getName() - new (实例.getName)() - 打印2，c = {}
```

```js
// 2025-03 浏览器前端性能优化RAIL
- 第一遍 2025.3.17 -
Response：响应 300ms 内 ❌ // 1、100ms 内响应交互
Animation：动画 css动画、合成线程 GPU 加速、避免回流重绘、requestAnimationCallback 重绘时间、60帧/秒不卡顿 ❌ // 2、重绘时间函数名称错误 requestAnimationFrame
Idle：休闲时间 requestIdleCallback 在空闲时间执行，数据计算等 // ⭐️ 预加载数据、加载非关键资源
Load：FCP 1s内加载完成，白屏优化 ❌ // 3、3秒内
```

```js
// 2022-10 TS 泛型函数/泛型接口/泛型约束、特性、type/keyof/enum/as/Partial
- 第一遍 2025.3.17 -
泛型函数 function <T, R>(a:T, b:R):[T, R] { return [a, b] }
❌ // 1、少写了函数名称：function getCode<T, R>(a:T, b:R):[T, R] { return [a, b] }
泛型接口 interface <T>MyCode{ value:T, function func(v:T):T[] {return [v]} }
❌ // 2、泛型写在名称后面 interface MyCode<T>{ value:T, function func(v:T):T[] {return [v]} }
泛型约束 interface <T extends {name: string}>MyCode{ v: T }
❌ // 3、泛型写在名称后面 function getCode<T extends {v:number}>(a:T):T {return a}
TS 特性：①面向接口编程 ②编译就是去除类型校验代码，保留功能代码
enum 声明一组常量 enum C {a=1,b=2}
type 类型别名 type Code = string | number / Partial<C>  将属性变为可选
keyof 获取类型接口的属性作为联合类型校验 keyof C = "a" | "b"
as 强制类型转换 // ⭐️ 类型断言
```

```js
// 2025.02 docker-compose 的配置管理 context 
- 第三遍 2025.3.17 -
context 配置 docker 构建上下文
在 dockerfile 执行 docker 启动时，COPY MOVE 会根据配置的根目录来处理 ❌ // 1、没有 move 指令，是 ADD 指令（可以解析tar文件
- 第二遍 2025.3.10 -
// ❌ 1、指定构建上下文路径
// ❌ 2、dockerfile + COPY ADD
- 第一遍 2025.2.28 -
```

```js
// 2025.02 TS - dayjs 引入但失效问题
- 第三遍 2025.3.17 -
dayjs 是 CommonJS模块，但现代框架使用 ES6
在 tsconfig.ts 中配置 
esModuleInterop: true - 将 CommonJS 和 ES6 转换
allowSyntheticImportDefault: true - 解决 CommonJS 没有默认导出的问题 ❌ // 1、allowSyntheticDefaultImports 属性名称错误 - 记忆法：允许异步默认导入s
- 第二遍 2025.3.10 -
- 第一遍 2025.2.28 -
```

```js
// 2021-04 01 浏览器进程组成 + 复用渲染进程 + 进程/线程
- 第一遍 2025.3.17 -
浏览器：浏览器进程x1 渲染进程xn 插件进程xn 网络进程x1 GPU进程x1
复用渲染进程：相同站点复用进程，同协议、同域名、同端口
进程：①有独立的资源空间 ②是程序的实例 ③ 多个进程间独立，通讯：IPC协议、管道、消息队列等
线程：①没有资源，多个线程共享同一进程的数据 ②是进程的一个实体 ③ 线程间数据共享，但是有同步限制：互斥锁-一次只能有一个线程访问；流量体-一次只能限制某个数量的线程访问；读写锁-读读不互斥，读写、写写互斥
// ⭐️ 不是“流量体”，是“信号量”
```
