---
layout:     post
title:     工作 数组方法统计
subtitle:  
date:       2020-03-20
author:     
header-img: 
catalog: true
tags:
    - < 工作遇到的问题记录 >
typora-root-url: ..
---


# 工作 数组方法统计

场景：遍历一个数组，找到满足条件的第一项后停止遍历。

参考：完全来自于MDN，只是简化成描述+语法，方便自己复习

总结：

除了抛出异常外，foreach的遍历不能中止；

some、find可以找到第一个返回true值之后停止；



> 返回新数组

**concat( )  合并数组** 

此方法不会更改现有数组，而是**返回一个新数组**。

```javascript
var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])
```

**copyWithin( )  同一数组内的浅复制**

浅复制数组的一部分到**同一数组**中的另一个位置，并返回它，**不会改变原数组的长度**。

```javascript
arr.copyWithin(target[, start[, end]])
// 如果 target 大于等于 arr.length，将会不发生拷贝。
```

**join( ) 连成一个字符串返回**

将一个数组（**或一个类数组对象**）的所有元素转换成字符串，再用分隔符连接，并返回这个字符串。

如果数组只有一个项目，那么将返回该项目而不使用分隔符；

如果一个元素为 `undefined` 或 `null`，它会被转换为空字符串；

```javascript
arr.join([separator])
```





> 改变原数组

**fill( )  固定值填充**

用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。**改变原数组**。

```javascript
arr.fill(value[, start[, end]])
```



> 遍历数组

**reduce( ) **

您的 **reducer** 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。

数组中的每一个元素依次执行`callback`函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：

- `accumulator 累计器`
- `currentValue 当前值`
- `currentIndex 当前索引`
- `array 数组`

回调函数第一次执行时，`accumulator` 和`currentValue`的取值有两种情况：如果调用`reduce()`时提供了`initialValue`，`accumulator`取值为`initialValue`，`currentValue`**取数组中的第一个值**；如果没有提供 `initialValue`，那么`accumulator`取数组中的第一个值，`currentValue`**取数组中的第二个值**。

```javascript
arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])
```

```javascript
// 按属性对Object进行分类
var people = [{ name: 'Alice', age: 21 },{ name: 'Max', age: 20 },{ name: 'Jane', age: 20 }];

function groupBy(objectArray, property) {
  return objectArray.reduce(function (acc, obj) {
    var key = obj[property];
    if (!acc[key]) {
      acc[key] = [];
    }
    acc[key].push(obj);
    return acc;
  }, {});
}

var groupedPeople = groupBy(people, 'age');
// groupedPeople is:
// { 
//   20: [
//     { name: 'Max', age: 20 }, 
//     { name: 'Jane', age: 20 }
//   ], 
//   21: [{ name: 'Alice', age: 21 }] 
// }
```

```javascript
// 按序运行Promise
function runPromiseInSequence(arr, input) {
  return arr.reduce(
    (promiseChain, currentFunction) => promiseChain.then(currentFunction),
    Promise.resolve(input)
  );
}

// promise function 1
function p1(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 5);
  });
}

// promise function 2
function p2(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 2);
  });
}

// function 3  - will be wrapped in a resolved promise by .then()
function f3(a) {
 return a * 3;
}

// promise function 4
function p4(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 4);
  });
}

const promiseArr = [p1, p2, f3, p4];
runPromiseInSequence(promiseArr, 10)
  .then(console.log);   // 1200
```

```javascript
// 使用reduce实现map
if (!Array.prototype.mapUsingReduce) {
  Array.prototype.mapUsingReduce = function(callback, thisArg) {
    return this.reduce(function(mappedArray, currentValue, index, array) {
      mappedArray[index] = callback.call(thisArg, currentValue, index, array);
      return mappedArray;
    }, []);
  };
}

[1, 2, , 3].mapUsingReduce(
  (currentValue, index, array) => currentValue + index + array.length
); // [5, 7, , 10]
```



**every( )  遍历检测**

测试一个数组内的所有元素是否都能通过某个指定函数的测试。它**返回一个布尔值**。

```javascript
arr.every(callback[, thisArg])
```

**filter( )  过滤器**

创建一个新数组，其包含能够通过所提供函数进行测试的所有元素。

```javascript
var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])
```

**find( )  找第一个元素的值**

返回数组中满足提供的测试函数的第一个元素的值。否则返回`undefined`。

```javascript
arr.find(callback[, thisArg])
```

**flat( )  扁平化数组/移除数组空项**

按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为**一个新数组返回**。

```javascript
var newArray = arr.flat([depth]);//depth使用Infinity，可展开任意深度的嵌套数组
```

**flatMap( )  **

首先使用映射函数映射每个元素，然后将结果压缩成一个**新数组**。

它与 map 连着深度值为1的 flat几乎相同，但 `flatMap` 通常在合并成一种方法的效率稍微高一些。

```javascript
var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) {
    // return element for new_array
}[, thisArg])
```

**map( )  遍历**

**创建一个新数组**，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。

`map` 方法会给原数组中的每个元素都按顺序调用一次  `callback` 函数。

注意：map中callback是有三个参数的，以下情况一定要注意，给parseInt传了`(value,index)`

![image-20200331113844043](/img/assets_2019/image-20200331113844043.png)

```javascript
var new_array = arr.map(function callback(currentValue[, index[, array]]) {
 // Return element for new_array 
}[, thisArg])
```

**forEach( )  遍历**

对数组的每个元素执行一次给定的函数。

```javascript
arr.forEach(callback(currentValue [, index [, array]])[, thisArg])
```

**includes( )  是否包含指定值**

判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。

```javascript
arr.includes(valueToFind[, fromIndex]);//开始查找的位置
```

**keys( )  新的Array迭代器对象**

返回一个包含数组中每个索引键的`Array Iterator`对象。

```javascript
arr.keys()
```



**pop( ) 删除并返回最后一个元素**

从数组中删除最后一个元素，并返回该元素的值。此方法**更改数组的长度**。

**push( )  返回数组新长度**

将一个或多个元素添加到数组的末尾，并返回该数组的**新长度**。

```javascript
// 合并两个数组，结合apply
var vegetables = ['parsnip', 'potato'];
var moreVegs = ['celery', 'beetroot'];

// 相当于 vegetables.push('celery', 'beetroot');
Array.prototype.push.apply(vegetables, moreVegs);
```





**findIndex( )  找第一个元素的索引**

返回数组中满足提供的测试函数的第一个元素的**索引**。否则返回-1。

```javascript
arr.findIndex(callback[, thisArg])
```

**indexOf( )  返回首个索引**

返回在数组中可以找到一个给定元素的**第一个索引**；如果不存在，则返回-1。

```javascript
arr.indexOf(searchElement[, fromIndex])
```

**lastIndexOf( )  返回最后一个索引**

返回指定元素在数组中的最后一个的索引，如果不存在则返回 -1。

从数组的后面向前查找，从 `fromIndex` 处开始。

```javascript
arr.lastIndexOf(searchElement[, fromIndex])
```











