---
layout:     post
title:      Object属性排序、与Map的区别
subtitle:  
date:       2021-09-09
author:     
header-img: 
catalog: true
tags:
    - < JS原生基础相关 >
    - < LTN1 >
typora-root-url: ..
---

## Object属性排序、与Map的区别

<img src="/../img/assets_2023/image-20241103200316638.png" alt="image-20241103200316638" style="zoom:23%;" />

##### 1、Object 中各属性排序规则

<img src="/../img/assets_2023/image-20241024095830999.png" alt="image-20241024095830999" style="zoom:50%;" />

- **非负整数** 会最先被列出，排序是从小到大的数字顺序
- 正数字 > 字符串 > 负整数 > 浮点数 > `Symbol`，顺序是根据插入的顺序
- **隐式字符串化**：当对象的键也被设置为属性时，会字符串化一个对象 - `[object Object]`;

##### 2、JSON 默认不支持 Map，但是可以转一层

若想要通过 `JSON` 传输 `Map` 则需要使用到 `.toJSON()` 方法，然后在 `JSON.parse()` 中传入复原函数来将其复原。详细可以看下 [JSON 的序列化和解析](https://link.zhihu.com/?target=https%3A//juejin.cn/post/6931927132427780103%23heading-5)

|           | Object                                                       | Map                                                          |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义      | 1、键的类型：只能是**字符串/Symbol**<br>2、顺序：不会完全保持插入时的顺序<br>3、『<u>计算长度绕</u>』：`Object.keys(testObj).length`<br>4、『<u>默认不可迭代</u>』，只支持 `for-in` 访问<br>5、可以覆盖原型上的键<br/>6、`JSON` 默认支持 `Object` | 1、键的类型：**任何类型**<br/>2、**保持其插入时的顺序**<br/>3、『<u>计算长度简单</u>』：`mapObj.size()`<br/>4、『<u>**可迭代对象**</u>』，支持 `for-of`<br/>5、不会覆盖原型上的键<br/>6、`JSON` 默认不支持 `Map` |
| 操作      | 1、创建<br>`let o = {}; // 对象字面量 `<br/>`let o = new Object(); // 构造函数`<br/>`let o = Object.create(null); // 静态方法 `<br/>2、新增/修改元素<br>`o.x=1;o['y'] = 2;`<br>3、读取元素<br>`o.x;o['y']; ` 或者 <br>4、删除元素<br>`delete o.b;` | 1、创建：<br>`let map = new Map().set('a', 1); // 构造函数`<br>2、新增/修改元素<br>`map.set('x', 1); `<br/>3、读取元素<br/>`map.get('x');`<br/>4、删除元素<br/>` map.delete('b');` |
| 性能      |                                                              | **Map性能比Object好**（占用内存小，增删速度更快）            |
| 适合 场景 | 1、只是 **简单的数据结构** 时（在数据少的时候占用内存更少，新建更为高效） <br/>2、需要用到 `JSON` 进行文件传输时（ `JSON` 不默认支持 `Map`） <br/>3、需要对**多个键值进行运算**时（语法更简洁） <br/>4、需要 **覆盖原型** 上的键时 | 1、**储存的键**不是字符串/数字/ `Symbol` 时<br/>2、储存 **大量的数据** 时（占用的内存更小） <br/>3、需要进行许多 **新增/删除元素的操作**时（速度更快） <br/>4、需要 **保持插入时的顺序** <br/>5、需要 **迭代**（默认可迭代对象） |



